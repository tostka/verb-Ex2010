# verb-ex2010.psm1


<#
.SYNOPSIS
VERB-Ex2010 - Exchange 2010 PS Module-related generic functions
.NOTES
Version     : 6.5.4
Author      : Todd Kadrie
Website     :	https://www.toddomation.com
Twitter     :	@tostka
CreatedDate : 1/16.5.40
FileName    : VERB-Ex2010.psm1
License     : MIT
Copyright   : (c) 1/16.5.40 Todd Kadrie
Github      : https://github.com/tostka
REVISIONS
* 11:22 AM 3/13/2020 Get-ExchangeServerInSite added a ping-test, to only return matches that are pingable, added -NoPing param, to permit (faster) untested bypass
* 6:25 PM 1/21/2020 - 1.0.0.1, rebuild, see if I can get a functional module out
* 1/16.5.40 - 1.0.0.0
# 7:31 PM 1/15/2020 major revise - subbed out all identifying constants, rplcd regex hardcodes with builds sourced in tor-incl-infrastrings.ps1. Tests functional.
# 11:34 AM 12/30/2019 ran vsc alias-expansion
# 7:51 AM 12/5/2019 Connect-Ex2010:retooled $ExAdmin variant webpool support - now has detect in the server-pick logic, and on failure, it retries to the stock pool.
# 10:19 AM 11/1/2019 trimmed some whitespace
# 10:05 AM 10/31/2019 added sample load/call info
# 12:02 PM 5/6.5.49 added cx10,rx10,dx10 aliases
# 11:29 AM 5/6.5.49 load-EMSLatest: spliced in from tsksid-incl-ServerApp.ps1, purging ; alias Add-EMSRemote-> Connect-Ex2010 ; toggle-ForestView():moved from tsksid-incl-ServerApp.ps1
# * 1:02 PM 11/7/2018 updated Disconnect-PssBroken
# 4:15 PM 3/24/2018 updated pshhelp
# 1:24 PM 11/2/2017 fixed connect-Ex2010 example code to include $Ex2010SnapinName vari for the snapin name (regex no worky for that)
# 1:33 PM 11/1/2017 add load-EMSSnapin (for use on server desktops)
# 11:37 AM 11/1/2017 shifted get-GcFast into here
# 9:29 AM 11/1/2017 spliced in Get-ExchangeServerInSite with updated auto-switch for ADL|SPB|LYN runs
# 8:02 AM 11/1/2017 updated connect-ex2010 & disconnect-ex2010 (add/remove-PSTitlebar), added disconnect-PssBroken
# 1:28 PM 12/9/2016: Reconnect-Ex2010, put in some logic to suppress errors
# 1:05 PM 12/9/2016 updated the docs & comments on new connect-Ex2010;Reconnect-Ex2010;Disconnect-Ex2010;Get-ExchangeServerInSite;Disconnect-PssBroken funcs and bp CALL code into function
# 11:03 AM 12/9/2016 debugged the new connect-Ex2010;Reconnect-Ex2010;Disconnect-Ex2010;Get-ExchangeServerInSite;Disconnect-PssBroken funcs and bp CALL code into function
.DESCRIPTION
VERB-Ex2010 - Exchange 2010 PS Module-related generic functions
.INPUTS
None
.OUTPUTS
None
.EXAMPLE
.EXAMPLE
.LINK
https://github.com/tostka/verb-Ex2010

#>


    $script:ModuleRoot = $PSScriptRoot ;
    $script:ModuleVersion = (Import-PowerShellDataFile -Path (get-childitem $script:moduleroot\*.psd1).fullname).moduleversion ;
    $runningInVsCode = $env:TERM_PROGRAM -eq 'vscode' ;

#*======v FUNCTIONS v======




#*------v add-MailboxAccessGrant.ps1 v------
function add-MailboxAccessGrant {
    <#
    .SYNOPSIS
    add-MailboxAccessGrant.ps1 - Add Mbx Access to a specified mailbox
    .NOTES
    Version     : 1.0.2
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-
    FileName    :
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Exchange,Permissions,Exchange2010
    REVISIONS
    # 5:12 PM 10/13/2021 fixed long standing random add-adgroupmember bug (failed to see target sg/dg), by swapping in ADGM ex cmd;  pulled [int] from $ticket , to permit non-numeric & multi-tix
    # 11:36 AM 9/16/2021 string
    # 10:27 AM 9/14/2021 beefed up echos w 7pswhsplat's pre
    # 3:21 PM 8/17/2021 recoded grabbing outputs, on object creations in EMS, tho' AD object creations generate no proper output. functoinal on current ticket.
    # 4:48 PM 8/16/2021 still wrestling grant fails, switched the *permission -user targets to the dg object.primarysmtpaddr (was adg.samaccountname), if the adg.sama didn't match the alias, that woulda caused failures. Seemd to work better in debugging
    # 1:51 PM 6/30/201:51 PM 6/30/2021 trying to work around sporadic $oSG add-mailboxperm fails, played with -user $osg designator - couldn't use DN, went back to samacctname, but added explicit RETRY echos on failretries (was visible evid at least one retry was in mix) ; hardened up the report gathers - stuck thge get-s in a try/catch ahead of echos, (vs inlines) ; we'll see if the above improve the issue - another option is to build something that can parse the splt echo back into a functional splat, to at least make remediation easier (copy, convert, rerun on fly).
    # 4:21 PM 5/19/2021 added -ea STOP to splats, to force retry's to trigger
    # 5:03 PM 5/18/2021 fixed the fundementally borked start-log I created below
    # 11:10 AM 5/11/2021 swapped parentpath code for dyn module-support code (moving the new-mailboxgenerictor & add-mbxaccessgrant preproc .ps1's to ex2010 mod functions)
    # 11:20 AM 4/21/2021 fixed/suppressed noisy verbose calls
    # 8:34 AM 3/31/2021 added verbose suppress to all import-mods
    # 1:27 PM 4/23/2020 updated loadmod & dynamic logging/exec code
    # 4:28 PM 4/22/2020 updated logging code, to accomodate dynamic locations and $ParentPath
    # 3:37 PM 4/9/2020 works fully on jumpbox, but ignores whatif, renamed $bwhatif -> $whatif (as the b variant was prev set in the same-script, now separate scopes); swapped out CU5 switch, moved settings into infra file, genericized
    # 1:38 PM 4/9/2020 modularized updated to reflect debugging on jumpbox
    # 9:57 AM 9/27/2019 added `a beep to all "YYY" prompts to draw attn
    # 12:50 PM 6/13/2019 repl get-timestamp() -> Get-Date -Format 'HH:mm:ss' throughout
    # 11:05 AM 6/13/2019 updated get-admininitials()
    # 2:19 PM 4/29/2019 add global.ad.torolab.com to the domain param validateset on get-gcfast copy (sync'd in from verb-ex2010.ps1 vers)
    # 11:43 AM 2/15/2019 debugged update through a prod revision
    # 11:15 AM 2/15/2019 copied in bug-fixed write-log() with fixed debug support
    # 10:41 AM 2/15/2019 updated write-log to latest deferring version
    # 10:39 AM 2/15/2019 added full write-log logging support
    # 3:24 PM 2/6/2019 #1416:needs -prop * to pull msExchRecipientDisplayType,showInAddressBook,mail etc
    # 8:36 AM 9/6/2018 switched secgrp to Global->Universal scope, mail-enabled as DG, and hiddenfromaddressbook, debugged out issues, used in prod creation
    # 10:28 AM 6/27/2018 add $domaincontroller param option - skips dc discovery process and uses the spec, also updated $findOU code to work with torolab dom
    # 11:05 AM 3/29/2018 #1116: added trycatch, UST lacked the secgrp ou and was failing ou lookup
    # 10:31 AM 11/22/2017 shifted a block of "User mbx grant:" confirmation into review block, also tightened up the formatted whitespace to make the material pasted into cw reflect all that you need to know on the grant status. also added distrib code
    # 1:17 PM 11/15/2017 949: no, this needs to be the obj (was extracting samaccountname)
    # 12:35 PM 11/15/2017 debugged EXO-hosted Owner code to function. worked granting lynctest18 (exo) access to shared 'SharedTestEXOOwner' OP
    # 11:58 AM 11/15/2017 945: accommodate EXO-hosted Owners by testing with get-remotemailbox -AND get-mailbox on the owner spec.
    # 12:57 PM 9/25/2017 standardized mbxp & adperm field output and format i the review settings block
    # 11:29 AM 6/23/2017 fix typos, added 'DomainControler', without the vari-spec $
    # 8:16 AM 6/23/2017 we're getting mismatches/misses on AD work - prolly because we're using the -server $domain, rather than a SPECIFIC GC! replic lag is killing us!
    #   switch to the same gc the Ex cmds are using
    #   rplc -server $($InputSplat.Domain)  -> -server $($InputSplat.DomainController)
    #   rplc -server $Domain -> -server $($DomainController)
    # 1:41 PM 6/13/2017 spliced in latest 3/16/16 get-gcfast()
    # 1:37 PM 5/30/2017 855: pretest get-command, fails if it doesn't even have it at all
    # 1:21 PM 5/30/2017 1484: block that adds the $tmbx to the maintain-offboards.ps1 target AccGrant group for the region
    # 1:20 PM 5/30/2017 pencil in new AG group add when grant is done.
    # 11:27 AM 5/22/2017 add $NoPrompt
    # 9:44 AM 3/2/2017 suppress ID null errors on close BP
    # 9:07 AM 3/2/2017: Example code:  Don't force load EMS/Add-EMSRemote if there's an existing functional get-exchangeserver command (suppress clobber errors)
    # 9:41 AM 3/2/2017 merged in updated Add-EMSRemote Set
    # 9:07 AM 3/2/2017: Add-EMSRemote set: Example code:  Don't force load EMS/Add-EMSRemote if there's an existing functional get-exchangeserver command (suppress clobber errors)
    # 9:07 AM 3/2/2017 Don't force load EMS/Add-EMSRemote if there's an existing functional get-exchangeserver command (suppress clobber errors)
    # 12:15 PM 2/27/2017 trailing membership test was still failing, tore out blocks of new code and recycled what's used up in the Existing quote who cares if it's a DN vs a name
    # 12:11 PM 2/27/2017 fixed compat in SPB (prolly ADL too) - resolved any Owner entered as email, to the samaccountname ; #1081: drop the pipe!
     $oSG | Get-ADGroupMember -server $Domain | select distinguishedName ; #1263 threw up trying to do the get-aduser on the members, # 1283 replace user lookup with this (skip the getxxx member, pull members right out of properties)
    # 1:04 PM 2/24/2017 tweak below
    #12:56 PM 2/24/2017 doesn't run worth a damn LYN-> adl/spb, force it to abort (avoid half-built remote objects that take too long to replicate back to lyn)
    # 12:24 PM 2/24/2017 fixed updated membership report bug - pulled pipe, probably dehydrated object issue sin remote ps
    # 12:11 PM 2/24/2017 fix vscode/code.exe char set damage: It replaced dashes (-) with "ï¿½"
    # fix -join typo/damage
    # 12:44 PM 10/18/2016 update rgx for ticket to accommodate 5-digit (or 6) CW numbers "^\d{6}$"=>^\d{5,6}$
    # 9:11 AM 9/30/2016 added pretest if(get-command -name set-AdServerSettings -ea 0)
    # # 12:22 PM 6/21/2016 secgrp membership seldom comes through clean, add a refresh loop
    # 10:52 AM 6/20/2016 fixed typo $InputSplatSiteOverride => $InputSplat.SiteOverride (broke -SiteOverride function)
    # 11:02 AM 6/7/2016 updated get-aduser review cmds to use the same dc, not the -domain global.ad.toro.com etc
    # 1:34 PM 5/26/2016 confirmed/verified works fine with SPB-hosted mbx under 376336 issitjx
    # 11:45 AM 5/19/2016 corrected $tmbx ref's to use $tmbx.identity v. $tmbx.samaccountname, now working. Retry code in place for SPB, but it didn't trigger during testing
    # 2:37 PM 5/18/2016 implmented Secgrp OU and Secgrp stnd name
    # 2:28 PM 5/18/2016 With the recent AD changes, all email access groups should be named         XXX-SEC-Email-firstname lastname-G     and stored in XXX\Managed Groups\SEC Groups\Email Access.     The generics were also renamed to XXX\Generic Email Accounts.
    # 2:17 PM 5/10/2016 used successfully to set a LYN manager perm's on an SPBMS640Mail02-hosted user. didn't time out, Set-MailboxPermission command completed after ~3 secs
    #     fixed bad param example, remmed out non-functional Owner in the SGSplat (nosuch param), and re-enabled the ManagedBy on the SG - it's not a mbx,
    #     so why not set ManagedBy, doesn't get used by the org chart in SP
    # 2:38 PM 3/17/2016 stop populating anything into any managed-by; it's an OrgChart political value now. Rename ManagedBy param and object names in here to 'Owner'
    # 1:12 PM 2/11/2016 fixed new bug in get-GCFast, wasn't detecting blank $site
    # 12:20 PM 2/11/2016 updated to standard EMS/AD Call block & Add-EMSRemote()
    # 9:36 AM 2/11/2016 just shifting to a single copy, with no # Requires at all, losing the -psv2.ps1 version
    # 2:23 PM 2/10/2016 debugged mismatched {}, working from SPB now
    # 1:54 PM 2/10/2016 recoded to work on SPB and ADL, this version just needs the #Requires -Version 3 for psv2 enabled to be a psv3 version
    #         added fundemental upgrade to the AD Site detection, to work from SPB/Spellbrook and ADL Adeliade
    # 12:07 PM 2/10/2016 Psv2 variant - at this point, the only real diff is the rem'd rem'd #Requires -Version 3 for psv2
    # 7:40 AM Add-EMSRemote: 2/5/2016 another damn cls REM IT! I want to see all the connectivity info, switched wh->wv, added explicit echo's of what it's doing.
    # 10:41 AM 1/13/2016 updated Add-EMSRemote set & removed Clear-Host's
    # 10:02 AM 1/13/2016: fixed cls bug due to spurious ";cls" included in the try/catch boilerplate: Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;cls => Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;
    # 1:02 PM 12/18/2015 missing SYD as well
    # 11:42 AM 12/18/2015: building a Psv2-compliant version (-psv2.ps1):

    - sub out all [ordered] (-psv2 only)
    - rem'd #Requires -Version 3 (-psv2 only)
    - added explicit .tostring() in front of all string handlers (.substring() etc) (added to both versions)
    # 3:08 PM 10/29/2015 added in XIA aware from other recent script updates, and -server xxx to all get-ad* that didn't have it
    #2:49 PM 10/29/2015 add entire MEL site, nothing in the OU or Secgrp name switch blocks
    # 9:08 AM 10/14/2015 added debugpref maint code to get write-debug to work
    # 8:04 AM 10/14/2015 add sendAS adperms
    # 7:31 AM 10/14/2015 added -dc specs to all *-user & *-mailbox cmds, to ensure we're pulling back data from same dc that was updated in the set-* commands
    # 7:19 AM 10/14/2015 fixed some typos, made sure all $InputSplat.domaincontroller were $()'d
    # 9:13 AM 10/12/2015 force $Grantsplat=$Tmbx to use $Tmbx.Samacctname, defaulting to displayname which isn't consistently resolvable, samacctname should be.
    # 1:17 PM 10/6/2015 update to spec, seems to work
    # splice in Add-EMSRemote set & get-gcfast
    # 10:49 AM 10/6/2015: updated vers of Get-AdminInitials
    # 2:49 PM 10/2/2015 updated catch block to be detailed
    # 10:57 AM 8/14/2015 defaulted PermsDays to 60 (was going to 999)
    # 10:46 AM 8/14/2015 add param examples for the PermsDays spec
    # 9:35 AM 8/14/2015 updated params examples to reflect use of -ticket & -siteoverride
    # 11:00 AM 8/12/2015 also add an Info ref for the admin doing the work
    # 10:37 AM 8/12/2015 I see from dumping all matching secgrps ...
      $AllSGs = Get-ADGroup  -filter {GroupCategory  -eq "Security"  -and GroupScope -eq "Global"} -properties info,description;
      $AllSGs = $AllSgs |?{$_.Name -match "^\w{3}-(SEC|Data)-Email-.*$"} ; ($AllSGs | measure).count ;
      # have to 2-stage filter as the get-adgroup -filter has no -match regex operator support
      ... that dawn used to use these, oldest record I see, was from 2005, most recent appears to have been 2011. But she was recording sometimes recording the incident req# - which is a useful item to include (esp if you don't want folks monkeyin with the Notes/Info
      value and breaking automation to clean these up!).
      So we need to add incident number to the add-MbxAccessGrant.ps1, that means a parameter and a 3rd line in the Info append
    #11:32 AM 8/5/2015 fixed trailing ) in Updated IRO-SEC-Email-Jodie Gilroy-G)
    #11:43 AM 7/20/2015 line 197added a :space after displayname:
    # 12:18 PM 7/17/2015 added -ea silentlycontinue to get-mailboxpermission - it was causing it to bomb script when no match found
    # 1:55 PM 6/15/2015 initial version
    .DESCRIPTION
    .PARAMETER TargetID
    Target Mailbox for Access Grant[name,emailaddr,alias]
    .PARAMETER SecGrpName
    Custom override default generated name for Perm-hosting Security Group[[SIT]-SEC-Email-[DisplayName]-G]
    .PARAMETER Owner
    Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]
    .PARAMETER SiteOverride
    Specify a 3-letter Site Code. Used to force DL name/placement to vary from TargetID's current site[3-letter Site code]
    .PARAMETER PermsDays
    Specify the number of day's the access-grant should be in place. (60 default. 999=permanent)[30-60,999]")]
    .PARAMETER Members
    Comma-delimited string of potential users to be granted access[name,emailaddr,alias]
    .PARAMETER ticket
    Incident number for the change request[[int]nnnnnn]
    .PARAMETER NoPrompt
    Suppress YYY confirmation prompts
    .PARAMETER domaincontroller
    Option to hardcode a specific DC [-domaincontroller xxxx]
    .PARAMETER ParentPath
    Calling script path (used for log construction)[-ParentPath c:\pathto\script.ps1]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowProgress
    Parameter to display progress meter [-ShowProgress switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    .\add-MailboxAccessGrant -ticket 123456 -SiteOverride LYN -TargetID lynctest13 -Owner SOMERECIP -PermsDays 999 -members "lynctest16,lynctest18" -showDebug -whatIf ;
    Parameter Whatif test with Debug messages displayed
    .EXAMPLE
    $pltInput=[ordered]@{} ;
    if ($PSCommandPath) { $pltInput.add("ParentPath", $PSCommandPath) } ;
    if($TargetID){$pltInput.add("TargetID",$TargetID) } ;
    if($SecGrpName){$pltInput.add("SecGrpName",$SecGrpName) } ;
    if($Owner){$pltInput.add("Owner",$Owner) } ;
    if($PermsDays){$pltInput.add("PermsDays",$PermsDays) } ;
    if($SiteOverride){$pltInput.add("SiteOverride",$SiteOverride) } ;
    if($Members){$pltInput.add("Members",$Members) } ;
    if($Ticket){$pltInput.add("Ticket",$Ticket) } ;
    if($NoPrompt){$pltInput.add("NoPrompt",$NoPrompt) } ;
    if($domaincontroller){$pltInput.add("domaincontroller",$domaincontroller) } ;
    if($showDebug){$pltInput.add("showDebug",$showDebug) } ;
    if($whatIf){$pltInput.add("whatIf",$whatIf) } ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):add-MbxAccessGrant w`n$(($pltInput|out-string).trim())" ;
    add-MbxAccessGrant @pltInput
    Splatted version
    .LINK
    https://github.com/tostka/verb-Ex2010/
    #>


    <# SecGrp Name spec: =
    2:29 PM 5/18/2016updated per dawn:
            XXX-SEC-Email-firstname lastname-G
    # orig spec:
    ($sSite + "-Data-Email-" + $Tmbx.DisplayName + "-G") ;
    Create the grp :Scope: Global, Type:Secureity
    Add members.
    Add mbx permission to the grp:
    add-mailboxpermission "bossvisiplex" -User "IRO-Data-Email-Boss Visiplex" -AccessRights FullAccess -whatif ;
    #>


    [CmdletBinding()]
    Param(
        [Parameter(HelpMessage = "Target Mailbox for Access Grant[name,emailaddr,alias]")]
        [string]$TargetID,
        [Parameter(HelpMessage = "Custom override default generated name for Perm-hosting Security Group[[SIT]-SEC-Email-[DisplayName]-G]")]
        [string]$SecGrpName,
        [Parameter(HelpMessage = "Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]")]
        [string]$Owner,
        [Parameter(HelpMessage = "Specify the number of day's the access-grant should be in place. (60 default. 999=permanent)[30-60,999]")]
        [ValidateRange(7, 999)]
        [int]$PermsDays,
        [Parameter(HelpMessage = "Specify a 3-letter Site Code. Used to force DL name/placement to vary from TargetID's current site[3-letter Site code]")]
        [string]$SiteOverride,
        [Parameter(HelpMessage = "Comma-delimited string of potential users to be granted access[name,emailaddr,alias]")]
        [string]$Members,
        [Parameter(HelpMessage = "Incident number for the change request[[int]nnnnnn]")]
        # [int] # 10:30 AM 10/13/2021 pulled, to permit non-numeric & multi-tix
        $Ticket,
        [Parameter(HelpMessage = "Suppress YYY confirmation prompts [-NoPrompt]")]
        [switch] $NoPrompt,
        [Parameter(HelpMessage = "Option to hardcode a specific DC [-domaincontroller xxxx]")]
        [string]$domaincontroller,
        [Parameter(HelpMessage = "Calling script path (used for log construction)[-ParentPath c:\pathto\script.ps1]")]
        [string]$ParentPath,
        [Parameter(HelpMessage = 'Debugging Flag [$switch]')]
        [switch] $showDebug,
        [Parameter(HelpMessage = 'Whatif Flag [$switch]')]
        [switch] $whatIf
    ) ;

    # NoPrompt Suppress YYY confirmation prompts

    BEGIN {

        # don't use the LoadModFile(), it has scoping issues returning the mods, they aren't accessible outside the function itself

        $verbose = ($VerbosePreference -eq "Continue") ;
        # Get the name of this function
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $continue = $true ;
        switch -regex ($env:COMPUTERNAME){
            ($rgxMyBoxW){ $LocalInclDir="c:\usr\work\exch\scripts" ; }
            ($rgxProdEx2010Servers){ $LocalInclDir="c:\scripts" ; }
            ($rgxLabEx2010Servers){ $LocalInclDir="c:\scripts" ; }
            ($rgxProdL13Servers){ $LocalInclDir="c:\scripts" ; }
            ($rgxLabL13Servers){ $LocalInclDir="c:\scripts" ; }
        } ;
        $Retries = 4 ; # number of re-attempts
        $RetrySleep = 5 ; # seconds to wait between retries
        # $rgxCU5 = [infra file]
        # OU that's used when can't find any baseuser for the owner's OU, default to a random shared from ($ADSiteCodeUS) (avoid crapping out):
        $FallBackBaseUserOU = "$($DomTORfqdn)/($ADSiteCodeUS)/Generic Email Accounts" ;

        # strings are: "[tModName];[tModFile];tModCmdlet"
        $tMods = @() ;
        #$tMods+="verb-Auth;C:\sc\verb-Auth\verb-Auth\verb-Auth.psm1;get-password" ;
        $tMods+="verb-logging;C:\sc\verb-logging\verb-logging\verb-logging.psm1;write-log";
        $tMods+="verb-IO;C:\sc\verb-IO\verb-IO\verb-IO.psm1;Add-PSTitleBar" ;
        $tMods+="verb-Mods;C:\sc\verb-Mods\verb-Mods\verb-Mods.psm1;check-ReqMods" ;
        #$tMods+="verb-Desktop;C:\sc\verb-Desktop\verb-Desktop\verb-Desktop.psm1;Speak-words" ;
        #$tMods+="verb-dev;C:\sc\verb-dev\verb-dev\verb-dev.psm1;Get-CommentBlocks" ;
        $tMods+="verb-Text;C:\sc\verb-Text\verb-Text\verb-Text.psm1;Remove-StringDiacritic" ;
        #$tMods+="verb-Automation.ps1;C:\sc\verb-Automation.ps1\verb-Automation.ps1\verb-Automation.ps1.psm1;Retry-Command" ;
        #$tMods+="verb-AAD;C:\sc\verb-AAD\verb-AAD\verb-AAD.psm1;Build-AADSignErrorsHash";
        $tMods+="verb-ADMS;C:\sc\verb-ADMS\verb-ADMS\verb-ADMS.psm1;load-ADMS";
        $tMods+="verb-Ex2010;C:\sc\verb-Ex2010\verb-Ex2010\verb-Ex2010.psm1;Connect-Ex2010";
        #$tMods+="verb-EXO;C:\sc\verb-EXO\verb-EXO\verb-EXO.psm1;Connect-Exo";
        #$tMods+="verb-L13;C:\sc\verb-L13\verb-L13\verb-L13.psm1;Connect-L13";
        $tMods+="verb-Network;C:\sc\verb-Network\verb-Network\verb-Network.psm1;Send-EmailNotif";
        #$tMods+="verb-Teams;C:\sc\verb-Teams\verb-Teams\verb-Teams.psm1;Connect-Teams";
        #$tMods+="verb-SOL;C:\sc\verb-SOL\verb-SOL\verb-SOL.psm1;Connect-SOL" ;
        #$tMods+="verb-Azure;C:\sc\verb-Azure\verb-Azure\verb-Azure.psm1;get-AADBearToken" ;
        foreach($tMod in $tMods){
            $tModName = $tMod.split(';')[0] ;             $tModFile = $tMod.split(';')[1] ;             $tModCmdlet = $tMod.split(';')[2] ;
            $smsg = "( processing `$tModName:$($tModName)`t`$tModFile:$($tModFile)`t`$tModCmdlet:$($tModCmdlet) )" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if($tModName -eq 'verb-Network' -OR $tModName -eq 'verb-Text' -OR $tModName -eq 'verb-IO'){
                write-host "GOTCHA!:$($tModName)" ;
            } ;
            $lVers = get-module -name $tModName -ListAvailable -ea 0 ;
            if($lVers){                 $lVers=($lVers | Sort-Object version)[-1];                 try {                     import-module -name $tModName -RequiredVersion $lVers.Version.tostring() -force -DisableNameChecking -verbose:$($false)                 }   catch {                      write-warning "*BROKEN INSTALLED MODULE*:$($tModName)`nBACK-LOADING DCOPY@ $($tModDFile)" ;import-module -name $tModDFile -force -DisableNameChecking -verbose:$($false)                } ;
            } elseif (test-path $tModFile) {                 write-warning "*NO* INSTALLED MODULE*:$($tModName)`nBACK-LOADING DCOPY@ $($tModDFile)" ;                 try {import-module -name $tModDFile -force -DisableNameChecking -verbose:$($false)}                 catch {                     write-error "*FAILED* TO LOAD MODULE*:$($tModName) VIA $(tModFile) !" ;                     $tModFile = "$($tModName).ps1" ;                     $sLoad = (join-path -path $LocalInclDir -childpath $tModFile) ;                     if (Test-Path $sLoad) {                         Write-Verbose ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;                         . $sLoad ;                         if ($showdebug) { Write-Verbose "Post $sLoad" };                     } else {                         $sLoad = (join-path -path $backInclDir -childpath $tModFile) ;                         if (Test-Path $sLoad) {                             write-verbose  ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;                             . $sLoad ;                             if ($showdebug) { write-verbose  "Post $sLoad" };                         } else {                             Write-Warning ((Get-Date).ToString("HH:mm:ss") + ":MISSING:" + $sLoad + " EXITING...") ;                             exit;                         } ;                     } ;                 } ;             } ;
            if(!(test-path function:$tModCmdlet)){                 write-warning "UNABLE TO VALIDATE PRESENCE OF $tModCmdlet`nfailing through to `$backInclDir .ps1 version" ;                 $sLoad = (join-path -path $backInclDir -childpath "$($tModName).ps1") ;                 if (Test-Path $sLoad) {                     write-verbose ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;                     . $sLoad ;                     if ($showdebug) { Write-Verbose "Post $sLoad" };                     if(!(test-path function:$tModCmdlet)){                         write-warning "$((get-date).ToString('HH:mm:ss')):FAILED TO CONFIRM `$tModCmdlet:$($tModCmdlet) FOR $($tModName)" ;                     } else {                         write-verbose  "(confirmed $tModName loaded: $tModCmdlet present)"                     }                 } else {                     Write-Warning ((Get-Date).ToString("HH:mm:ss") + ":MISSING:" + $sLoad + " EXITING...") ;                     exit;                 } ;
            } else {                 write-verbose  "(confirmed $tModName loaded: $tModCmdlet present)"             } ;
        } ;  # loop-E
        #*------^ END MOD LOADS ^------

        <#
        if($ParentPath){
            $rgxProfilePaths='(\\Documents\\WindowsPowerShell\\scripts|\\Program\sFiles\\windowspowershell\\scripts)' ;
            if($ParentPath -match $rgxProfilePaths){
                $ParentPath = "$(join-path -path 'c:\scripts\' -ChildPath (split-path $ParentPath -leaf))" ;
            } ;
            $logspec = start-Log -Path ($ParentPath) -showdebug:$($showdebug) -whatif:$($whatif) -tag $TargetID;
            if($logspec){
                $logging=$logspec.logging ;
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
            } else {$smsg = "Unable to configure logging!" ; write-warning "$((get-date).ToString('HH:mm:ss')):$($sMsg)" ; Exit ;} ;
        } else {$smsg = "No functional `$ParentPath found!" ; write-warning "$((get-date).ToString('HH:mm:ss')):$($sMsg)" ;  Exit ;} ;
        #>
        # with shift of add-mbxaccessgrant preprocessor to mod func, the above needs to be recoded, as $ParentPath would wind up a module file
        # detect profile installs (installed mod or script), and redir to stock location
        $dPref = 'd','c' ; foreach($budrv in $dpref){ if(test-path -path "$($budrv):\scripts" -ea 0 ){ break ;  } ;  } ;
        [regex]$rgxScriptsModsAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
        [regex]$rgxScriptsModsCurrUserScope="^$([regex]::escape([environment]::getfolderpath('Mydocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
        # -Tag "($TenOrg)-LASTPASS" 
        $pltSLog = [ordered]@{ NoTimeStamp=$false ; Tag=$lTag  ; showdebug=$($showdebug) ;whatif=$($whatif) ;} ;
        if($PSCommandPath){
            if(($PSCommandPath -match $rgxScriptsModsAllUsersScope) -OR ($PSCommandPath -match $rgxScriptsModsCurrUserScope) ){
                # AllUsers or CU installed script, divert into [$budrv]:\scripts (don't write logs into allusers context folder)
                if($PSCommandPath -match '\.ps(d|m)1$'){
                    # module function: use the ${CmdletName} for childpath
                    $pltSLog.Path= (join-path -Path "$($budrv):\scripts" -ChildPath "$(${CmdletName}).ps1" )  ;
                } else { 
                    $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
                } ; 
            }else {
                $pltSLog.Path=$PSCommandPath ;
            } ;
        } else {
            if( ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsCurrUserScope) ){
                $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
            } else {
                $pltSLog.Path=$MyInvocation.MyCommand.Definition ;
            } ;
        } ;
        $smsg = "start-Log w`n$(($pltSLog|out-string).trim())" ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        $logspec = start-Log @pltSLog ;
        
        if($logspec){
            $logging=$logspec.logging ;
            $logfile=$logspec.logfile ;
            $transcript=$logspec.transcript ;
            
            if($whatif){
                $logfile=$logfile.replace("-BATCH","-BATCH-WHATIF") ;
                $transcript=$transcript.replace("-BATCH","-BATCH-WHATIF") ;
            } else {
                $logfile=$logfile.replace("-BATCH","-BATCH-EXEC") ;
                $transcript=$transcript.replace("-BATCH","-BATCH-EXEC") ;
            } ;
            if($Ticket){
                $logfile=$logfile.replace("-BATCH","-$($Ticket)") ;
                $transcript=$transcript.replace("-BATCH","-$($Ticket)") ;
            } else {
                $logfile=$logfile.replace("-BATCH","-nnnnnn") ;
                $transcript=$transcript.replace("-BATCH","-nnnnnn") ;
            } ;
            
            if(Test-TranscriptionSupported){
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                start-transcript -Path $transcript ;
            } ;
        } else {throw "Unable to configure logging!" } ;
        

        <#
        $sBnr="#*======v START PASS:$($ScriptBaseName) v======" ;
        $smsg= "$($sBnr)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
        #>

        $xxx = "====VERB====";
        $xxx = $xxx.replace("VERB", "NewMbxAccess") ;
        $BARS = ("=" * 10);
        #write-host -fore green ((get-date).ToString('HH:mm:ss') + ":===PASS STARTED=== ")


        $reqMods += "Add-PSTitleBar;Remove-PSTitleBar".split(";") ;
        #Disconnect-EMSR (variant name in some ps1's for Disconnect-Ex2010)
        #$reqMods+="Reconnect-CCMS;Connect-CCMS;Disconnect-CCMS".split(";") ;
        #$reqMods+="Reconnect-SOL;Connect-SOL;Disconnect-SOL".split(";") ;
        $reqMods += "Test-TranscriptionSupported;Test-Transcribing;Stop-TranscriptLog;Start-IseTranscript;Start-TranscriptLog;get-ArchivePath;Archive-Log;Start-TranscriptLog".split(";") ;
        # 12:15 PM 9/12/2018 remove dupes
        $reqMods = $reqMods | Select-Object -Unique ;

        #region SPLATDEFS ; # ------

        if (($host.version.major) -lt 3) {
            $InputSplat = @{
                TargetID     = "TARGETMBX";
                SecGrpName   = "";
                Owner        = "LYNCTEST2"
                PermsDays    = 60;
                SiteOverride = "";
                Members      = "LYNCTEST3"
            } ;
            # switch to EXO-compatible group type: Univ, mail-enable
            $SGSplat = @{
                Name            = "";
                DisplayName     = "";
                SamAccountName  = "";
                GroupScope      = "Global";
                GroupCategory   = "Universal";
                ManagedBy       = "";
                Description     = "";
                OtherAttributes = "";
                Path            = "";
                Server          = ""
            };
            $SGUpdtSplat = @{
                Identity = "";
                Server   = ""
            };
            $DGEnableSplat = @{
                Identity         = "";
                DomainController = "" ;
            } ;
            $DGUpdtSplat = @{
                Identity                      = "";
                HiddenFromAddressListsEnabled = $true ;
                DomainController              = "" ;
            } ;
            $GrantSplat = @{
                Identity        = "" ;
                User            = "" ;
                AccessRights    = "FullAccess";
                InheritanceType = "All";
            };
            # pulling id, pipeline it in
            $ADMbxGrantSplat = @{
                User           = "" ;
                ExtendedRights = "Send As" ;
            };
        } else {
            # psv3 code
            $InputSplat = [ordered]@{
                TargetID     = "TARGETMBX";
                SecGrpName   = "";
                Owner        = "LYNCTEST2"
                PermsDays    = 60;
                SiteOverride = "";
                Members      = "LYNCTEST3"
            } ;
            $SGSplat = [ordered]@{
                Name            = "";
                DisplayName     = "";
                SamAccountName  = "";
                GroupScope      = "Universal";
                GroupCategory   = "Security";
                ManagedBy       = "";
                Description     = "";
                OtherAttributes = "";
                Path            = "";
                Server          = ""
                ErrorAction     = 'STOP' # need this to trigger retries
            };
            $SGUpdtSplat = [ordered]@{
                Identity = "";
                Server   = ""
                ErrorAction     = 'STOP' # need this to trigger retries
            };
            $DGEnableSplat = [ordered]@{
                Identity         = "";
                DomainController = ""
                ErrorAction     = 'STOP' # need this to trigger retries
            };
            $DGUpdtSplat = [ordered]@{
                Identity                      = "";
                HiddenFromAddressListsEnabled = $true ;
                DomainController              = "" ;
                ErrorAction     = 'STOP' # need this to trigger retries
            } ;
            $GrantSplat = [ordered]@{
                Identity        = "" ;
                User            = "" ;
                AccessRights    = "FullAccess";
                InheritanceType = "All";
                ErrorAction     = 'STOP' # need this to trigger retries
            };
            # add for AD SendAs perms grant
            #pulling id, pipeline it in
            $ADMbxGrantSplat = [ordered]@{
                User           = "" ;
                ExtendedRights = "Send As" ;
                ErrorAction     = 'STOP' # need this to trigger retries
            };
        }

        if ($TargetID) { $InputSplat.TargetID = $TargetID };
        if ($SecGrpName) { $InputSplat.SecGrpName = $SecGrpName };
        if ($Owner) { $InputSplat.Owner = $Owner };
        if ($PermsDays) { $InputSplat.PermsDays = $PermsDays };
        if ($SiteOverride) { $InputSplat.SiteOverride = $SiteOverride };
        if ($Members) { $InputSplat.Members = $Members };

        $smsg = "`nSpecified Target Email: $($InputSplat.TargetID)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn

        #endregion SPLATDEFS ; # ------
        #region LOADMODS ; # ------
        $rgxExoPsHostName="^(ps\.outlook\.com|outlook\.office365\.com)$" ;
        #$rgxEx10HostName=[infra file]
        $rgxRemsPssName="^(Exchange2010|Session\sfor\simplicit\sremoting\smodule\sat\s.*)" ;
        $rgxSnapPssname="^Session\d{1}$" ;
        $rgxEx2010SnapinName="^Microsoft\.Exchange\.Management\.PowerShell\.E2010$";
        $Ex2010SnapinName="Microsoft.Exchange.Management.PowerShell.E2010" ;

        #
        #LEMS detect: IdleTimeout -ne -1
        if(get-pssession |Where-Object{($_.configurationname -eq 'Microsoft.Exchange') -AND ($_.ComputerName -match $rgxEx10HostName) -AND ($_.IdleTimeout -ne -1)} ){
            write-verbose  "$((get-date).ToString('HH:mm:ss')):LOCAL EMS detected" ;
            $Global:E10IsDehydrated=$false ;
        # REMS detect dleTimeout -eq -1
        } elseif(get-pssession |Where-Object{$_.configurationname -eq 'Microsoft.Exchange' -AND $_.ComputerName -match $rgxEx10HostName -AND ($_.IdleTimeout -eq -1)} ){
            write-verbose  "$((get-date).ToString('HH:mm:ss')):REMOTE EMS detected" ;
            $reqMods+="get-GCFast;Get-ExchangeServerInSite;connect-Ex2010;Reconnect-Ex2010;Disconnect-Ex2010;Disconnect-PssBroken".split(";") ;
            if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
            reconnect-ex2010 ;
            $Global:E10IsDehydrated=$true ;
        } else {
            write-verbose  "$((get-date).ToString('HH:mm:ss')):No existing Ex2010 Connection detected" ;
            # Server snapin defer
            if(($host.version.major -lt 3) -AND (get-service MSExchangeADTopology -ea SilentlyContinue)){
                write-verbose "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Loading Local Server EMS10 Snapin" ;
                $reqMods+="Load-EMSSnap;load-EMSLatest".split(";") ;
                if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
                Load-EMSSnap ;
                $Global:E10IsDehydrated=$false ;
            } else {
                # if you want REMS - (assumed on new scripts)
                $reqMods+="connect-Ex2010;Reconnect-Ex2010;Disconnect-Ex2010;Get-ExchangeServerInSite;Disconnect-PssBroken".split(";") ;
                if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
                reconnect-ex2010 ;
                $Global:E10IsDehydrated=$true ;
            } ;
        } ;
        #

        # load ADMS
        $reqMods+="load-ADMS;get-AdminInitials".split(";") ;
        if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
        write-verbose  "$((get-date).ToString('HH:mm:ss')):(loading ADMS...)" ;
        load-ADMS -cmdlet get-aduser,Set-ADUser,Get-ADGroupMember,Get-ADDomainController,Get-ADObject,get-adforest | out-null ;

        $AdminInits=get-AdminInitials ;

        #region LOADMODS ; # ------

    }  # BEG-E ;

    PROCESS {

        #region DATAPREP ; # ------

        $Tmbx = (get-mailbox $($InputSplat.TargetID) -domaincontroller (Get-ADDomainController).Name.tostring() -ea stop) ;
        $GrantSplat.Identity = $($Tmbx.samaccountname);
        $domain = $Tmbx.identity.tostring().split("/")[0]
        $InputSplat.Add("Domain", $($domain) ) ;
        if (!$domaincontroller) {
            $domaincontroller = (get-gcfast -domain $domain) ;
        } else {
            $smsg = "Using hard-coded domaincontroller:$($domaincontroller)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
        } ;

        $InputSplat.Add("DomainController", $domaincontroller) ;
        $SGUpdtSplat.Server = $($InputSplat.DomainController);
        $DGEnableSplat.DomainController = $($domaincontroller);
        $DGUpdtSplat.DomainController = $($domaincontroller);
        $InputSplat.Site = ($Tmbx.identity.tostring().split('/')[1]) ;

        switch ((get-recipient -Identity $Inputsplat.Owner).RecipientType ) {
            "UserMailbox" {

                if ( ($InputSplat.OwnerMbx = (get-mailbox -identity $($InputSplat.Owner) -ea stop)) ) {
                    if ($showdebug) { $smsg = "UserMailbox detected" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Debug } ; } ;
                } else {
                    throw "Unable to resolve $($InputSplat.Owner) to any existing OP or EXO mailbox" ;
                    Cleanup ; Exit ;
                } ;
            }
            "MailUser" {
                if ( ($InputSplat.OwnerMbx = (get-remotemailbox -identity $($InputSplat.Owner) -ea stop)) ) {
                    if ($showdebug) {
                        $smsg = "MailUser detected" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Debug } ; #Error|Warn|Debug
                    } ;
                } else {
                    throw "Unable to resolve $($InputSplat.Owner) to any existing OP or EXO mailbox" ;
                    Cleanup ; Exit ;
                } ;
            }
            default {
                throw "$($InputSplat.Owner) Not found, or unrecognized RecipientType" ;
                Cleanup ; Exit ;
            }
        } ;

        # owner needs to be samaccountname or DN - can't use email addresses!
        if ($Inputsplat.Owner -match $rgxEmailAddr) {
            $smsg = "Converting Owner email:$($Inputsplat.Owner) to logon..." ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
            $Inputsplat.Owner = $InputSplat.OwnerMbx.alias ;
        } ;

        # if no permsdays, default it to 60d
        if (!($InputSplat.PermsDays)) { "defaulting PermsDays to 60"; $InputSplat.PermsDays = 60 };
        if ($InputSplat.PermsDays -eq 999) {
            [string]$PermsExp = (get-date "12/31/2099" -format "MM/dd/yyyy") ;
        } else {
            [string]$PermsExp = (get-date (Get-Date).AddDays($InputSplat.PermsDays + 1) -format "MM/dd/yyyy") ;
        } ;

        $Infostr = "TargetMbx:$($Tmbx.samaccountname)`r`nPermsExpire:$($PermsExp)`r`nIncident:$($Ticket)`r`nAdmin:$($AdminInits)`r`nBusinessOwner:$($InputSplat.Owner);`r`nITOwner:$($InputSplat.Owner)" ;

        $smsg = "Site:$($InputSplat.Site)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
        $smsg = "`nTLogon: $($Tmbx.samaccountname )" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn

        $Adu = (get-aduser $($tmbx.SamAccountName) -server $($InputSplat.DomainController) -ea stop -properties manager)  ;
        if ($Adu.Manager) {
            $Mgr = ((get-aduser ($Adu.manager)).samaccountname) ;
            $smsg = "MgrLogon: $($Mgr)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
        } else {
            $smsg = "$($Tmbx.displayname) has a blank AD Manager field.`nAsserting Owner from inputs:$($InputSplat.Owner) " ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
            $Mgr = $($InputSplat.Owner);
        } ;
        if ($InputSplat.SiteOverride) {
            $SiteCode = $($InputSplat.SiteOverride);
        } else {
            # we need to use the OwnerMbx - Owner currently is the alias, we want the object with it's dn
            $SiteCode = $InputSplat.OwnerMbx.identity.tostring().split("/")[1]  ;
        } ;
        if ($env:USERDOMAIN -eq $TORMeta['legacyDomain']) {
            $FindOU = "^OU=Email\sAccess,OU=SEC\sGroups,OU=Managed\sGroups,";
        } ELSEif ($env:USERDOMAIN -eq $TOLMeta['legacyDomain']) {
            # CN=Lab-SEC-Email-Thomas Jefferson,OU=Email Access,OU=SEC Groups,OU=Managed Groups,OU=LYN,DC=SUBDOM,DC=DOMAIN,DC=DOMAIN,DC=com
            $FindOU = "^OU=Email\sAccess,OU=SEC\sGroups,OU=Managed\sGroups,"; ;
        } else {
            throw "UNRECOGNIZED USERDOMAIN:$($env:USERDOMAIN)" ;
        } ;

        $SGSplat.DisplayName = "$($SiteCode)-SEC-Email-$($Tmbx.DisplayName)-G";

        TRY {
            $OU = (Get-ADObject -filter { ObjectClass -eq 'organizationalunit' } -server $($DomainController) | Where-Object { $_.distinguishedname -match "^$($FindOU).*OU=$($SiteCode),.*,DC=ad,DC=toro((lab)*),DC=com$" } | Select-Object distinguishedname).distinguishedname.tostring() ;
        } CATCH {
            $ErrTrpd = $_ ;
            $smsg = "UNABLE TO LOCATE $($FindOU) BELOW SITECODE $($SiteCode)!. EXITING!" ; $smsg = "MESSAGE" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } ; #Error|Warn
            $smsg = "Failed processing $($ErrTrpd.Exception.ItemName). `nError Message: $($ErrTrpd.Exception.Message)`nError Details: $($ErrTrpd)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } ; #Error|Warn
            Exit
        } ;
        If ($OU -isnot [string]) {
            $smsg = "WARNING AD OU SEARCH SITE:$($InputSplat.SiteCode), FindOU:$($FindOU), FAILED TO RETURN A SINGLE OU...`n$($OU.distinguishedname)`nEXITING!";
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } ; #Error|Warn
            Exit ;
        } ;

        $smsg = "$SiteCode" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
        $smsg = "$OU" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug

        $SGSplat.Path = $OU ;
        $smsg = "Checking specified SecGrp Members..." ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
        # 3:50 PM 10/13/2021 flip ea stop to continue, we want it to get through, even if it throws error, and continue will complain
        $SGMembers = ($InputSplat.members.split(",") | ForEach-Object { get-recipient $_ -ea continue | select -expand primarysmtpaddress  | select -unique})
        $smsg = "Checking for existing $($SGSplat.DisplayName)..." ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn

        if ($bDebug) {
            $smsg = "`$SGSrchName:$($SGSrchName)`n`$SGSplat.DisplayName: $($SGSplat.DisplayName)"; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Debug } ;
        } ;

        $SGSrchName = $($SGSplat.DisplayName);
        $oSG = Get-ADGroup -Filter { SamAccountName -eq $SGSrchName } -server $($InputSplat.DomainController) -ErrorAction stop;

        if ($oSG) {
            if ($bDebug) {
                $smsg = "`$oSG:$($oSG.SamAccountname)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Debug } ; #Error|Warn
                $smsg = "`$oSG.DN:$($oSG.DistinguishedName)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Debug } ; #Error|Warn
            } ;

            # 4:16 PM 8/16/2021 nope, it's not dg-enabled yet, it's a secgrp, can't pull it.
            # try flipping the $osg adg, to a resolved equiv dg obj, and use it's primarysmtpaddress rather than the adg.samaccountname (which may not match the alias, as an id). The dG should be a native rcp obj better fit to the add-mailboxperm cmd
            $oDG = get-distributiongroup -DomainController $InputSplat.DomainController -Identity $osg.DistinguishedName -ErrorAction 'STOP' ;
            #$SGUpdtSplat.Identity = $DGEnableSplat.Identity = $DGUpdtSplat.Identity = $GrantSplat.User = $ADMbxGrantSplat.User = $oSG.samaccountname ;
            $GrantSplat.User = $ADMbxGrantSplat.User = $oDG.primarysmtpaddress ;

            # _append_ the $InfoStr into any existing Info for the object
            # can't use [ordered] on psv2 if we must have these in order use a psv2 OrderedDictionary
            if (($host.version.major) -lt 3) {
                $ADOtherInfoProps = New-Object Collections.Specialized.OrderedDictionary ;
                #$ADOtherInfoProps.Add('One',1) ;
                $ADOtherInfoProps.Add('TargetMbx', $null) ;
                $ADOtherInfoProps.Add('PermsExpire', $null) ;
                $ADOtherInfoProps.Add('Incident', $null) ;
                $ADOtherInfoProps.Add('Admin', $null) ;
                $ADOtherInfoProps.Add('BusinessOwner', $null) ;
                $ADOtherInfoProps.Add('ITOwner', $null) ;

            } else {
                $ADOtherInfoProps = [ordered]@{
                    TargetMbx     = $null ;
                    PermsExpire   = $null ;
                    Incident      = $null ;
                    Admin         = $null ;
                    BusinessOwner = $null ;
                    ITOwner       = $null ;
                } ;
            } ;

            if ($oSG.info) {
                # existing info tag
                # update the splat
                # just loop each line split on `n: (Get-ADUser lynctest9 -Properties info).info.split("`n")| foreach{"Ln:$_"}
                $oADOtherInfo = New-Object PSObject -Property $ADOtherInfoProps ;

                #( $ln in ($oSG.info.tostring().split("`n") )  {
                $ilines = $oSG.info.tostring().split("`n").count ;
                $iIter = 0 ;
                foreach ( $ln in $oSG.info.tostring().split("`n") ) {
                    $iIter++

                    if ($iIter -eq 1) { $UpdInfo = $null; } ;

                    if ($ln -match "^(TargetMbx|PermsExpire|Incident|Admin|BusinessOwner|ITOwner):.*$") {
                        # it's part of a defined Info tag
                        $matches = $null ;
                        # ingest the matches and throw away the lines
                        if ($ln -match "(?<=TargetMbx:)\w+" ) { $oADOtherInfo.TargetMbx = $matches[0] } ; $matches = $null ;
                        if ($ln -match "(?<=PermsExpire:)\d+\/\d+/\d+" ) { $oADOtherInfo.PermsExpire = (get-date $matches[0]) ; } ; ; $matches = $null ;
                        # 12:44 PM 10/18/2016 update rgx for ticket to accommodate 5-digit (or 6) CW numbers "^\d{6}$"=>^\d{5,6}$
                        if ($ln -match "(?<=Incident:)^\d{5,6}$") { $oADOtherInfo.Incident = $matches[0] ; } ; $matches = $null ;
                        if ($ln -match "(?<=Admin:)\w*") { $oADOtherInfo.Admin = $matches[0] ; } ; $matches = $null ;
                        if ($ln -match "(?<=BusinessOwner:)\w{2,20}") { $oADOtherInfo.BusinessOwner = $matches[0] ; } ; $matches = $null ;
                        if ($ln -match "(?<=ITOwner:)\w{2,20}") { $oADOtherInfo.ITOwner = $matches[0] ; } ; $matches = $null ;
                    } else {
                        $UpdInfo += "$($ln)`r`n" ;
                    } ;

                    if ($iIter -eq $iLines) {
                        $smsg = "`$uinfo:`n$uinfo" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                        if ($oADOtherInfo) {
                            $smsg = "Updating existing Info tag:`n$(($oADOtherInfo |out-string).trim())";
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                        }
                        $UpdInfo += "`r`nTargetMbx:$($Tmbx.samaccountname)`r`nPermsExpire:$($PermsExp)`r`nIncident:$($Ticket)`r`nAdmin:$($AdminInits)`r`nBusinessOwner:$($InputSplat.Owner);`r`nITOwner:$($InputSplat.Owner)" ;
                        if ($bDebug) {
                            $smsg = "New Info field:`n$(($UpdInfo |out-string).trim())";
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                        } ;

                        #Set-ADUser -identity $tusr -Replace @{info="$($uinfo)"} -server LYNMS811 -whatif  ;
                        Get-ADGroup -Filter { SamAccountName -eq $SGSrchName } -server $($InputSplat.DomainController) -ErrorAction stop | Set-ADUser -Replace @{info = "$($UpdInfo)" }  -whatif ; ;
                    }


                } # loop-E $lines

            } ; # if-E $osg

        } else {
            $smsg = "$($SGSplat.DisplayName) Not found. Testing Create with the following paraemters..."  ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
            # create the secgrp
            $SGSplat.Name = $($SGSplat.DisplayName);
            $SGSplat.SamAccountName = $($SGSplat.DisplayName);
            $SGSplat.ManagedBy = $($InputSplat.Owner);
            $SGSplat.Description = "Email - access to $($Tmbx.displayname)'s mailbox";
            $SGSplat.Server = $($InputSplat.DomainController) ;
            # build the Notes/Info field as a hashcode: OtherAttributes=@{    info="TargetMbx:SOMERECIP`r`nPermsExpire:6/19/2015"  } ;
            $SGSplat.OtherAttributes = @{info = $($Infostr) } ;


            $smsg = "`$SGSplat:`n---"; $smsg = "MESSAGE" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
            foreach ($row in $SGSplat) {
                foreach ($key in $row.keys) {
                    if ($key -eq "OtherAttributes") {
                        $smsg = "==v OtherAttributes: v==" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                        $SGSplat.OtherAttributes.GetEnumerator() | Foreach-Object {
                            $smsg = "==$($_.Key ):==`n$(($_.Value|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                        } ;
                        $smsg = "==^ OtherAttributes: ^==" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                    } else {
                        $smsg = "$($key): $($row[$key])" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                    } ;
                }
            } ;

            $smsg = "---`nWhatif $($SGSplat.Name) creation...";
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
            # unlike most other modules, ADMS and it's new-ADGroup does *not* return the created object. Have to qry the object back, cold. 
            New-AdGroup @SGSplat -whatif ;
            $DGEnableSplat.identity = $SGSplat.SamAccountName ;
            $DGUpdtSplat.identity = $SGSplat.SamAccountName ;

            $smsg = "`$DGEnableSplat:`n---`n$(($DGEnableSplat|out-string).trim())`n---`n" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn

            write-host -foregroundcolor yellow "$((get-date).ToString("HH:mm:ss")):Continue with $($SGSplat.Name) creation?...";
            if ($NoPrompt) { $bRet = "YYY" } else { $bRet = Read-Host "Enter YYY to continue. Anything else will exit`a" ; } ;
            if ($bRet.ToUpper() -eq "YYY") {


                if ($whatif) {
                    $smsg = "-Whatif pass, skipping exec." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                } else {
                    $smsg = "Executing...";
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                    New-AdGroup @SGSplat  ;
                    Do { write-host "." -NoNewLine; Start-Sleep -s 1 } Until (Get-ADGroup -Filter { SamAccountName -eq $SGSrchName } -server $($InputSplat.DomainController)) ;
                    #$oSG= (get-adgroup "$($SGSplat.DisplayName)" -server $($InputSplat.Domain) -ea stop );
                    $oSG = Get-ADGroup -Filter { SamAccountName -eq $SGSrchName } -server $($InputSplat.DomainController) -ErrorAction stop;
                    if ($bDebug) {
                        $smsg = "`$oSG:$($oSG.SamAccountname)`n`$oSG.DN:$($oSG.DistinguishedName)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Debug } ; #Error|Warn
                    } ;
                    $smsg = "Enable-DistributionGroup w`n$(($DGEnableSplat|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                    # capture the enabl - EMS ps returns the intact $osg DG object
                    $oDG = Enable-DistributionGroup @DGEnableSplat ;
                    $smsg = "Set HiddenFromAddressListsEnabled:Set-DistributionGroup w`n$(($DGUpdtSplat|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                    # but set-dg does *not* return the updated object, it has to be re-queried for current status. 
                    Set-DistributionGroup @DGUpdtSplat ;
                    $oSG = Get-ADGroup -Filter { SamAccountName -eq $SGSrchName } -prop * -server $($InputSplat.DomainController) -ErrorAction stop;
                    $smsg = "Final SecGrp Config:$($oSG.SamAccountname)`n:$(($oSG | fl Name,GroupCategory,GroupScope,msExchRecipientDisplayType,showInAddressBook,mail|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                    # qry back updated status
                    $oDG = get-distributiongroup -DomainController $InputSplat.DomainController -Identity $oDG.DistinguishedName -ErrorAction 'STOP' ;
                    #$SGUpdtSplat.Identity = $DGEnableSplat.Identity = $DGUpdtSplat.Identity = $GrantSplat.User = $ADMbxGrantSplat.User = $oSG.samaccountname ;
                    $GrantSplat.User = $ADMbxGrantSplat.User = $oDG.primarysmtpaddress ;
                } ;
            } else { $smsg = "INVALID KEY ABORTING NO CHANGE!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; Exit ; } ;
        } # if-E $osg

        $smsg = "`nTesting SecGrp Members Add `nto group: $($oSG.Name)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
        if ($oSG -AND $oDG) {
            
            $DGEnableSplat.Identity = $DGUpdtSplat.Identity = $SGUpdtSplat.Identity = $oSG.samaccountname ;
            
            # we're using the samaccountname for -user spec, 
            # can't use the DN either (won't resolve)
            $SGUpdtSplat.Server = $($InputSplat.DomainController) ;
            $DGEnableSplat.DomainController = $($InputSplat.DomainController) ;
            $DGUpdtSplat.DomainController = $($InputSplat.DomainController) ;
            # 12:47 PM 10/6/2015 add dc
            $GrantSplat.Add("DomainController", $($InputSplat.domaincontroller)) ;
            #8:41 AM 10/14/2015 add adp
            $ADMbxGrantSplat.Add("DomainController", $($InputSplat.domaincontroller)) ;

            $ExistMbrs = get-distributiongroupmember -Identity $oSG.samaccountname -DomainController $domaincontroller -ErrorAction 'Stop' | select -expand primarysmtpaddress ; 
            $pltAddDGM=[ordered]@{
                identity=$oDG.alias ;
                #Member= $mbr  ; 
                BypassSecurityGroupManagerCheck=$true 
                ErrorAction = 'Stop' ; 
                whatif=$($whatif) ; 
                DomainController= $domaincontroller
            } ;
            <# with AddDGM, if you're not the explicit owner, you get:
            You don't have sufficient permissions. This operation can only be performed by a manager of the group.
            use the -BypassSecurityGroupManagerCheck param to quash the check
            #>
            if ($whatif) {
                $smsg = "-Whatif pass, skipping exec." ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
            } else {
                foreach ($Mbr in $SGMembers) { 
                    if ($ExistMbrs -notcontains $Mbr) {
                        $smsg = "ADD:$($mbr)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                        #Add-ADGroupMember @SGUpdtSplat -members $($mbr.samaccountname)  -whatif ;
                        <# AAGM keeps throwing
                            Couldn't resolve the user or group "GROUP DNAME." If the user or group is a foreign forest principal, you must have either a two-way trust or an outgoing trust.
                            + CategoryInfo          : InvalidOperation: (:) [], LocalizedException
                            + FullyQualifiedErrorId : 9A7F344F
                            + PSComputerName        : DC.DOMAIN.COM
                        #> 
                        # flip the adds to adgm
                        Add-DistributionGroupMember @pltAddDGM -member $mbr ; 
                    } else {
                        $smsg = "SKIPPING:$($mbr.samaccountname) is already a member of $($oSG.samaccountname)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                    } ;
                }  # loop-E ;
                <# toss out the whole prompted thing, just do it above
                $smsg = "Continue with Member Addition?...";
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                if ($NoPrompt) { $bRet = "YYY" } else { $bRet = Read-Host "Enter YYY to continue. Anything else will exit`a" ; } ;
                if ($bRet.ToUpper() -eq "YYY") {
                    $smsg = "Exec Update";
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                    foreach ($Mbr in $SGMembers) {
                        If ($ExistMbrs -notcontains $Mbr.sAMAccountName) {
                            "Exec ADD:$($mbr.samaccountname)"
                            if ($whatif) {
                                # 11:17 AM 6/22/2015 whatif-only pass
                                $smsg = "SKIPPING EXEC: Whatif-only pass";
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                            } else {
                                # 8:33 AM 6/27/2019 fix latest ADmod, added a conflicting param, autoresolve fails, typo -member -> proper -members
                                Add-ADGroupMember @SGUpdtSplat -members $($mbr.samaccountname)  ;
                            } ;
                        } else {
                            "SKIPPING:$($mbr.samaccountname) is already a member of $($oSG.samaccountname)"
                        } ;
                    } #  # loop-E;
                } ;
                #>
            } # if-E whatif ;
            #$mbxp = $Tmbx | get-mailboxpermission -user ($oSG).Name -domaincontroller $InputSplat.domaincontroller -ea silentlycontinue | 
            $mbxp = $Tmbx | get-mailboxpermission -user $oSG.samaccountname -domaincontroller $InputSplat.domaincontroller  | 
                Where-Object { $_.user -match ".*-(SEC|Data)-Email-.*$" }
            $smsg = "`nChecking Mailbox Permission on $($Tmbx.samaccountname) mailbox to accessing user:`n $($oSG.Name)...`n(blank if none)`n---`n$(($mbxp | select user,AccessRights,IsInhertied,Deny | format-list|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug


            # AD SendAs too

            $mbxadp = $Tmbx | Get-ADPermission -domaincontroller $($InputSplat.domaincontroller) -ea Silentlycontinue |
                 Where-Object { ($_.ExtendedRights -like "*Send-As*") -and ($_.IsInherited -eq $false) -and ($_.user -match ".*-(SEC|Data)-Email-.*$") };

            $smsg = "`nChecking AD SendAs Permission on $($Tmbx.samaccountname) mailbox to accessing user:`n $($oSG.Name)...`n(blank if none)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug

            $smsg = "`n$(($mbxadp | select identity,User,ExtendedRights,Deny,Inherited | format-list|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
            # format-table -wrap ;

            $smsg = "`n---`nExisting $($oSG.Name) Membership...`n(blank if none)`n$((Get-ADGroupMember -identity $oSG.samaccountname -server $($DomainController) | select distinguishedName|out-string).trim())`n" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug

            $smsg = "Testing Permissions Grant Update...`nAdd-MailboxPermission -whatif w`n$(($GrantSplat|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug

            # add retry :
            $Exit = 0 ;
            # do loop until up to 4 retries...
            Do {
                if($Exit -gt 0){
                    $smsg = "RETRY#:$($exit)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
                Try {
                     # capture returned added perms (not full perms on mbx)
                    $addedmbxp = add-mailboxpermission @GrantSplat -whatif ;
                    $Exit = $Retries ;
                } Catch {
                    $ErrTrapd = $Error[0] ;

                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec add-mailboxpermission -whatif cmd because: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                    $smsg = "Try #: $($Exit)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                    If ($Exit -eq $Retries) { $smsg = "Unable to exec cmd!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } ; } ;
                    Continue ;
                } # try-E
            } Until ($Exit -eq $Retries) # loop-E

            #$smsg = "Add-ADPermission -whatif... w`n$(($ADMbxGrantSplat|out-string).trim())" ;
            #if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
            $smsg = "add-adpermission w`n-identity $($TMbx.Identity)`n$(($ADMbxGrantSplat|out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            $Exit = 0 ;
            Do {
                if($Exit -gt 0){
                    $smsg = "RETRY#:$($exit)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
                Try {
                    # capture returned added perms (not full perms on mbx)
                    $addedadmbxp = add-adpermission -identity $($TMbx.Identity) @ADMbxGrantSplat -whatif ;
                    $Exit = $Retries ;
                } Catch {
                    $ErrTrapd = $Error[0] ;
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec add-mailboxpermission -whatif cmd because: $($ErrTrpd)`nTry #: $($Exit)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } ;
                    If ($Exit -eq $Retries) { $smsg = "Unable to exec cmd!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } ; } ;
                    Continue ;
                } # try-E
            } Until ($Exit -eq $Retries) # loop-E

            write-host -foregroundcolor green "$((get-date).ToString("HH:mm:ss")):Exec Permissions Grant Update";
            if ($whatif) {
                # 11:17 AM 6/22/2015 whatif-only pass
                write-verbose "SKIPPING EXEC: Whatif-only pass";
            } else {
                $smsg = "add-mailboxpermission w`n$(($GrantSplat|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $Exit = 0 ;
                # do loop until up to 4 retries...
                Do {
                    if($Exit -gt 0){
                        $smsg = "RETRY#:$($exit)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                    Try {
                        add-mailboxpermission @GrantSplat ;
                        $Exit = $Retries ;
                    } Catch {
                        $ErrTrapd = $Error[0] ;

                        Start-Sleep -Seconds $RetrySleep ;
                        $Exit ++ ;
                        $smsg = "Failed to exec add-mailboxpermission EXEC cmd because: $($ErrTrapd)`nTry #: $($Exit)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } ; #Error|Warn|Debug
                        If ($Exit -eq $Retries) { $smsg = "Unable to exec cmd!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } ; } ;
                        Continue ;
                    } # try-E
                } Until ($Exit -eq $Retries) # loop-E

                $smsg = "Add-ADPermission -whatif:identity $($TMbx.Identity) w`n$(($ADMbxGrantSplat|out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug

                $Exit = 0 ;
                Do {
                    if($Exit -gt 0){
                        $smsg = "RETRY#:$($exit)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                    Try {
                        add-adpermission -identity $($TMbx.Identity) @ADMbxGrantSplat ;
                        $Exit = $Retries ;
                    } Catch {
                        $ErrTrapd = $Error[0] ;

                        Start-Sleep -Seconds $RetrySleep ;
                        $Exit ++ ;
                        $smsg = "Failed to exec add-adpermission EXEC cmd because: $($ErrTrapd)`nTry #: $($Exit)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } ; #Error|Warn|Debug
                        If ($Exit -eq $Retries) { $smsg = "Unable to exec cmd!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } ; } ;
                        Continue ;
                    } # try-E
                } Until ($Exit -eq $Retries) # loop-E

                # generics don't need this, test the OU path and only add folks below users
                # we're only hiding folks matching:
                #$rgxBannedOUs=[xxx]
                # and unhiding folks matching
                if ($Tmbx.distinguishedname -match $rgxUserOUs) {
                    # block that adds the $tmbx to the maintain-offboards.ps1 target AccGrant group for the region
                    $smsg = "Add TMBX $($tMbx.samaccountname) to AccGrant Group`n$(($TMbx | select -expand distinguishedname|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                    $grpN = "LYN-DL-Exch-AGUnHide" ;
                    $smsg = "==TGroup:$($grpN)";
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug

                    if ($tdl = get-DistributionGroup -identity $grpN -domaincontroller $($InputSplat.domaincontroller) ) {
                        
                        $pltAddDGM=@{
                            identity=$tdl.alias ;Member=$TMbx.distinguishedname; domaincontroller=$($InputSplat.domaincontroller) ;whatif=$($whatif);ErrorAction='STOP';
                        } ; 

                        $smsg = "==Add $($TMbx.name) to $($tdl.alias):" ;
                        $smsg += "`nadd-DistributionGroupMember w`n$(($pltAddDGM|out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;                        
                        $Exit = 0 ;
                        # do loop until up to 4 retries...
                        Do {
                            Try {
                                add-DistributionGroupMember @pltAddDGM ;
                                #-identity $tdl.alias -Member $TMbx.distinguishedname -domaincontroller $($InputSplat.domaincontroller) -whatif:$($whatif) ;

                                $Exit = $Retries ;
                            } Catch {
                                $ErrTrapd = $Error[0] ;

                                Start-Sleep -Seconds $RetrySleep ;
                                $Exit ++ ;
                                $smsg = "Failed to exec add-DistributionGroupMember EXEC cmd because: $($ErrTrapd)`nTry #: $($Exit)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } ; #Error|Warn|Debug
                                If ($Exit -eq $Retries) { $smsg = "Unable to exec cmd!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } ; } ;
                                # 11:15 AM 11/26/2019 add Cont - doesn't seem to be retrying
                                Continue ;
                            } # try-E
                        } Until ($Exit -eq $Retries) # loop-E

                    } else {
                        "$($grpN): NOT FOUND" ;
                    }  ;
                } else {
                    $smsg = "TMBX $($tMbx.samaccountname) is in a non-User OU: Term Hide/Unhide groups do not apply...";
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                }

            } ;
            write-verbose "$(Get-Date -Format 'HH:mm:ss'):Waiting 5secs to refresh";
            Start-Sleep -s 5 ;

            # secgrp membership seldom comes through clean, add a refresh loop
            do {
                # 12:53 PM 6/30/2021 idsolate the get's & add try/catch
                TRY{
                    $propsMbxP = 'user','AccessRights','IsInhertied','Deny' ; 
                    $propsAMbxP = 'User','ExtendedRights','Inherited','Deny' ; 
                    $rMbxP = get-mailboxpermission -identity $($TMbx.Identity) -user $oSG.samaccountname -domaincontroller $($InputSplat.domaincontroller) |
                        ?{$_.user -match ".*-(SEC|Data)-Email-.*$"} ; 
                    $rAMbxP = Get-ADPermission -identity $($TMbx.Identity) -domaincontroller $($InputSplat.domaincontroller) -user $oSG.distinguishedName ; 
                    $mbrs = Get-ADGroupMember -identity $oSG.distinguishedName -server $($DomainController) | 
                        Select-Object distinguishedName ;
                 <# orig, revised to modern standard below
                 } Catch {
                    $ErrTrapd = $Error[0] ;
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    $smsg = "Failed to exec add-DistributionGroupMember EXEC cmd because: $($ErrTrapd)`nTry #: $($Exit)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } ; #Error|Warn|Debug
                    If ($Exit -eq $Retries) { $smsg = "Unable to exec cmd!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } ; } ;
                    # 11:15 AM 11/26/2019 add Cont - doesn't seem to be retrying
                    Continue ;
                } # try-E
                #>
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    
                    Continue ;#Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                } ; 
                
                $smsg = "===REVIEW SETTINGS:===`n----Updated Permissions:`n`nChecking Mailbox/AD Permission on $($Tmbx.samaccountname) mailbox `n to accessing user:`n $($oSG.SamAccountName)`n---" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug

                #$smsg = "`n$((get-mailboxpermission -identity $($TMbx.Identity) -user $(($oSG).Name) -domaincontroller $($InputSplat.domaincontroller) | ?{$_.user -match ".*-(SEC|Data)-Email-.*$"} | format-list user,AccessRights,IsInhertied,Deny |out-string).trim())" ;
                # 12:52 PM 6/30/2021 fix typo:
                #$smsg = "`n$((get-mailboxpermission -identity $($TMbx.Identity) -user $oSG.distinguishedName -domaincontroller $($InputSplat.domaincontroller) | ?{$_.user -match ".*-(SEC|Data)-Email-.*$"} | format-list user,AccessRights,IsInhertied,Deny |out-string).trim())" ;
                $smsg = "`n$(($rMbxP | format-list $propsMbxP |out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                #$smsg = "`n$((get-mailboxpermission -identity $($TMbx.Identity) -user $(($oSG).Name) -domaincontroller $($InputSplat.domaincontroller) | ?{$_.user -match ".*-(SEC|Data)-Email-.*$"} | format-list user,AccessRights,IsInhertied,Deny|out-string).trim())" ;
                #if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug

                $smsg = "`n==User mbx grant: Confirming $($TMbx.name) member of $($grpN):" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug

                # 10:04 AM 11/22/2017 put the accgrant confirmation into the output:
                if ($Tmbx.distinguishedname -match $rgxUserOUs) {
                    #$smsg = "$((Get-ADPermission -identity $($TMbx.Identity) -domaincontroller $($InputSplat.domaincontroller) -user "$($oSG.SamAccountName)"|  format-list User,ExtendedRights,Inherited,Deny | out-string).trim())" ;
                    $smsg = "`n$(($rAMbxP|out-string | format-list $propsAMbxP ).trim())" ; 
                    # $rAMbxP 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                } else {
                    $smsg = "TMBX $($tMbx.samaccountname) is in a non-User OU: Term Hide/Unhide groups do not apply...";
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                }  ;

                $smsg = "`nUpdated $($oSG.Name) Membership...`n" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
                write-host -foregroundcolor green "$((get-date).ToString("HH:mm:ss")):---";
                #if ($mbrs = Get-ADGroupMember -identity $oSG.samaccountname -server $($DomainController) | Select-Object distinguishedName ) {
                if ($mbrs) {
                    $smsg = "$(($mbrs | out-string).trim() | out-default)`n-----------------------" ;
                } else {
                    $smsg = "(NO MEMBERS RETURNED)`n-----------------------" ;
                } ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug

                $bRet = Read-Host "Enter Y to Refresh Review (replication latency)." ;
            } until ($bRet -ne "Y");

        } else { $smsg = "$($InputSplat.SecGrpName) not found.`n" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } ; };


    } # PROC-E ;

    END {


    } # END-E
}

#*------^ add-MailboxAccessGrant.ps1 ^------


#*------v add-MbxAccessGrant.ps1 v------
function add-MbxAccessGrant {
    <#
    .SYNOPSIS
    add-MbxAccessGrant.ps1 - Wrapper/pre-processor function to Add Mbx Access to a specified mailbox (leverages generic add-MailboxAccessGrant())
    .NOTES
    Version     : 1.0.1
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2020-
    FileName    : 
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Exchange,Permissions,Mailbox,Exchange2010
    AddedCredit : 
    AddedWebsite: 
    AddedTwitter: 
    REVISIONS
    # 10:30 AM 10/13/2021 pulled [int] from $ticket , to permit non-numeric & multi-tix
    * 2:05 PM 4/27/2020 debugged, fully ported to published/installed use
    * 3:57 PM 4/9/2020 genericized for pub, moved material into infra, updated hybrid mod loads, cleaned up comments/remmed material ; updated to use start-log, debugged to funciton on jumpbox, w divided modules
    * 2:30 PM 10/1/2019 fixed 2405 errant duped catch block post merge
    * 1:54 PM 10/1/2019 manually merged branch master with the long open/outstanding branch tostka/update-new-MailboxGenericTOR.ps1
    # 9:54 AM 9/27/2019 added `a beep to all "YYY" prompts, to draw attn while multitasking
    # 8:34 AM 6/27/2019 fixed add-adgroupmember autoresolution param break - had typo -member which worked until they added a new conflicting -membertimetolive param, should have been -members (tho' add-dgmember uses -member)
    # 2:32 PM 6/13/2019 converted to function: add-MbxAccessGrant(), passed
    debugging, saving out to add-MbxAccessGrant-function.ps1 ->
    add-MbxAccessGrant.ps1 and backing up the original
    # 11:05 AM 6/13/2019 updated get-admininitials(), # 12:50 PM 6/13/2019 repl get-timestamp() -> Get-Date -Format 'HH:mm:ss' throughout
    # 2:19 PM 4/29/2019 add TOL to the domain param validateset on get-gcfast copy (sync'd in from verb-ex2010.ps1 vers)
    # 11:43 AM 2/15/2019 debugged update through a prod revision
    # 11:15 AM 2/15/2019 copied in bug-fixed write-log() with fixed debug support
    # 10:41 AM 2/15/2019 updated write-log to latest deferring version
    # 10:39 AM 2/15/2019 added full write-log logging support
    # 3:24 PM 2/6/2019 #1416:needs -prop * to pull msExchRecipientDisplayType,showInAddressBook,mail etc
    # 8:36 AM 9/6/2018 switched secgrp to Global->Universal scope, mail-enabled as DG, and hiddenfromaddressbook, debugged out issues, used in prod creation
    # 10:28 AM 6/27/2018 add $domaincontroller param option - skips dc discovery process and uses the spec, also updated $findOU code to work with TOL dom
    # 11:05 AM 3/29/2018 #1116: added trycatch, UST lacked the secgrp ou and was failing ou lookup
    # 10:31 AM 11/22/2017 shifted a block of "User mbx grant:" confirmation into review block, also tightened up the formatted whitespace to make the material pasted into cw reflect all that you need to know on the grant status. also added distrib code
    # 1:17 PM 11/15/2017 949: no, this needs to be the obj (was extracting samaccountname)
    # 12:35 PM 11/15/2017 debugged EXO-hosted Owner code to function. worked granting GRANTEE2 (exo) access to shared 'SharedTestEXOOwner' OP
    # 11:58 AM 11/15/2017 945: accommodate EXO-hosted Owners by testing with get-remotemailbox -AND get-mailbox on the owner spec.
    # 12:57 PM 9/25/2017 standardized mbxp & adperm field output and format i the review settings block
    # 11:29 AM 6/23/2017 fix typos, added 'DomainControler', without the vari-spec $
    # 8:16 AM 6/23/2017 we're getting mismatches/misses on AD work - prolly because we're using the -server $domain, rather than a SPECIFIC GC! replic lag is killing us!
    #   switch to the same gc the Ex cmds are using
    #   rplc -server $($InputSplat.Domain)  -> -server $($InputSplat.DomainController)
    #   rplc -server $Domain -> -server $($DomainController)
    # 1:41 PM 6/13/2017 spliced in latest 3/16/16 get-gcfast()
    # 1:37 PM 5/30/2017 855: pretest get-command, fails if it doesn't even have it at all
    # 1:21 PM 5/30/2017 1484: block that adds the $tmbx to the maintain-offboards.ps1 target AccGrant group for the region
    # 1:20 PM 5/30/2017 pencil in new AG group add when grant is done.
    # 11:27 AM 5/22/2017 add $NoPrompt
    # 9:44 AM 3/2/2017 suppress ID null errors on close BP
    # 9:07 AM 3/2/2017: Example code:  Don't force load EMS/Add-EMSRemote if there's an existing functional get-exchangeserver command (suppress clobber errors)
    # 9:41 AM 3/2/2017 merged in updated Add-EMSRemote Set
    # 9:07 AM 3/2/2017: Add-EMSRemote set: Example code:  Don't force load EMS/Add-EMSRemote if there's an existing functional get-exchangeserver command (suppress clobber errors)
    # 9:07 AM 3/2/2017 Don't force load EMS/Add-EMSRemote if there's an existing functional get-exchangeserver command (suppress clobber errors)
    # 12:15 PM 2/27/2017 trailing membership test was still failing, tore out blocks of new code and recycled what's used up in the Existing quote who cares if it's a DN vs a name
    # 12:11 PM 2/27/2017 fixed compat in SITE (prolly SITE too) - resolved any Owner entered as email, to the samaccountname ; #1081: drop the pipe!
     $oSG | Get-ADGroupMember -server $Domain | select distinguishedName ; #1263 threw up trying to do the get-aduser on the members, # 1283 replace user lookup with this (skip the getxxx member, pull members right out of properties)
    # 1:04 PM 2/24/2017 tweak below
    #12:56 PM 2/24/2017 doesn't run worth a damn SITE-> SITE/SITE, force it to abort (avoid half-built remote objects that take too long to replicate back to SITE)
    # 12:24 PM 2/24/2017 fixed updated membership report bug - pulled pipe, probably dehydrated object issue sin remote ps
    # 12:11 PM 2/24/2017 fix vscode/code.exe char set damage: It replaced dashes (-) with "?"
    # fix -join typo/damage
    # 12:44 PM 10/18/2016 update rgx for ticket to accommodate 5-digit (or 6) CW numbers "^\d{6}$"=>^\d{5,6}$
    # 9:11 AM 9/30/2016 added pretest if(get-command -name set-AdServerSettings -ea 0)
    # # 12:22 PM 6/21/2016 secgrp membership seldom comes through clean, add a refresh loop
    # 10:52 AM 6/20/2016 fixed typo $InputSplatSiteOverride => $InputSplat.SiteOverride (broke -SiteOverride function)
    # 11:02 AM 6/7/2016 updated get-aduser review cmds to use the same dc, not the -domain global.ad.toro.com etc
    # 1:34 PM 5/26/2016 confirmed/verified works fine with SITE-hosted mbx under 376336 
    # 11:45 AM 5/19/2016 corrected $tmbx ref's to use $tmbx.identity v. $tmbx.samaccountname, now working. Retry code in place for SITE, but it didn't trigger during testing
    # 2:37 PM 5/18/2016 implmented Secgrp OU and Secgrp stnd name
    # 2:28 PM 5/18/2016 support dmg's latest unilateral changes:With the recent AD changes, all email access groups should be named     XXX-SEC-Email-firstname lastname-G and stored in XXX\Managed Groups\SEC Groups\Email Access. The generics were also renamed to XXX\Generic Email Accounts.

    # 2:17 PM 5/10/2016 used successfully to set a SITE manager perm's on an SERVERMail02-hosted user. didn't time out, Set-MailboxPermission command completed after ~3 secs
    #     fixed bad param example, remmed out non-functional Owner in the SGSplat (nosuch param), and re-enabled the ManagedBy on the SG - it's not a mbx,
    #     so why not set ManagedBy, doesn't get used by the org chart in SP
    # 2:38 PM 3/17/2016 stop populating anything into any managed-by; it's an OrgChart political value now. Rename ManagedBy param and object names in here to 'Owner'
    # 1:12 PM 2/11/2016 fixed new bug in get-GCFast, wasn't detecting blank $site
    # 12:20 PM 2/11/2016 updated to standard EMS/AD Call block & Add-EMSRemote()
    # 9:36 AM 2/11/2016 just shifting to a single copy, with no # Requires at all, losing the -psv2.ps1 version
    # 2:23 PM 2/10/2016 debugged mismatched {}, working from SITE now
    # 1:54 PM 2/10/2016 recoded to work on SITE and SITE, this version just needs the #Requires -Version 3 for psv2 enabled to be a psv3 version
    #         added fundemental upgrade to the AD Site detection, to work from SITE/SITENAME and SITE SITENAME
    # 12:07 PM 2/10/2016 Psv2 variant - at this point, the only real diff is the rem'd rem'd #Requires -Version 3 for psv2
    # 7:40 AM Add-EMSRemote: 2/5/2016 another damn cls REM IT! I want to see all the connectivity info, switched wh->wv, added explicit echo's of what it's doing.
    # 10:41 AM 1/13/2016 updated Add-EMSRemote set & removed Clear-Host's
    # 10:02 AM 1/13/2016: fixed cls bug due to spurious ";cls" included in the try/catch boilerplate: Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;cls => Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;
    # 1:02 PM 12/18/2015 missing SYD as well
    # 11:42 AM 12/18/2015: building a Psv2-compliant version (-psv2.ps1):

    - sub out all [ordered] (-psv2 only)
    - rem'd #Requires -Version 3 (-psv2 only)
    - added explicit .tostring() in front of all string handlers (.substring() etc) (added to both versions)
    # 3:08 PM 10/29/2015 added in XIA aware from other recent script updates, and -server xxx to all get-ad* that didn't have it
    #2:49 PM 10/29/2015 add entire MEL site, nothing in the OU or Secgrp name switch blocks
    # 9:08 AM 10/14/2015 added debugpref maint code to get write-debug to work
    # 8:04 AM 10/14/2015 add sendAS adperms
    # 7:31 AM 10/14/2015 added -dc specs to all *-user & *-mailbox cmds, to ensure we're pulling back data from same dc that was updated in the set-* commands
    # 7:19 AM 10/14/2015 fixed some typos, made sure all $InputSplat.domaincontroller were $()'d
    # 9:13 AM 10/12/2015 force $Grantsplat=$Tmbx to use $Tmbx.Samacctname, defaulting to displayname which isn't consistently resolvable, samacctname should be.
    # 1:17 PM 10/6/2015 update to spec, seems to work
    # splice in Add-EMSRemote set & get-gcfast
    # 10:49 AM 10/6/2015: updated vers of Get-AdminInitials
    # 2:49 PM 10/2/2015 updated catch block to be detailed
    # 10:57 AM 8/14/2015 defaulted PermsDays to 60 (was going to 999)
    # 10:46 AM 8/14/2015 add param examples for the PermsDays spec
    # 9:35 AM 8/14/2015 updated params examples to reflect use of -ticket & -siteoverride
    # 11:00 AM 8/12/2015 also add an Info ref for the admin doing the work
    # 10:37 AM 8/12/2015 I see from dumping all matching secgrps ...
      $AllSGs = Get-ADGroup  -filter {GroupCategory  -eq "Security"  -and GroupScope -eq "Global"} -properties info,description;
      $AllSGs = $AllSgs |?{$_.Name -match "^\w{3}-(SEC|Data)-Email-.*$"} ; ($AllSGs | measure).count ;
      # have to 2-stage filter as the get-adgroup -filter has no -match regex operator support
      ... that dawn used to use these, oldest record I see, was from 2005, most recent appears to have been 2011. But she was recording sometimes recording the incident req# - which is a useful item to include (esp if you don't want folks monkeyin with the Notes/Info
      value and breaking automation to clean these up!).
      So we need to add incident number to the add-MbxAccessGrant.ps1, that means a parameter and a 3rd line in the Info append
    #11:32 AM 8/5/2015 fixed trailing ) in Updated IRO-SEC-Email-Jodie Gilroy-G)
    #11:43 AM 7/20/2015 line 197added a :space after displayname:
    # 12:18 PM 7/17/2015 added -ea silentlycontinue to get-mailboxpermission - it was causing it to bomb script when no match found
    # 1:55 PM 6/15/2015 initial version


    #-=-=DISTRIB SCRIPT (ALL EX SERVERS)-=-=-=-=-=-=
    [array]$files = (gci -path "\\$env:COMPUTERNAME\c$\usr\work\exch\scripts\add-MbxAccessGrant.ps1" | ?{$_.Name -match "(?i:(.*\.(PS1|CMD)))$" })  ;[array]$srvrs = get-exchangeserver | ?{(($_.IsMailboxServer) -OR ($_.IsHubTransportServer))} | select  @{Name='COMPUTER';Expression={$_.Name }} ;$srvrs = $srvrs|?{$_.computer -ne $($env:COMPUTERNAME) } ; $srvrs | % { write-host "$($_.computer)" ; copy $files -Destination \\$($_.computer)\c$\scripts\ -whatif ; } ; get-date ;
    #-=-=-=-=-=-=-=-=


    .DESCRIPTION 
    add-MbxAccessGrant.ps1 - Add Mbx Access to a specified mailbox

    .PARAMETER TargetID
    Target Mailbox for Access Grant[name,emailaddr,alias]
    .PARAMETER SecGrpName
    Custom override default generated name for Perm-hosting Security Group[[SIT]-SEC-Email-[DisplayName]-G]
    .PARAMETER Owner
    Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]
    .PARAMETER SiteOverride
    Specify a 3-letter Site Code. Used to force DL name/placement to vary from TargetID's current site[3-letter Site code]
    .PARAMETER PermsDays
    Specify the number of day's the access-grant should be in place. (60 default. 999=permanent)[30-60,999]")]
    .PARAMETER Members
    Comma-delimited string of potential users to be granted access[name,emailaddr,alias]
    .PARAMETER ticket
    Incident number for the change request[[int]nnnnnn]
    .PARAMETER TenOrg 
	TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']
	.PARAMETER Credential
	Credential to use for this connection [-credential [credential obj variable]")][System.Management.Automation.PSCredential]
	.PARAMETER UserRole
	Role of account (SID|CSID|UID|B2BI|CSVC|ESvc|LSvc)[-UserRole SID]
    .PARAMETER NoPrompt
    Suppress YYY confirmation prompts
    .PARAMETER domaincontroller
    Option to hardcode a specific DC [-domaincontroller xxxx]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowProgress
    Parameter to display progress meter [-ShowProgress switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .PARAMETER NoOutput
    Switch to enable output (success/fail), defaults false, but adding to support tested function execution.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    .\add-MbxAccessGrant.ps1 -ticket 123456 -SiteOverride SITE -TargetID lynctest13 -Owner LOGON -PermsDays 999 -members "GRANTEE1,GRANTEE2" -showDebug -whatIf ;
    Parameter Whatif test with Debug messages displayed
    .LINK
    #>


    <# SecGrp Name spec: =
    2:29 PM 5/18/2016updated per dawn:
            XXX-SEC-Email-firstname lastname-G
    # orig spec:
    ($sSite + "-Data-Email-" + $Tmbx.DisplayName + "-G") ;
    Create the grp :Scope: Global, Type:Secureity
    Add members.
    Add mbx permission to the grp:
    add-mailboxpermission "bossvisiplex" -User "IRO-Data-Email-Boss Visiplex" -AccessRights FullAccess -whatif ;
    #>

    Param(
        [Parameter(HelpMessage="Target Mailbox for Access Grant[name,emailaddr,alias]")]
        [string]$TargetID,
        [Parameter(HelpMessage="Custom override default generated name for Perm-hosting Security Group[[SIT]-SEC-Email-[DisplayName]-G]")]
        [string]$SecGrpName,
        [Parameter(HelpMessage="Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]")]
        [string]$Owner,
        [Parameter(HelpMessage="Specify the number of day's the access-grant should be in place. (60 default. 999=permanent)[30-60,999]")]
        [ValidateRange(7,999)]
        [int]$PermsDays,
        [Parameter(HelpMessage="Specify a 3-letter Site Code. Used to force DL name/placement to vary from TargetID's current site[3-letter Site code]")]
        [string]$SiteOverride,
        [Parameter(HelpMessage="Comma-delimited string of potential users to be granted access[name,emailaddr,alias]")]
        [string]$Members,
        [Parameter(HelpMessage="Incident number for the change request[[int]nnnnnn]")]
        # [int] # 10:30 AM 10/13/2021 pulled, to permit non-numeric & multi-tix
        $Ticket,
        [Parameter(HelpMessage="Suppress YYY confirmation prompts [-NoPrompt]")]
        [switch] $NoPrompt,
        [Parameter(HelpMessage="Option to hardcode a specific DC [-domaincontroller xxxx]")]
        [string]$domaincontroller,
        $TenOrg = 'TOR',
	    [Parameter(HelpMessage="Credential to use for cloud actions [-credential [credential obj variable]")][System.Management.Automation.PSCredential]
	    $Credential,
	    [ValidateSet('SID','CSID','UID','B2BI','CSVC')]
	    [string]$UserRole='SID',
        [Parameter(HelpMessage='Debugging Flag [$switch]')]
        [switch] $showDebug,
        [Parameter(HelpMessage='Whatif Flag [$switch]')]
    [switch] $whatIf) ;

    # NoPrompt Suppress YYY confirmation prompts

    # Get the name of this function
    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
    # Get parameters this function was invoked with
    $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters 

    # 2:50 PM 5/18/2016 add SITE retry code
    $Retries = 4 ; # number of re-attempts
    $RetrySleep = 5 ; # seconds to wait between retries

    # 12:26 PM 5/31/2017 maintain-offboards.ps1 regex constants
    #$rgxBannedOUs=[infra file]
    #$rgxUserOUs==[infra file]


    # 12:49 PM 5/10/2016 updated the BP INIT block to stnd
    #region INIT; # ------
    #*======v SCRIPT/DOMAIN/MACHINE/INITIALIZATION-DECLARE-BOILERPLATE v======
    # * vers: 8:31 AM 5/3/2016: updated tightened up, reflects most common matl want in every script
    # * 2:10 PM 2/4/2015 shifted to here to accommodate include locations
    # pick up the bDebug from the $ShowDebug switch parameter
    # SCRIPT-CONFIG MATERIAL TO SET THE UNDERLYING $DBGPREF:
    if ($Whatif){$bWhatif=$true ; Write-Verbose -Verbose:$true "`$Whatif is $true (`$bWhatif:$bWhatif)" ; };
    if($bdebug){$ErrorActionPreference = 'Stop' ; write-debug "(Setting `$ErrorActionPreference:$ErrorActionPreference;"};

    if($showDebug){
        write-host -foregroundcolor green "`SHOWDEBUG: `$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;
    } ;
    # most of this falls apart once you move a script to a module - all resolve to the module .ps(m|d)1 file, have to use ${CmdletName} for funcs, instead
    if ($psISE -AND (!($PSScriptRoot) -AND !($PSCommandPath))){
            $ScriptDir = Split-Path -Path $psISE.CurrentFile.FullPath ;
            $ScriptBaseName = split-path -leaf $psise.currentfile.fullpath ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($psise.currentfile.fullpath) ;
            $PSScriptRoot = $ScriptDir ;
            if($PSScriptRoot -ne $ScriptDir){ write-warning "UNABLE TO UPDATE BLANK `$PSScriptRoot TO CURRENT `$ScriptDir!"} ;
            $PSCommandPath = $psise.currentfile.fullpath ;
            if($PSCommandPath -ne $psise.currentfile.fullpath){ write-warning "UNABLE TO UPDATE BLANK `$PSCommandPath TO CURRENT `$psise.currentfile.fullpath!"} ;
    } else {
        if($host.version.major -lt 3){
            $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
            $PSCommandPath = $myInvocation.ScriptName ;
            $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } elseif($PSScriptRoot) {
            $ScriptDir = $PSScriptRoot ;
            if($PSCommandPath){
                $ScriptBaseName = split-path -leaf $PSCommandPath ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($PSCommandPath) ;
            } else {
                $PSCommandPath = $myInvocation.ScriptName ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } ;
        } else {
            if($MyInvocation.MyCommand.Path) {
                $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } else {
                throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" ;
            } ;
        } ;
    } ;
    # ISE also has not perfect but roughly equiv workingdir (unless script cd's):
    #$ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath('.\')
    write-verbose "`$ScriptDir:$($ScriptDir)`n`$ScriptBaseName:$($ScriptBaseName)`n`$ScriptNameNoExt:$($ScriptNameNoExt)`n`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;
    

    # 11:19 AM 2/24/2017 add password generator
    [Reflection.Assembly]::LoadWithPartialName("System.Web") | out-null ;

    # Clear error variable
    $Error.Clear() ;

    #endregion INIT; # ------

    #region FUNCTIONS ; # ------
    #*======v FUNCTIONS v======


    function _cleanup  {
        # clear all objects and exit
        # 11:15 AM 5/11/2021 renamed helper func Cleanup -> _cleanup
        # 1:36 PM 11/16/2018 Cleanup:stop-transcriptlog left tscript running, test again and re-stop
        # 8:15 AM 10/2/2018 Cleanup:make it defer to $script:cleanup() (needs to be preloaded before verb-transcript call in script), added missing semis, replaced all $bDebug -> $showDebug
        # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
        # 8:45 AM 10/13/2015 reset $DebugPreference to default SilentlyContinue, if on
        # # 8:46 AM 3/11/2015 at some time from then to 1:06 PM 3/26/2015 added ISE Transcript
        # 8:39 AM 12/10/2014 shifted to stop-transcriptLog function
        # 7:43 AM 1/24/2014 always stop the running transcript before exiting
        if ($showdebug) {"_cleanup  "} ;
        #stop-transcript ;
        <#actually, with write-log in use, I don't even need cleanup /ISE logging, it's already covered in new-mailboxshared() etc)
        if($host.Name -eq "Windows PowerShell ISE Host"){
            # 8:46 AM 3/11/2015 shift the logfilename gen out here, so that we can arch it
            #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -uformat "%Y%m%d-%H%M" ) + "-ISEtrans.log")) ;
            # 2:16 PM 4/27/2015 shift to static timestamp $timeStampNow
            #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + $timeStampNow + "-ISEtrans.log")) ;
            # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
            $Logname=(join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
            write-host "`$Logname: $Logname";
            Start-iseTranscript -logname $Logname ;
            #Archive-Log $Logname ;
            # 1:23 PM 4/23/2015 standardize processing file so that we can send a link to open the transcript for review
            $transcript = $Logname ;
        } else {
            if($showdebug){ write-debug "$(Get-Date -Format 'HH:mm:ss'):Stop Transcript" };
            Stop-TranscriptLog ;
            #if($showdebug){ write-debug "$(Get-Date -Format 'HH:mm:ss'):Archive Transcript" };
            #Archive-Log $transcript ;
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):`$transcript:$(($transcript|out-string).trim())" ;
        } # if-E
        # 1:36 PM 11/16/2018 _cleanup  :stop-transcriptlog left tscript running, test again and re-stop
        if (Test-Transcribing) {
            Stop-Transcript
            if ($showdebug) {write-host -foregroundcolor green "`$transcript:$transcript"} ;
        }  # if-E
        #>
        #11:10 AM 4/2/2015 add an exit comment
        Write-Verbose -Verbose:$verbose "END $BARSD4 $scriptBaseName $BARSD4"  ;
        Write-Verbose -Verbose:$verbose "$BARSD40" ;
        # finally restore the DebugPref if set
        if ($ShowDebug -OR ($DebugPreference = "Continue")) {
            Write-Verbose -Verbose:$true "Resetting `$DebugPreference from 'Continue' back to default 'SilentlyContinue'" ;
            $showdebug=$false ;
            # 8:41 AM 10/13/2015 also need to enable write-debug output (and turn this off at end of script, it's a global, normally SilentlyContinue)
            $DebugPreference = "SilentlyContinue" ;
        } # if-E
        exit ;
    #} ;
    } ; #*------^ END Function _cleanup   ^------




    #*======^ END Functions ^======
    #endregion FUNCTIONS ; # ------

    #region SUBMAIN ; # ------
    #*======v SUB MAIN v======


    $pltInput=[ordered]@{} ;

    if ($PSCommandPath) { $pltInput.add("ParentPath", $PSCommandPath) } ;
    if($TargetID){$pltInput.add("TargetID",$TargetID) } ;
    if($SecGrpName){$pltInput.add("SecGrpName",$SecGrpName) } ;
    if($Owner){$pltInput.add("Owner",$Owner) } ;
    if($PermsDays){$pltInput.add("PermsDays",$PermsDays) } ;
    if($SiteOverride){$pltInput.add("SiteOverride",$SiteOverride) } ;
    if($Members){$pltInput.add("Members",$Members) } ;
    if($Ticket){$pltInput.add("Ticket",$Ticket) } ;
    if($NoPrompt){$pltInput.add("NoPrompt",$NoPrompt) } ;
    if($domaincontroller){$pltInput.add("domaincontroller",$domaincontroller) } ;
    if($showDebug){$pltInput.add("showDebug",$showDebug) } ;
    if($whatIf){$pltInput.add("whatIf",$whatIf) } ;

    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):add-MbxAccessGrant w`n$(($pltInput|out-string).trim())" ;
    if(-not($NoOutput)){
        $bRet = add-MailboxAccessGrant @pltInput ;  
        $bRet | write-output ;
    } else { 
        add-MailboxAccessGrant @pltInput
    } ; 
    #_cleanup   ;
    #Exit ;

    #*======^ END SUB MAIN ^======
    #endregion SUBMAIN ; # ------
}

#*------^ add-MbxAccessGrant.ps1 ^------


#*------v Connect-Ex2010.ps1 v------
Function Connect-Ex2010 {
  <#
    .SYNOPSIS
    Connect-Ex2010 - Setup Remote ExchOnPrem Mgmt Shell connection (validated functional Exch2010 - Exch2016)
    .NOTES
    Author: Todd Kadrie
    Website:	http://toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    AddedCredit : Inspired by concept code by ExactMike Perficient, Global Knowl... (Partner)
    AddedWebsite:	https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    Version     : 1.1.0
    CreatedDate : 2020-02-24
    FileName    : Connect-Ex2010()
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell
    REVISIONS   :
    * 1:30 PM 9/5/2024 added  update-SecurityProtocolTDO() SB to begin
    * 3:11 PM 7/15/2024 needed to change CHKPREREQ to check for presence of prop, not that it had a value (which fails as $false); hadn't cleared $MetaProps = ...,'DOESNTEXIST' ; confirmed cxo working non-based
    * 10:47 AM 7/11/2024 cleared debugging NoSuch etc meta tests
    * 1:34 PM 6/21/2024 ren $Global:E10Sess -> $Global:EXOPSess ; add: prereq checks, and $isBased support, to devert into most connect-exchangeServerTDO, get-ADExchangeServerTDO 100% generic fall back support (including buffering in the pair of funcs)
    # 9:43 AM 7/27/2021 revised -PSTitleBar to support suffix EMS[ctl]
    # 1:31 PM 7/21/2021 revised Add-PSTitleBar $sTitleBarTag with TenOrg spec (for prompt designators)
    # 3:18 PM 5/18/2021 somehow lost $credOpTORSID, so flipped lost default $credOPTor -> $credTORSID
    * 11:40 AM 5/14/2021 added -ea 0 to the gv tests (suppresses not-found error when called without logging config)
    * 11:22 AM 4/21/2021 coded around recent 'verbose the heck out of everything', yanked 99% of the verbose support - this seldom fails in a way that you need verbose, and when it's on, every cmdlet in the modules get echo'd, spams the heck out of console & logging. One key change (not sure if source) was to switch from inline import-pss & import-mod, into 2 steps with varis.
    * 10:02 AM 4/12/2021 add alias connect-ExOP (eventually rename verb-ex2010 to verb-exOnPrem)
    * 12:06 PM 4/2/2021 added alias cxOP ; added explicit echo on import-session|module, removed redundant catch block; added trycatch around import-sess|mod ; added recStatus support
    # 8:34 AM 3/31/2021 added verbose suppress to all import-mods ; renamed-standardized splat names (EMSSplat ->pltNSess ; ) ; flipped prefix into splat add ;
    * 2:36 PM 3/23/2021 getting away from dyn, random from array in $XXXMeta.Ex10Server, doesn't rely on AD lookups for referrals
    * 10:14 AM 3/23/2021 flipped default $Cred spec, pointed at an OP cred (matching reconnect-ex2010())
    * 11:36 AM 3/5/2021 updated colorcode, subed wv -verbose with just write-verbose, added cred.uname echo
    * 1:15 PM 3/1/2021 added org-level color-coded console
    * 3:28 PM 2/17/2021 updated to support cross-org, leverages new $XXXMeta.ExRevision, ExViewForest
    * 5:16 PM 10/22/2020 switched to no-loop meta lookup; debugged, fixed
    * 7:13 AM 7/22/2020 replaced codeblock w get-TenantTag(), flipped ExAdmin fr switch to un-typed
    * 5:11 PM 7/21/2020 added VEN support
    * 12:20 PM 5/27/2020 moved aliases: Add-EMSRemote,cx10 win func
    * 10:13 AM 5/15/2020 with vpn AD Ex lookup issue, patched in backup pass of get-ExchangeServerFromExGroup, in case of fail ; added failthrough to updated get-ExchangeServerFromExGroup, and finally to profile $smtpserver
    * 10:19 AM 2/24/2020 Connect-Ex2010/-OBS v1.1.0: updated cx10 to reflect infra file cred name change: cred####SID -> cred###SID, debugged, working, updated output banner to draw from global session, rather than imported module (was blank output). Ren'ing this one to the primary vers, and the prior to -OBS. Changed attribution, other than function names & concept, none of the code really sources back to Mike's original any more.
    * 6:59 PM 1/15/2020 cleanup
    * 7:51 AM 12/5/2019 Connect-Ex2010:retooled $ExAdmin variant webpool support - now has detect in the server-pick logic, and on failure, it retries to the stock pool.
    * 8:55 AM 11/27/2019 expanded $Credential support to switch to torolab & - potentiall/uncfg'd - CMW mail infra. Fw seems to block torolab access (wtf)
    * # 7:54 AM 11/1/2017 add titlebar tag & updated example to test for pres of Add-PSTitleBar
    * 12:09 PM 12/9/2016 implented and debugged as part of verb-Ex2010 set
    * 2:37 PM 12/6/2016 ported to local EMSRemote
    * 2/10/14 posted version
    $Credential can leverage a global: $Credential = $global:SIDcred
    .DESCRIPTION
    Connect-Ex2010 - Setup Remote Exch2010 Mgmt Shell connection
    This supports Non-Restricted IIS custom pools, which are created via create-EMSOpenRemotePool.ps1
    .PARAMETER  ExchangeServer
    Exch server to Remote to
    .PARAMETER  ExAdmin
    Use exadmin IIS WebPool for remote EMS[-ExAdmin]
    .PARAMETER  Credential
    Credential object
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    # -----------
    try{
        $reqMods="Connect-Ex2010;Reconnect-Ex2010;Disconnect-Ex2010;Get-ExchangeServerInSite;Disconnect-PssBroken;Add-PSTitleBar".split(";") ;
        $reqMods | % {if( !(test-path function:$_ ) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing $($_) function. EXITING." } } ;
        Reconnect-Ex2010 ;
    } CATCH {
        Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
        Exit #STOP(debug)|EXIT(close)|Continue(move on in loop cycle) ;
    } ;

    # -----------
    .EXAMPLE
    # -----------
    $rgxExoPsHostName="^(ps\.outlook\.com|outlook\.office365\.com)$" ;
    $rgxRemsPssName="^(Exchange2010|Session\sfor\simplicit\sremoting\smodule\sat\s.*)" ;
    $rgxSnapPssname="^Session\d{1}$" ;
    $rgxEx2010SnapinName="^Microsoft\.Exchange\.Management\.PowerShell\.E2010$";
    $Ex2010SnapinName="Microsoft.Exchange.Management.PowerShell.E2010" ;
    $Error.Clear() ;
    TRY {
    if(($host.version.major -lt 3) -AND (get-service MSExchangeADTopology -ea SilentlyContinue)){
        if (!(Get-PSSnapin | where {$_.Name -match $rgxEx2010SnapinName})) {Add-PSSnapin $Ex2010SnapinName -ea Stop} ;
            write-verbose -verbose:$bshowVerbose  "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Using Local Server EMS10 Snapin" ;
            $Global:E10IsDehydrated=$false ;
        } else {
            $reqMods="Connect-Ex2010;Reconnect-Ex2010;Disconnect-Ex2010;Get-ExchangeServerInSite;Disconnect-PssBroken;Cleanup;Add-PSTitleBar;Remove-PSTitleBar".split(";") ;
            $reqMods | % {if( !(test-path function:$_ ) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing $($_) function. EXITING." } } ;
            if(!(Get-PSSession |?{$_.ComputerName -match "^(adl|spb|lyn|bcc)ms\d{3}\.global\.ad\.toro\.com$" -AND $_.ConfigurationName -eq "Microsoft.Exchange" -AND $_.Name -eq "Exchange2010" -AND $_.State -eq "Opened" -AND $_.Availability -eq "Available"})){
    reconnect-Ex2010 ;
            $Global:E10IsDehydrated=$true ;
        } else {
          write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Functional REMS connection found. " ;
        } ;
    } ;
    get-exchangeserver | out-null ;
    # -----------
    More detailed REMS & server-EMS snapin coexistince version.
    .EXAMPLE
    # -----------
    if(!(Get-PSSnapin | where {$_.Name -match $rgxEx2010SnapinName})){
        Do {
            write-host "." -NoNewLine;Start-Sleep -m (1000 * 5)
            if( !(Get-PSSession|?{$_.Name -match $rgxRemsPssName -AND $_.ComputerName -match $rgxProdEx2010ServersFqdn -AND $_.State -eq 'Opened' -AND $_.Availability -eq 'Available'}) ){
                    Reconnect-Ex2010 ;
            } ;
        } Until ((Get-PSSession|?{($_.Name -match $rgxRemsPssName -AND $_.ComputerName -match $rgxProdEx2010ServersFqdn) -AND ($_.State -eq 'Opened') -AND ($_.Availability -eq 'Available')}))
    } ;
    # -----------
    Looping reconnect test example ; defers to existing Snapin (which should be self-maintaining)
    .LINK
    https://github.com/tostka/verb-Ex2010/
    #>
    #[CmdletBinding()] # 10:03 AM 4/21/2021 disable, see if it kills verbose
    [Alias('Add-EMSRemote','cx10','cxOP','connect-ExOP')]
    Param(
        [Parameter(Position = 0, HelpMessage = "Exch server to Remote to")]
            [string]$ExchangeServer,
        [Parameter(HelpMessage = 'Use exadmin IIS WebPool for remote EMS[-ExAdmin]')]
            $ExAdmin,
        [Parameter(HelpMessage = 'Credential object')][System.Management.Automation.PSCredential]
            $Credential = $credTORSID
    )  ;
    BEGIN{
        #$verbose = ($VerbosePreference -eq "Continue") ;
		$CurrentVersionTlsLabel = [Net.ServicePointManager]::SecurityProtocol ; # Tls, Tls11, Tls12 ('Tls' == TLS1.0)  ;
        write-verbose "PRE: `$CurrentVersionTlsLabel : $($CurrentVersionTlsLabel )" ;
        # psv6+ already covers, test via the SslProtocol parameter presense
        if ('SslProtocol' -notin (Get-Command Invoke-RestMethod).Parameters.Keys) {
            $currentMaxTlsValue = [Math]::Max([Net.ServicePointManager]::SecurityProtocol.value__,[Net.SecurityProtocolType]::Tls.value__) ;
            write-verbose "`$currentMaxTlsValue : $($currentMaxTlsValue )" ;
            $newerTlsTypeEnums = [enum]::GetValues('Net.SecurityProtocolType') | Where-Object { $_ -gt $currentMaxTlsValue }
            if($newerTlsTypeEnums){
                write-verbose "Appending upgraded/missing TLS `$enums:`n$(($newerTlsTypeEnums -join ','|out-string).trim())" ;
            } else {
                write-verbose "Current TLS `$enums are up to date with max rev available on this machine" ;
            };
            $newerTlsTypeEnums | ForEach-Object {
                [Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor $_
            } ;
        } ;
        
        #region CHKPREREQ ; #*------v CHKPREREQ v------
        # critical dependancy Meta variables
        $MetaNames = ,'TOR','CMW','TOL' #,'NOSUCH' ; 
        # critical dependancy Meta variable properties
        $MetaProps = 'Ex10Server','Ex10WebPoolVariant','ExRevision','ExViewForest','ExOPAccessFromToro','legacyDomain' #,'DOESNTEXIST' ; 
        # critical dependancy parameters
        $gvNames = 'Credential' 
        $isBased = $true ; $gvMiss = @() ; $ppMiss = @() ; 
        foreach($met in $metanames){
            write-verbose "chk:`$$($met)Meta" ; 
            if(-not (gv -name "$($met)Meta" -ea 0)){$isBased = $false; $gvMiss += "$($met)Meta" } ; 
            if($MetaProps){
                foreach($mp in $MetaProps){
                    write-verbose "chk:`$$($met)Meta.$($mp)" ; 
                    #if(-not (gv -name "$($met)Meta" -ea 0).value[$mp]){
                    if(-not (gv -name "$($met)Meta" -ea 0).value.keys -contains $mp){
                        $isBased = $false; $ppMiss += "$($met)Meta.$($mp)" 
                    } ; 
                } ; 
            } ; 
        } ; 
        if($gvNames){
            foreach($gvN in $gvNames){
                write-verbose "chk:`$$($gvN)" ; 
                if(-not (gv -name "$($gvN)" -ea 0)){$isBased = $false; $gvMiss += "$($gvN)" } ; 
            } ; 
        } ; 
        if($gvmiss){write-warning "Missing Dependant Meta variables:`n$(($gvMiss |%{"`$$($_)" }) -join ',')" } ; 
        if($ppMiss){write-warning "Missing Dependant Meta vari properties:`n$(($ppMiss |%{"`$$($_)" }) -join ',')" } ; 
        if(-not $isBased){ write-warning  "missing critical dependancy profile config!" } ; 
        #endregion CHKPREREQ ; #*------^ END CHKPREREQ ^------


        $sWebPoolVariant = "exadmin" ;
        $CommandPrefix = $null ;
        # use credential domain to determine target org
        $rgxLegacyLogon = '\w*\\\w*' ;

        #region CONNEXOPTDO ; #*------v  v------
        #*------v Function Connect-ExchangeServerTDO v------
        #if(-not(get-command Connect-ExchangeServerTDO -ea SilentlyContinue)){
            Function Connect-ExchangeServerTDO {
                <#
                .SYNOPSIS
                Connect-ExchangeServerTDO.ps1 - Dependancy-less Function that, fed an Exchange server name, or AD SiteName, and optional RoleNames array, 
                will obtain a list of Exchange servers from AD (in the specified scope), and then run the list attempting to PowershellREmote (REMS) connect to each server, 
                stopping at the first successful connection.
                .NOTES
                Version     : 3.0.3
                Author      : Todd Kadrie
                Website     : http://www.toddomation.com
                Twitter     : @tostka / http://twitter.com/tostka
                CreatedDate : 2024-05-30
                FileName    : Connect-ExchangeServerTDO.ps1
                License     : (none-asserted)
                Copyright   : (none-asserted)
                Github      : https://github.com/tostka/verb-Ex2010
                Tags        : Powershell, ActiveDirectory, Exchange, Discovery
                AddedCredit : Brian Farnsworth
                AddedWebsite: https://codeandkeep.com/
                AddedTwitter: URL
                AddedCredit : David Paulson
                AddedWebsite: https://techcommunity.microsoft.com/t5/exchange-team-blog/exchange-health-checker-has-a-new-home/ba-p/2306671
                AddedTwitter: URL
                REVISIONS
                * 12:49 PM 6/21/2024 flipped PSS Name to Exchange$($ExchVers[dd])
                * 12:57 PM 6/11/2024 Validated, Ex2010 & Ex2019, hub, mail & edge roles: tested ☑️ on CMW mail role (Curly); and Jumpbox; 
                    copied in CBH from repo copy, which has been updated/debugged compat on CMW Edge 
                    includes local snapin detect & load for edge role (simplest EMS load option for Edge role, from David Paulson's original code; no longer published with Ex2010 compat)
                * 11:28 AM 5/30/2024 fixed failure to recognize existing functional PSSession; Made substantial update in logic, validate works fine with other orgs, and in our local orgs.
                * 4:02 PM 8/28/2023 debuged, updated CBH, renamed connect-ExchangeSErver -> Connect-ExchangeServerTDO (avoid name clashes, pretty common verb-noun combo).
                * 12:36 PM 8/24/2023 init

                .DESCRIPTION
                Connect-ExchangeServerTDO.ps1 - Dependancy-less Function that, fed an Exchange server name, or AD SiteName, and optional RoleNames array, 
                will obtain a list of Exchange servers from AD (in the specified scope), and then run the list attempting to PowershellRemote (REMS) connect to each server, 
                stopping at the first successful connection.

                Relies upon/requires get-ADExchangeServerTDO(), to return a descriptive summary of the Exchange server(s) revision etc, for connectivity logic.
                Supports Exchange 2010 through 2019, as implemented.
            
                Intent, as contrasted with verb-EXOP/Ex2010 is to have no local module dependancies, when running EXOP into other connected orgs, where syncing profile & supporting modules code can be problematic. 
                This uses native ADSI calls, which are supported by Windows itself, without need for external ActiveDirectory module etc.

                The particular approach inspired by BF's demo func that accompanied his take on get-adExchangeServer(), which I hybrided with my own existing code for cred-less connectivity. 
                I added get-OrganizationConfig testing, for connection pre/post confirmation, along with Exchange Server revision code for continutional handling of new-pssession remote powershell EMS connections.
                Also shifted connection code into _connect-EXOP() internal func.
                As this doesn't rely on local module presnece, it doesn't have to do the usual local remote/local invocation detection you'd do for non-dehydrated on-server EMS (more consistent this way, anyway; 
                there are only a few cmdlet outputs I'm aware of, that have fundementally broken returns dehydrated, and require local non-remote EMS use to function.

                My core usage would be to paste the function into the BEGIN{} block for a given remote org process, to function as a stricly local ad-hoc function.
                .PARAMETER name
                FQDN of a specific Exchange server[-Name EXSERVER.DOMAIN.COM]
                .PARAMETER discover
                Boolean paraameter that drives auto-discovery of target Exchange servers for connection (defaults `$true)[-discover:`$false]
                .PARAMETER credential
                Use specific Credentials[-Credentials [credential object]
                    .PARAMETER Site
                Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-Site 'SITENAME']
                .PARAMETER RoleNames
                Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']
                .PARAMETER TenOrg
                Tenant Tag (3-letter abbrebiation - defaults to variable `$global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']
                .INPUTS
                None. Does not accepted piped input.(.NET types, can add description)
                .OUTPUTS
                [system.object] Returns a system object containing a successful PSSession
                System.Boolean
                [| get-member the output to see what .NET obj TypeName is returned, to use here]
                System.Array of System.Object's
                .EXAMPLE
                PS> $PSSession = Connect-ExchangeServerTDO -siteName SITENAME -RoleNames @('HUB','CAS') -verbose 
                Demo's connecting to a functional Hub or CAS server in the SITENAME site with verbose outputs, the `PSSession variable will contain information about the successful connection. Makes automatic Exchangeserver discovery calls into AD (using ADSI) leveraging the separate get-ADExchangeServerTDO()
                .EXAMPLE
                PS> TRY{$Site=[System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name}CATCH{$Site=$env:COMPUTERNAME} ;
                PS> $PSSession = Connect-ExchangeServerTDO -siteName $Site -RoleNames @('HUB','CAS') -verbose ; 
                Demo including support for EdgeRole, which is detected on it's lack of AD Site specification (which gets fed through to call, by setting the Site to the machine itself).
                .LINK
                https://codeandkeep.com/PowerShell-ActiveDirectory-Exchange-Part1/
                .LINK
                https://github.com/Lucifer1993/PLtools/blob/main/HealthChecker.ps1
                .LINK
                https://microsoft.github.io/CSS-Exchange/Diagnostics/HealthChecker/
                .LINK
                https://bitbucket.org/tostka/powershell/
                .LINK
                https://github.com/tostka/verb-Ex2010
                #>        
                [CmdletBinding(DefaultParameterSetName='discover')]
                PARAM(
                    [Parameter(Position=0,Mandatory=$true,ParameterSetName='name',HelpMessage="FQDN of a specific Exchange server[-Name EXSERVER.DOMAIN.COM]")]
                        [String]$name,
                    [Parameter(Position=0,ParameterSetName='discover',HelpMessage="Boolean paraameter that drives auto-discovery of target Exchange servers for connection (defaults `$true)[-discover:`$false]")]
                        [bool]$discover=$true,
                    [Parameter(Position=1,HelpMessage = "Use specific Credentials[-Credentials [credential object]")]
                        [Management.Automation.PSCredential]$credential,
                    [Parameter(Position=1,HelpMessage="Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-Site 'SITENAME']")]
                        [Alias('Site')]
                        [string]$SiteName = (gv -name "$($TenOrg)_ADSiteDefaultName" -ea 0).Value,
                    [Parameter(Position=2,HelpMessage="Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']")]
                        [ValidateSet('MBX','CAS','HUB','UM','MBX','EDGE')]
                        [string[]]$RoleNames = @('HUB','CAS'),
                    [Parameter(Mandatory=$FALSE,HelpMessage="Tenant Tag (3-letter abbrebiation - defaults to global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']")]
                        [ValidateNotNullOrEmpty()]
                        [string]$TenOrg = $global:o365_TenOrgDefault
                ) ;
                BEGIN{
                    $Verbose = ($VerbosePreference -eq 'Continue') ;
                    write-verbose "#*------v Function _connect-ExOP v------" ;
                    function _connect-ExOP{
                        [CmdletBinding()]
                        PARAM(
                            [Parameter(Position=0,Mandatory=$true,HelpMessage="Exchange server AD Summary system object[-Server EXSERVER.DOMAIN.COM]")]
                                [system.object]$Server,
                            [Parameter(Position=1,HelpMessage = "Use specific Credentials[-Credentials [credential object]")]
                                [Management.Automation.PSCredential]$credential
                        );
                        $verbose = $($VerbosePreference -eq "Continue") ;
                        if([double]$ExVersNum = [regex]::match($Server.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value){
                            switch -regex ([string]$ExVersNum) {
                                '15.2' { $isEx2019 = $true ; $ExVers = 'Ex2019' }
                                '15.1' { $isEx2016 = $true ; $ExVers = 'Ex2016'}
                                '15.0' { $isEx2013 = $true ; $ExVers = 'Ex2013'}
                                '14.*' { $isEx2010 = $true ; $ExVers = 'Ex2010'}
                                '8.*' { $isEx2007 = $true ; $ExVers = 'Ex2007'}
                                '6.5' { $isEx2003 = $true ; $ExVers = 'Ex2003'}
                                '6' {$isEx2000 = $true ; $ExVers = 'Ex2000'} ;
                                default {
                                    $smsg = "UNRECOGNIZED ExVersNum.Major.Minor string:$($ExVersNum)! ABORTING!" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    THROW $SMSG ;
                                    BREAK ;
                                }
                            } ;
                        }else {
                            $smsg = "UNABLE TO RESOLVE `$ExVersNum from `$Server.version:$($Server.version)!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            throw $smsg ;
                            break ;
                        } ;
                        if($Server.RoleNames -eq 'EDGE'){
                            if(($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup')) -or
                                ($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup')) -or
                                $ByPassLocalExchangeServerTest)
                            {
                                if((Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\EdgeTransportRole') -or
                                     (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\EdgeTransportRole'))
                                {
                                    write-verbose ("We are on Exchange Edge Transport Server")
                                    $IsEdgeTransport = $true
                                }
                                TRY {
                                    Get-ExchangeServer -ErrorAction Stop | Out-Null
                                    write-verbose "Exchange PowerShell Module already loaded."
                                    $passed = $true 
                                }CATCH {
                                    write-verbose ("Failed to run Get-ExchangeServer")
                                    if($isLocalExchangeServer){
                                        write-host  "Loading Exchange PowerShell Module..."
                                        TRY{
                                            if($IsEdgeTransport){
                                                # implement local snapins access on edge role: Only way to get access to EMS commands.
                                                [xml]$PSSnapIns = Get-Content -Path "$env:ExchangeInstallPath\Bin\exshell.psc1" -ErrorAction Stop
                                                ForEach($PSSnapIn in $PSSnapIns.PSConsoleFile.PSSnapIns.PSSnapIn){
                                                    write-verbose ("Trying to add PSSnapIn: {0}" -f $PSSnapIn.Name)
                                                    Add-PSSnapin -Name $PSSnapIn.Name -ErrorAction Stop
                                                } ; 
                                                Import-Module $env:ExchangeInstallPath\bin\Exchange.ps1 -ErrorAction Stop ; 
                                                $passed = $true #We are just going to assume this passed.
                                            }else{
                                                Import-Module $env:ExchangeInstallPath\bin\RemoteExchange.ps1 -ErrorAction Stop
                                                Connect-ExchangeServer -Auto -ClientApplication:ManagementShell
                                                $passed = $true #We are just going to assume this passed.
                                            } 
                                        }CATCH {
                                            write-host ("Failed to Load Exchange PowerShell Module...")
                                        }                               
                                    } ;
                                } FINALLY {
                                    if($LoadExchangeVariables -and $passed -and $isLocalExchangeServer){
                                        if($ExInstall -eq $null -or $ExBin -eq $null){
                                            if(Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup'){
                                                $Global:ExInstall = (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup).MsiInstallPath
                                            }else{
                                                $Global:ExInstall = (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup).MsiInstallPath
                                            }
            
                                            $Global:ExBin = $Global:ExInstall + "\Bin"
            
                                            write-verbose ("Set ExInstall: {0}" -f $Global:ExInstall)
                                            write-verbose ("Set ExBin: {0}" -f $Global:ExBin)
                                        }
                                    }
                                }
                            } else  {
                                write-verbose ("Does not appear to be an Exchange 2010 or newer server.")
                            }
                            if(get-command -Name Get-OrganizationConfig -ea 0){
                                $smsg = "Running in connected/Native EMS" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                Return $true ; 
                            } else { 
                                TRY{
                                    $smsg = "Initiating Edge EMS local session (exshell.psc1 & exchange.ps1)" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                    # 5;36 PM 5/30/2024 didn't work, went off to nowhere for a long time, and exited the script
                                    #& (gcm powershell.exe).path -PSConsoleFile "$($env:ExchangeInstallPath)bin\exshell.psc1" -noexit -command ". '$($env:ExchangeInstallPath)bin\Exchange.ps1'"
                                    <# [Adding the Transport Server to Exchange - Mark Lewis Blog](https://marklewis.blog/2020/11/19/adding-the-transport-server-to-exchange/)
                                    To access the management console on the transport server, I opened PowerShell then ran
                                    exshell.psc1
                                    Followed by
                                    exchange.ps1
                                    At this point, I was able to create a new subscription using he following PowerShel
                                    #>
                                    invoke-command exshell.psc1 ; 
                                    invoke-command exchange.ps1
                                    if(get-command -Name Get-OrganizationConfig -ea 0){
                                        $smsg = "Running in connected/Native EMS" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                        Return $true ;
                                    } else { return $false };  
                                }CATCH{
                                    Write-Error $_ ;
                                } ;
                            } ; 
                        } else {
                            $pltNPSS=@{ConnectionURI="http://$($Server.FQDN)/powershell"; ConfigurationName='Microsoft.Exchange' ; name="Exchange$($ExVersNum.tostring())"} ;
                            # use ExVersUnm dd instead of hardcoded (Exchange2010)
                            if($ExVersNum -ge 15){
                                write-verbose "EXOP.15+:Adding -Authentication Kerberos" ;
                                $pltNPSS.add('Authentication',"Kerberos") ;
                                $pltNPSS.name = $ExVers ;
                            } ;
                            $smsg = "Adding EMS (connecting to $($Server.FQDN))..." ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            $smsg = "New-PSSession w`n$(($pltNPSS|out-string).trim())" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            $ExPSS = New-PSSession @pltNPSS  ;
                            $ExIPSS = Import-PSSession $ExPSS -allowclobber ;
                            $ExPSS | write-output ;
                            $ExPSS= $ExIPSS = $null ;
                        } ; 
                    } ;
                    write-verbose "#*------^ END Function _connect-ExOP ^------" ;
                    $pltGADX=@{
                        ErrorAction='Stop';
                    } ;
                } ;
                PROCESS{
                    if($PSBoundParameters.ContainsKey('credential')){
                        $pltGADX.Add('credential',$credential) ;
                    }
                    if($SiteName){
                        $pltGADX.Add('siteName',$siteName) ;
                    } ;
                    if($RoleNames){
                        $pltGADX.Add('RoleNames',$RoleNames) ;
                    } ;
                    TRY{
                        if($discover){
                            $smsg = "Getting list of Exchange Servers" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            $exchServers=get-ADExchangeServerTDO @pltGADX | sort responsetime ;
                        }else{
                            $exchServers=get-ADExchangeServerTDO @pltGADX | sort responsetime ;
                        } ;
                        $pltTW=@{
                            'ErrorAction'='Stop';
                        } ;
                        $pltCXOP = @{
                            verbose = $($VerbosePreference -eq "Continue") ;
                        } ;
                        if($pltGADX.credential){
                            $pltCXOP.Add('Credential',$pltCXOP.Credential) ;
                        } ;
                        $prpPSS = 'Id','Name','ComputerName','ComputerType','State','ConfigurationName','Availability' ; 
                        foreach($exServer in $exchServers){
                            write-verbose "testing conn to:$($exServer.name.tostring())..." ; 
                            if(get-command -module (get-module |?{$_.name -like 'tmp_*'}).name -name 'get-OrganizationConfig' -ea SilentlyContinue){
                                if($pssEXOP = Get-PSSession |  where-object { ($_.ConfigurationName -eq 'Microsoft.Exchange') -AND ( $_.runspace.ConnectionInfo.AppName -match '^/(exadmin|powershell)$') -AND ( $_.runspace.ConnectionInfo.Port -eq '80') }){
                                    if($pssEXOP.State -ne "Opened" -OR $pssEXOP.Availability -ne "Available"){
                                        $pssEXOP | remove-pssession ; $pssEXOP = $null ;
                                    } ;
                                } ; 
                            } else {
                                $smsg = "(mangled ExOP conn: disconnect/reconnect...)" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                if($pssEXOP = Get-PSSession |  where-object { ($_.ConfigurationName -eq 'Microsoft.Exchange') -AND ( $_.runspace.ConnectionInfo.AppName -match '^/(exadmin|powershell)$') -AND ( $_.runspace.ConnectionInfo.Port -eq '80') }){
                                    if($pssEXOP.State -ne "Opened" -OR $pssEXOP.Availability -ne "Available"){
                                        $pssEXOP | remove-pssession ; $pssEXOP = $null ;
                                    } ;
                                } ; 
                            } ;
                            if(-not $pssEXOP){
                                $smsg = "Connecting to: $($exServer.FQDN)" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                if($NoTest){
                                    $ExPSS =$ExPSS = _connect-ExOP @pltCXOP -Server $exServer
                               } else {
                                    TRY{
                                        $smsg = "Testing Connection: $($exServer.FQDN)" ;
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                        If(test-connection $exServer.FQDN -count 1 -ea 0) {
                                            $smsg = "confirmed pingable..." ;
                                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                        } else {
                                            $smsg = "Unable to Ping $($exServer.FQDN)" ; ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        } ;
                                        $smsg = "Testing WinRm: $($exServer.FQDN)" ;
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                        $winrm=Test-WSMan @pltTW -ComputerName $exServer.FQDN ;
                                        if($winrm){
                                            $ExPSS = _connect-ExOP @pltCXOP -Server $exServer;
                                        } else {
                                            $smsg = "Unable to Test-WSMan $($exServer.FQDN) (skipping)" ; ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        } ;
                                    }CATCH{
                                        $errMsg="Server: $($exServer.FQDN)] $($_.Exception.Message)" ;
                                        Write-Error -Message $errMsg ;
                                        continue ;
                                    } ;
                                };
                            } else {
                                $smsg = "$((get-date).ToString('HH:mm:ss')):Accepting first valid connection w`n$(($pssEXOP | ft -a $prpPSS|out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success }
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                $ExPSS = $pssEXOP ; 
                                break ; 
                            }  ;
                        } ;
                    }CATCH{
                        Write-Error $_ ;
                    } ;
                } ;
                END{
                    if(-not $ExPSS){
                        $smsg = "NO SUCCESSFUL CONNECTION WAS MADE, WITH THE SPECIFIED INPUTS!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $smsg = "(returning `$false to the pipeline...)" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        return $false
                    } else{
                        if($ExPSS.State -eq "Opened" -AND $ExPSS.Availability -eq "Available"){
                            if(-not ($OrgName = ((get-OrganizationConfig).DistinguishedName.split(',') |?{$_ -like 'DC=*'}) -join '.' -replace 'DC=','')){
                                $smsg = "Missing Exchange Connection! (no (Get-OrganizationConfig).name returned)" ;
                                throw $smsg ;
                                $smsg | write-warning  ;
                            } else {
                                $smsg = "(connected to EXOP.Org:$($orgName))" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success }
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                            return $ExPSS
                        } ;
                    } ; 
                } ;
            } ;
        #} ; 
        #*------^ END Function Connect-ExchangeServerTDO ^------
        #endregion CONNEXOPTDO ; #*------^ END CONNEXOPTDO ^------
    
        #region GADEXSERVERTDO ; #*------v  v------
        #*------v Function get-ADExchangeServerTDO v------
        #if(-not(get-command get-ADExchangeServerTDO -ea SilentlyContinue)){
            Function get-ADExchangeServerTDO {
                <#
                .SYNOPSIS
                get-ADExchangeServerTDO.ps1 - Returns Exchangeserver summary(s) from AD records
                .NOTES
                Version     : 3.0.1
                Author      : Todd Kadrie
                Website     : http://www.toddomation.com
                Twitter     : @tostka / http://twitter.com/tostka
                CreatedDate : 2015-09-03
                FileName    : get-ADExchangeServerTDO.ps1
                License     : (none-asserted)
                Copyright   : (none-asserted)
                Github      : https://github.com/tostka/verb-Ex2010
                Tags        : Powershell, ActiveDirectory, Exchange, Discovery
                AddedCredit : Mike Pfeiffer
                AddedWebsite: mikepfeiffer.net
                AddedTwitter: URL
                AddedCredit : Sammy Krosoft 
                AddedWebsite: http://aka.ms/sammy
                AddedTwitter: URL
                AddedCredit : Brian Farnsworth
                AddedWebsite: https://codeandkeep.com/
                AddedTwitter: URL
                REVISIONS
                * 12:57 PM 6/11/2024 Validated, Ex2010 & Ex2019, hub, mail & edge roles: tested ☑️ on CMW mail role (Curly); and Jumpbox; copied in CBH from repo copy, which has been updated/debugged compat on CMW Edge 
                * 2:05 PM 8/28/2023 REN -> Get-ExchangeServerInSite -> get-ADExchangeServerTDO (aliased orig); to better steer profile-level options - including in cmw org, added -TenOrg, and default Site to constructed vari, targeting new profile $XXX_ADSiteDefault vari; Defaulted -Roles to HUB,CAS as well.
                * 3:42 PM 8/24/2023 spliced together combo of my long-standing, and some of the interesting ideas BF's version had. Functional prod:
                    - completely removed ActiveDirectory module dependancies from BF's code, and reimplemented in raw ADSI calls. Makes it fully portable, even into areas like Edge DMZ roles, where ADMS would never be installed.

                * 3:17 PM 8/23/2023 post Edge testing: some logic fixes; add: -Names param to filter on server names; -Site & supporting code, to permit lookup against sites *not* local to the local machine (and bypass lookup on the local machine) ; 
                    ren $Ex10siteDN -> $ExOPsiteDN; ren $Ex10configNC -> $ExopconfigNC
                * 1:03 PM 8/22/2023 minor cleanup
                * 10:31 AM 4/7/2023 added CBH expl of postfilter/sorting to draw predictable pattern 
                * 4:36 PM 4/6/2023 validated Psv51 & Psv20 and Ex10 & 16; added -Roles & -RoleNames params, to perform role filtering within the function (rather than as an external post-filter step). 
                For backward-compat retain historical output field 'Roles' as the msexchcurrentserverroles summary integer; 
                use RoleNames as the text role array; 
                    updated for psv2 compat: flipped hash key lookups into properties, found capizliation differences, (psv2 2was all lower case, wouldn't match); 
                flipped the [pscustomobject] with new... psobj, still psv2 doesn't index the hash keys ; updated for Ex13+: Added  16  "UM"; 20  "CAS, UM"; 54  "MBX" Ex13+ ; 16385 "CAS" Ex13+ ; 16439 "CAS, HUB, MBX" Ex13+
                Also hybrided in some good ideas from SammyKrosoft's Get-SKExchangeServers.psm1 
                (emits Version, Site, low lvl Roles # array, and an array of Roles, for post-filtering); 
                # 11:20 AM 4/21/2021 fixed/suppressed noisy verbose calls
                * 12:08 PM 5/15/2020 fixed vpn issue: Try/Catch'd around recently failing $ADSite::GetComputerSite().GetDirectoryEntry().distinguishedName qry
                * 11:22 AM 3/13/2020 Get-ExchangeServerInSite added a ping-test, to only return matches that are pingable, added -NoPing param, to permit (faster) untested bypass
                * 6:59 PM 1/15/2020 cleanup
                # 10:03 AM 11/16/2018 Get-ExchangeServerInSite:can't do AD-related functions when not AD authentictaed (home, pre-vpn connect). Added if/then test on status and abort balance when false.
                * 11/18/18 BF's posted rev
                # 12:10 PM 8/1/2017 updated example code at bottom, to accommodate variant sites
                # 11:28 AM 3/31/2016 validated that latest round of updates are still functional
                #1:58 PM 9/3/2015 - added pshelp and some docs
                #April 12, 2010 - web version
                .DESCRIPTION
                get-ADExchangeServerTDO.ps1 - Returns Exchangeserver summary(s) from AD records

                Hybrided together ideas from Brian Farnsworth's blog post
                [PowerShell - ActiveDirectory and Exchange Servers – CodeAndKeep.Com – Code and keep calm...](https://codeandkeep.com/PowerShell-ActiveDirectory-Exchange-Part1/)
                ... with much older concepts from  Sammy Krosoft, and much earlier Mike Pfeiffer. 

                - Subbed in MP's use of ADSI for ActiveDirectory Ps mod cmds - it's much more dependancy-free; doesn't require explicit install of the AD ps module
                ADSI support is built into windows.
                - spliced over my addition of Roles, RoleNames, Name & NoTest params, for prefiltering and suppressing testing.


                [briansworth · GitHub](https://github.com/briansworth)

                Uses an ADSI DirectorySearcher to search the current Active Directory site for Exchange on-prem servers.
                        Intent is to discover connection points for Powershell, wo the need to preload/pre-connect to Exchange.

                        But, as a non-Exchange-Management-Shell-dependant info source on Exchange Server configs, it can be used before connection, with solely AD-available data, to check configuration spes on the subject server(s). 

                        For example, this query will return sufficient data under Version to indicate which revision of Exchange is in use:


                        Returned object (in array):
                        Site      : {ADSITENAME}
                        Roles     : {64}
                        Version   : {Version 15.1 (Build 32375.7)}
                        Name      : SERVERNAME
                        RoleNames : EDGE
                        FQDN      : SERVERNAME.DOMAIN.TLD

                        ... includes the post-filterable Role property ($_.Role -contains 'CAS') which reflects the following
                        installed-roles ('msExchCurrentServerRoles') on the discovered servers
                            2   {"MBX"} # Ex10
                            4   {"CAS"}
                            16  {"UM"}
                            20  {"CAS, UM" -split ","} # 
                            32  {"HUB"}
                            36  {"CAS, HUB" -split ","}
                            38  {"CAS, HUB, MBX" -split ","}
                            54  {"MBX"} # Ex13+
                            64  {"EDGE"}
                            16385   {"CAS"} # Ex13+
                            16439   {"CAS, HUB, MBX"  -split ","} # Ex13+

                .PARAMETER Roles
                Array of msExchCurrentServerRoles 'role' integers to be filtered against (2|4|16|20|32|36|38|54|64|16385|16439)[-Roles @(38,16385)]
                .PARAMETER RoleNames
                Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']
                .PARAMETER Server
                Array of Server name strings to be filtered against[-Server 'SERVER1','SERVER2']
                .PARAMETER SiteName
                Name of specific AD SiteName to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-SiteName 'SITENAME']
                .PARAMETER TenOrg
                Tenant Tag (3-letter abbrebiation - defaults to variable `$global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']
                .PARAMETER NoPing
                Switch to suppress default 'pingable' test (e.g. returns all matches, no testing)[-NoPing]
                .INPUTS
                None. Does not accepted piped input.(.NET types, can add description)
                .OUTPUTS
                None. Returns no objects or output (.NET types)
                System.Boolean
                [| get-member the output to see what .NET obj TypeName is returned, to use here]
                System.Array of System.Object's
                .EXAMPLE
                PS> If(!($ExchangeServer)){$ExchangeServer = (get-ADExchangeServerTDO| ?{$_.RoleNames -contains 'CAS' -OR $_.RoleNames -contains 'HUB' -AND ($_.FQDN -match "^SITECODE") } | Get-Random ).FQDN
                Return a random Hub Cas Role server in the local Site with a fqdn beginning SITECODE
                .EXAMPLE
                PS> $localADExchserver = get-ADExchangeServerTDO -Names $env:computername -SiteName ([System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().name)
                Demo, if run from an Exchange server, return summary details about the local server (-SiteName isn't required, is default imputed from local server's Site, but demos explicit spec for remote sites)
                .EXAMPLE
                PS> $regex = '(' + [regex]($ADSiteCodeUK,$ADSiteCodeAU -join "|") + ')'
                PS> switch -regex ($($env:computername).substring(0,3)){
                PS>    "$($ADSiteCodeUS)" {$tExRole=36 } ;
                PS>    "$($regex)" {$tExRole= 38 }  default { write-error "$((get-date).ToString('HH:mm:ss')):UNRECOGNIZED SERVER PREFIX!."; } ;
                PS> } ;
                PS> $exhubcas = (get-ADExchangeServerTDO |?{($_.roles -eq $tExRole) -AND ($_.FQDN -match "$($env:computername.substring(0,3)).*")} | Get-Random ).FQDN ;
                Use a switch block to select different role combo targets for a given server fqdn prefix string.
                .EXAMPLE
                PS> $ExchangeServer = get-ADExchangeServerTDO | ?{$_.Roles -match '(4|20|32|36|38|16385|16439)'} | select -expand fqdn | get-random ; 
                Another/Older approach filtering on the Roles integer (targeting combos with Hub or CAS in the mix)
                .EXAMPLE
                PS> $ret = get-ADExchangeServerTDO -Roles @(4,20,32,36,38,16385,16439) -verbose 
                Demo use of the -Roles param, feeding it an array of Role integer values to be filtered against. In this case, the Role integers that include a CAS or HUB role.
                .EXAMPLE
                PS> $ret = get-ADExchangeServerTDO -RoleNames 'HUB','CAS' -verbose ;
                Demo use of the -RoleNames param, feeding it the array 'HUB','CAS' Role name strings to be filtered against
                PS> $ret = get-ADExchangeServerTDO -Names 'SERVERName' -verbose ;
                Demo use of the -RoleNames param, feeding it the array 'HUB','CAS' Role name strings to be filtered against
                .EXAMPLE
                PS> $ExchangeServer = get-ADExchangeServerTDO | sort version,roles,name | ?{$_.rolenames -contains 'CAS'}  | select -last 1 | select -expand fqdn ;
                Demo post sorting & filtering, to deliver a rule-based predictable pattern for server selection: 
                Above will always pick the highest Version, 'CAS' RoleName containing, alphabetically last server name (that is pingable). 
                And should stick to that pattern, until the servers installed change, when it will shift to the next predictable box.
                .EXAMPLE
                PS> $ExOPServer = get-ADExchangeServerTDO -Name LYNMS650 -SiteName Lyndale
                PS> if([double]$ExVersNum = [regex]::match($ExOPServer.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value){
                PS>     switch -regex ([string]$ExVersNum) {
                PS>         '15\.2' { $isEx2019 = $true ; $ExVers = 'Ex2019' }
                PS>         '15\.1' { $isEx2016 = $true ; $ExVers = 'Ex2016'}
                PS>         '15\.0' { $isEx2013 = $true ; $ExVers = 'Ex2013'}
                PS>         '14\..*' { $isEx2010 = $true ; $ExVers = 'Ex2010'}
                PS>         '8\..*' { $isEx2007 = $true ; $ExVers = 'Ex2007'}
                PS>         '6\.5' { $isEx2003 = $true ; $ExVers = 'Ex2003'}
                PS>         '6|6\.0' {$isEx2000 = $true ; $ExVers = 'Ex2000'} ;
                PS>         default {
                PS>             $smsg = "UNRECOGNIZED ExchangeServer.AdminDisplayVersion.Major.Minor string:$($ExOPServer.version)! ABORTING!" ;
                PS>             write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                PS>         }
                PS>     } ; 
                PS> }else {
                PS>     $smsg = "UNABLE TO RESOLVE `$ExVersNum from `$ExOPServer.version:$($ExOPServer.version)!" ; 
                PS>     write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ; 
                PS>     throw $smsg ; 
                PS>     break ; 
                PS> } ; 
                Demo of parsing the returned Version property, into the proper Exchange Server revision.      
                .LINK
                https://github.com/tostka/verb-XXX
                .LINK
                https://bitbucket.org/tostka/powershell/
                .LINK
                http://mikepfeiffer.net/2010/04/find-exchange-servers-in-the-local-active-directory-site-using-powershell/
                .LINK
                https://github.com/SammyKrosoft/Search-AD-Using-Plain-PowerShell/blob/master/Get-SKExchangeServers.psm1
                .LINK
                https://github.com/tostka/verb-Ex2010
                .LINK
                https://codeandkeep.com/PowerShell-ActiveDirectory-Exchange-Part1/
                #>
                [CmdletBinding()]
                [Alias('Get-ExchangeServerInSite')]
                PARAM(
                    [Parameter(Position=0,HelpMessage="Array of Server name strings to be filtered against[-Server 'SERVER1','SERVER2']")]
                        [string[]]$Server,
                    [Parameter(Position=1,HelpMessage="Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-SiteName 'SITENAME']")]
                        [Alias('Site')]
                        [string]$SiteName = (gv -name "$($TenOrg)_ADSiteDefaultName" -ea 0).Value,
                    [Parameter(Position=2,HelpMessage="Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']")]
                        [ValidateSet('MBX','CAS','HUB','UM','MBX','EDGE')]
                        [string[]]$RoleNames = @('HUB','CAS'),
                    [Parameter(HelpMessage="Array of msExchCurrentServerRoles 'role' integers to be filtered against (2|4|16|20|32|36|38|54|64|16385|16439)[-Roles @(38,16385)]")]
                        [ValidateSet(2,4,16,20,32,36,38,54,64,16385,16439)]
                        [int[]]$Roles,
                    [Parameter(HelpMessage="Switch to suppress default 'pingable' test (e.g. returns all matches, no testing)[-NoTest]")]
                        [Alias('NoPing')]
                        [switch]$NoTest,
                    [Parameter(HelpMessage="Milliseconds of max timeout to wait during port 80 test (defaults 100)[-SpeedThreshold 500]")]
                        [int]$SpeedThreshold=100,
                    [Parameter(Mandatory=$FALSE,HelpMessage="Tenant Tag (3-letter abbrebiation - defaults to global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']")]
                        [ValidateNotNullOrEmpty()]
                        [string]$TenOrg = $global:o365_TenOrgDefault,
                    [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials[-Credentials [credential object]]")]
                        [System.Management.Automation.PSCredential]$Credential
                ) ;
                BEGIN{
                    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
                    $Verbose = ($VerbosePreference -eq 'Continue') ;
                    $_sBnr="#*======v $(${CmdletName}): v======" ;
                    $smsg = $_sBnr ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
                PROCESS{
                    TRY{
                        $configNC = ([ADSI]"LDAP://RootDse").configurationNamingContext ;
                        $search = new-object DirectoryServices.DirectorySearcher([ADSI]"LDAP://$configNC") ;
                        $bLocalEdge = $false ; 
                        if($Sitename -eq $env:COMPUTERNAME){
                            $smsg = "`$SiteName -eq `$env:COMPUTERNAME:$($SiteName):$($env:COMPUTERNAME)" ; 
                            $smsg += "`nThis computer appears to be an EdgeRole system (non-ADConnected)" ; 
                            $smsg += "`n(Blanking `$sitename and continuing discovery)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            #$bLocalEdge = $true ; 
                            $SiteName = $null ; 
                        
                        } ; 
                        If($siteName){
                            $smsg = "WVGetting Site: $siteName" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            $objectClass = "objectClass=site" ;
                            $objectName = "name=$siteName" ;
                            $search.Filter = "(&($objectClass)($objectName))" ;
                            $site = ($search.Findall()) ;
                            $siteDN = ($site | select -expand properties).distinguishedname  ;
                        } else {
                            $smsg = "(No -Site specified, resolving site from local machine domain-connection...)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                            else{ write-host -foregroundcolor green "$($smsg)" } ;
                            TRY{$siteDN = [System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().GetDirectoryEntry().distinguishedName}
                            CATCH [System.Management.Automation.MethodInvocationException]{
                                $ErrTrapd=$Error[0] ;
                                if(($ErrTrapd.Exception -match 'The computer is not in a site.') -AND $env:ExchangeInstallPath){
                                    $smsg = "$($env:computername) is non-ADdomain-connected" ;
                                    $smsg += "`nand has `$env:ExchangeInstalled populated: Likely Edge Server" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                                    else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    $vers = (get-item "$($env:ExchangeInstallPath)\Bin\Setup.exe").VersionInfo.FileVersionRaw ; 
                                    $props = @{
                                        Name=$env:computername;
                                        FQDN = ([System.Net.Dns]::gethostentry($env:computername)).hostname;
                                        Version = "Version $($vers.major).$($vers.minor) (Build $($vers.Build).$($vers.Revision))" ; 
                                        #"$($vers.major).$($vers.minor)" ; 
                                        #$exServer.serialNumber[0];
                                        Roles = [System.Object[]]64 ;
                                        RoleNames = @('EDGE');
                                        DistinguishedName =  "CN=$($env:computername),CN=Servers,CN=Exchange Administrative Group (FYDIBOHF23SPDLT),CN=Administrative Groups,CN=First Organization,CN=Microsoft Exchange,CN=Services,CN=Configuration,CN={nnnnnnnn-FAKE-GUID-nnnn-nnnnnnnnnnnn}" ;
                                        Site = [System.Object[]]'NOSITE'
                                        ResponseTime = if($rsp){$rsp.ResponseTime} else { 0} ;
                                        NOTE = "This summary object, returned for a non-AD-connected EDGE server, *approximates* what would be returned on an AD-connected server" ;
                                    } ;
                                
                                    $smsg = "(-NoTest:Defaulting Fast:`$true)" ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                    $props.add('Fast',$true) ;
                                
                                    return (New-Object -TypeName PsObject -Property $props) ;
                                }elseif(-not $env:ExchangeInstallPath){
                                    $smsg = "Non-Domain Joined machine, with NO ExchangeInstallPath e-vari: `nExchange is not installed locally: local computer resolution fails:`nPlease specify an explicit -Server, or -SiteName" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    $false | write-output ;
                                } else {
                                    $smsg = "$($env:computername) is both NON-Domain-joined -AND lacks an Exchange install (NO ExchangeInstallPath e-vari)`nPlease specify an explicit -Server, or -SiteName" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    $false | write-output ;
                                };
                            } CATCH {
                                $siteDN =$ExOPsiteDN ;
                                write-warning "`$siteDN lookup FAILED, deferring to hardcoded `$ExOPsiteDN string in infra file!" ;
                            } ;
                        } ;
                        $smsg = "Getting Exservers in Site:$($siteDN)" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        $search = new-object DirectoryServices.DirectorySearcher([ADSI]"LDAP://$configNC") ;
                        $objectClass = "objectClass=msExchExchangeServer" ;
                        $version = "versionNumber>=1937801568" ;
                        $site = "msExchServerSite=$siteDN" ;
                        $search.Filter = "(&($objectClass)($version)($site))" ;
                        $search.PageSize = 1000 ;
                        [void] $search.PropertiesToLoad.Add("name") ;
                        [void] $search.PropertiesToLoad.Add("msexchcurrentserverroles") ;
                        [void] $search.PropertiesToLoad.Add("networkaddress") ;
                        [void] $search.PropertiesToLoad.Add("msExchServerSite") ;
                        [void] $search.PropertiesToLoad.Add("serialNumber") ;
                        [void] $search.PropertiesToLoad.Add("DistinguishedName") ;
                        $exchServers = $search.FindAll() ;
                        $Aggr = @() ;
                        foreach($exServer in $exchServers){
                            $fqdn = ($exServer.Properties.networkaddress |
                                Where-Object{$_ -match '^ncacn_ip_tcp:'}).split(':')[1] ;
                            if($NoTest){} else {
                                $rsp = test-connection $fqdn -count 1 -ea 0 ;
                            } ;
                            $props = @{
                                Name = $exServer.Properties.name[0]
                                FQDN=$fqdn;
                                Version = $exServer.Properties.serialnumber
                                Roles = $exserver.Properties.msexchcurrentserverroles
                                RoleNames = $null ;
                                DistinguishedName = $exserver.Properties.distinguishedname;
                                Site = @("$($exserver.Properties.msexchserversite -Replace '^CN=|,.*$')") ;
                                ResponseTime = if($rsp){$rsp.ResponseTime} else { 0} ;
                            } ;
                            $props.RoleNames = switch ($exserver.Properties.msexchcurrentserverroles){
                                2       {"MBX"}
                                4       {"CAS"}
                                16      {"UM"}
                                20      {"CAS;UM".split(';')}
                                32      {"HUB"}
                                36      {"CAS;HUB".split(';')}
                                38      {"CAS;HUB;MBX".split(';')}
                                54      {"MBX"}
                                64      {"EDGE"}
                                16385   {"CAS"}
                                16439   {"CAS;HUB;MBX".split(';')}
                            }
                            if($NoTest){
                                $smsg = "(-NoTest:Defaulting Fast:`$true)" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                $props.add('Fast',$true) ;
                            }else {
                                $props.add('Fast',[boolean]($rsp.ResponseTime -le $SpeedThreshold)) ;
                            };
                            $Aggr += New-Object -TypeName PsObject -Property $props ;
                        } ;
                        $httmp = @{} ;
                        if($Roles){
                            [regex]$rgxRoles = ('(' + (($roles |%{[regex]::escape($_)}) -join '|') + ')') ;
                            $matched =  @( $aggr | ?{$_.Roles -match $rgxRoles}) ;
                            foreach($m in $matched){
                                if($httmp[$m.name]){} else {
                                    $httmp[$m.name] = $m ;
                                } ;
                            } ;
                        } ;
                        if($RoleNames){
                            foreach ($RoleName in $RoleNames){
                                $matched = @($Aggr | ?{$_.RoleNames -contains $RoleName} ) ;
                                foreach($m in $matched){
                                    if($httmp[$m.name]){} else {
                                        $httmp[$m.name] = $m ;
                                    } ;
                                } ;
                            } ;
                        } ;
                        if($Server){
                            foreach ($Name in $Server){
                                $matched = @($Aggr | ?{$_.Name -eq $Name} ) ;
                                foreach($m in $matched){
                                    if($httmp[$m.name]){} else {
                                        $httmp[$m.name] = $m ;
                                    } ;
                                } ;
                            } ;
                        } ;
                        if(($httmp.Values| measure).count -gt 0){
                            $Aggr  = $httmp.Values ;
                        } ;
                        $smsg = "Returning $((($Aggr|measure).count|out-string).trim()) match summaries to pipeline..." ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        $Aggr | write-output ;
                    }CATCH{
                        Write-Error $_ ;
                    } ;
                } ;
                END{
                    $smsg = "$($_sBnr.replace('=v','=^').replace('v=','^='))" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
            } ;
        #} ; 
        #*------^ END Function get-ADExchangeServerTDO ^------ ;
        #endregion GADEXSERVERTDO ; #*------^ END GADEXSERVERTDO ^------

        if($isBased){
            $TenOrg = get-TenantTag -Credential $Credential ;
        } else { 

        } ; 
        <#
        if($Credential.username -match $rgxLegacyLogon){
            $credDom =$Credential.username.split('\')[0] ;
        } elseif ($Credential.username.contains('@')){
            $credDom = ($Credential.username.split("@"))[1] ;
        } else {
            write-warning "$((get-date).ToString('HH:mm:ss')):UNRECOGNIZED CREDENTIAL!:$($Credential.Username)`nUNABLE TO RESOLVE DEFAULT EX10SERVER FOR CONNECTION!" ;
        } ;
        #>
    } ;  # BEG-E
    PROCESS{
        if($isBased){
            $ExchangeServer=$null ;
            # flip from dyn lookup to array in Ex10Server, and always use get-random to pick between. Returns a value, even when only a single value
            $ExchangeServer = (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server|get-random ;
            $ExAdmin = (Get-Variable  -name "$($TenOrg)Meta").value.Ex10WebPoolVariant ;
            $ExVers = (Get-Variable  -name "$($TenOrg)Meta").value.ExRevision ;
            $ExVwForest = (Get-Variable  -name "$($TenOrg)Meta").value.ExViewForest ;
            $ExOPAccessFromToro = (Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro
            # force unresolved to dyn
            if(!$ExchangeServer){
                #$ExchangeServer = 'dynamic' ;
                # getting away from dyn, random from array in Ex10Server
                throw "Undefined `$ExchangeServer for $($TenOrg) org, and `$$($TenOrg)Meta.Ex10Server property" ;
                Exit ;
            } ;
            if($ExchangeServer -eq 'dynamic'){
                if( $ExchangeServer = (Get-ExchangeServerInSite | Where-Object { ($_.roles -eq 36) } | Get-Random ).FQDN){}
                else {
                    write-warning "$((get-date).ToString('HH:mm:ss')):Get-ExchangeServerInSite *FAILED*,`ndeferring to Get-ExchServerFromExServersGroup" ;
                    if(!($ExchangeServer = Get-ExchServerFromExServersGroup)){
                        write-warning "$((get-date).ToString('HH:mm:ss')):Get-ExchServerFromExServersGroup *FAILED*,`n deferring to profile `$smtpserver:$($smtpserver))"  ;
                        $ExchangeServer = $smtpserver ;
                    };
                } ;
            } ;

            write-host -foregroundcolor darkgray "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Adding EMS (connecting to $($ExchangeServer))..." ;
            # splat to open a session - # stock 'PSLanguageMode=Restricted' powershell IIS Webpool
            $pltNSess = @{ConnectionURI = "http://$ExchangeServer/powershell"; ConfigurationName = 'Microsoft.Exchange' ; name = "Exchange$($ExVers)" } ;
            if($env:USERDOMAIN -ne (Get-Variable  -name "$($TenOrg)Meta").value.legacyDomain){
                # if not in the $TenOrg legacy domain - running cross-org -  add auth:Kerberos
                <#suppresses: The WinRM client cannot process the request. It cannot determine the content type of the HTTP response f rom the destination computer. The content type is absent or invalid
                #>
                $pltNSess.add('Authentication','Kerberos') ;
            } ;
            if ($ExAdmin) {
              # use variant IIS Webpool
              $pltNSess.ConnectionURI = $pltNSess.ConnectionURI.replace("/powershell", "/$($sWebPoolVariant)") ;
            }
            if ($Credential) {
                 $pltNSess.Add("Credential", $Credential)
                 write-verbose "(using cred:$($credential.username))" ;
            } ;

            # -Authentication Basic only if specif needed: for Ex configured to connect via IP vs hostname)
            # try catch against and retry into stock if fails
            $error.clear() ;
            TRY {
                $Global:EXOPSess = New-PSSession @pltNSess -ea STOP  ;
            } CATCH {
                $ErrTrapd = $_ ;
                write-warning "$(get-date -format 'HH:mm:ss'): Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                #-=-record a STATUSWARN=-=-=-=-=-=-=
                $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                if(Get-Variable passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(Get-Variable -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
                #-=-=-=-=-=-=-=-=
                if ($ExAdmin) {
                    # switch to stock pool and retry
                    $pltNSess.ConnectionURI = $pltNSess.ConnectionURI.replace("/$($sWebPoolVariant)", "/powershell") ;
                    write-warning "$((get-date).ToString('HH:mm:ss')):FAILED TARGETING EXADMIN POOL`nRETRY W STOCK POOL: New-PSSession w`n$(($pltNSess|out-string).trim())" ;
                    $Global:EXOPSess = New-PSSession @pltNSess -ea STOP  ;
                } else {
                    BREAK ;
                } ;
            } ;

            write-verbose "$((get-date).ToString('HH:mm:ss')):Importing Exchange 2010 Module" ;
            #$pltIMod=@{Global=$true;PassThru=$true;DisableNameChecking=$true ; verbose=$false} ; # force verbose off, suppress spam in console
            # tear verbose out
            $pltIMod=@{Global=$true;PassThru=$true;DisableNameChecking=$true ;} ;
            #$pltISess = [ordered]@{Session = $Global:EXOPSess ; DisableNameChecking = $true  ; AllowClobber = $true ; ErrorAction = 'Stop' ; Verbose = $false ;} ;
            $pltISess = [ordered]@{Session = $Global:EXOPSess ; DisableNameChecking = $true  ; AllowClobber = $true ; ErrorAction = 'Stop' ; } ;
            if($CommandPrefix){
                $pltIMod.add('Prefix',$CommandPrefix) ;
                $pltISess.add('Prefix',$CommandPrefix) ;
            } ;
            $smsg = "$((get-date).ToString('HH:mm:ss')):Import-PSSession  w`n$(($pltISess|out-string).trim())`nImport-Module w`n$(($pltIMod|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $error.clear() ;
            TRY {
                # 9:57 AM 4/21/2021 coming through full verbose, suppress the pref
                if($VerbosePreference -eq "Continue"){
                    $VerbosePrefPrior = $VerbosePreference ;
                    $VerbosePreference = "SilentlyContinue" ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ;
                #$Global:E10Mod = Import-Module (Import-PSSession @pltISess) @pltIMod   ;
                # try 2-stopping (suppress verbose)
                $xIPS = Import-PSSession @pltISess ;
                $Global:E10Mod = Import-Module $xIPS @pltIMod ;
                if($ExVwForest){
                    write-host "Setting EMS Session: Set-AdServerSettings -ViewEntireForest `$True" ;
                    Set-AdServerSettings -ViewEntireForest $True ;
                } ;
                # reenable VerbosePreference:Continue, if set, during mod loads
                if($VerbosePrefPrior -eq "Continue"){
                    $VerbosePreference = $VerbosePrefPrior ;
                    $verbose = ($VerbosePreference -eq "Continue") ;
                } ;
            } CATCH {
                $ErrTrapd = $_ ;
                write-warning "$(get-date -format 'HH:mm:ss'): Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                #-=-record a STATUSERROR=-=-=-=-=-=-=
                $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                if(Get-Variable passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(Get-Variable -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
                #-=-=-=-=-=-=-=-=
            } ;
            # 7:54 AM 11/1/2017 add titlebar tag
            #Add-PSTitleBar 'EMS' ;
            # 1:31 PM 7/21/2021 build with TenOrg spec
            # 9:00 AM 7/27/2021 revise to support EMS[tlc] single-letter onprem conne designator (already in infra file OrgSvcs list).
            if($TenOrg){
                <# can't just use last char, lab varies from others
                if($TenOrg -ne 'TOL' ){
                    $sTitleBarTag = @("EMS$($TenOrg.substring(0,1).tolower())") ; # 1st char
                }else{
                    $sTitleBarTag = @("EMS$($TenOrg.substring(2,1).tolower())") ; # last char
                } ; 
                #>
                switch -regex ($TenOrg){
                    '^(CMW|TOR)$'{
                        $sTitleBarTag = @("EMS$($TenOrg.substring(0,1).tolower())") ; # 1st char
                    }
                    '^TOL$'{
                        $sTitleBarTag = @("EMS$($TenOrg.substring(2,1).tolower())") ; # last char
                    } ; 
                    default{
                        throw "$($TenOrg):unsupported `$TenOrg!" ; 
                        break ; 
                    }
                } ; 
            } else { 
                $sTitleBarTag = @("EMS") ;
            } ; 
            write-verbose "`$sTitleBarTag:$($sTitleBarTag)" ; 
        
            #$sTitleBarTag += $TenOrg ;
            Add-PSTitleBar $sTitleBarTag -verbose:$($VerbosePreference -eq "Continue")  ;
            # tag E10IsDehydrated
            $Global:E10IsDehydrated = $true ;
            write-host -foregroundcolor darkgray "`n$(($Global:EXOPSess | select ComputerName,Availability,State,ConfigurationName | format-table -auto |out-string).trim())" ;

        } else { 
            
            #region SERVICE_CONNECTIONS_DEPENDANCYLESS #*======v SERVICE_CONNECTIONS_DEPENDANCYLESS v======
            # DON'T RUN THIS AND THE USEXOP= BLOCK TOGETHER!
            # SIMPLE DEP-LESS VARIANT FOR EXOP-ONLY, NO DEPS ON VERB-*, OTHER THAN REQS: load-ADMs() & get-ADExchangeSErverTDO() (both should be local function includes)
            # PRETUNE STEERING separately *before* pasting in balance of region
            #*------v STEERING VARIS v------
            # CAN USE THIS BLOCK TO FORCE UPPER SERVICE_CONNECTIONS DRIVERS FALSE BEFORE USE HERE
            #$UseOP=$false ; 
            #$UseExOP=$false ;
            #$useForestWide = $false ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
            #$UseOPAD = $false ; 
            # ---
            $UseOPDYN=$true ; 
            $UseExOPDYN=$true ;
            $UseEXOPInSite=$true ;
            $useForestWideDYN = $false ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
            $UseOPADDYN = $true ; 
            $UseOPDYN = [boolean]($UseOPDYN -OR $UseExOPDYN -OR $UseOPADDYN) ;
            if($UseOPDYN -AND $UseOP){ write-warning "BOTH `$UseOPDYN -AND `$UseOP ARE TRUE!`nUSE ONE OR THE OTHER!" } ;
            if($UseExOPDYN -AND $UseExOP){ write-warning "BOTH `$UseExOPDYN -AND `$UseExOP ARE TRUE!`nUSE ONE OR THE OTHER!" } ;
            if($UseOPADDYN -AND $UseOPAD){ write-warning "BOTH `$UseOPADDYN -AND `$UseOPAD ARE TRUE!`nUSE ONE OR THE OTHER!" } ;
            if($useForestWideDYN -AND $useForestWide){ write-warning "BOTH `$useForestWideDYN -AND `$useForestWide ARE TRUE!`nUSE ONE OR THE OTHER!" } ;
            #*------^ END STEERING VARIS ^------
            #region GENERIC_EXOP_SRVR_CONN #*------v GENERIC_EXOP_SRVR_CONN BP v------
            if($UseOPDYN){
                #*------v GENERIC EXOP SRVR CONN BP v------
                # connect to ExOP 
                if($UseExOPDYN){
                    'get-ADExchangeSErverTDO','Connect-ExchangeServerTDO'  | foreach-object{
                        if(get-command $_ -ErrorAction STOP){} else { 
                            $smsg = "MISSING DEP FUNC:$($_)! must be either local include, or pre-loaded for EXOP connectivity to work!" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            throw $smsg ; 
                            break ; 
                        } ; 
                    } ; 
                    if($UseEXOPInSite){
                        TRY{
                            $Site=[System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name 
                        }CATCH{$Site=$env:COMPUTERNAME} ;
                        #$HubServers = get-ADExchangeSErverTDO -RoleNames 'HUB' -verbose
                        $PSSession = Connect-ExchangeServerTDO -siteName $Site -RoleNames @('HUB','CAS') -verbose ; 
                    }else{
                        $PSSession = Connect-ExchangeServerTDO -RoleNames @('HUB','CAS') -verbose ; 
                    } ; 
                    # from get-ADExchangeSErverTDO return 
                    #if([double]$ExVersNum = [regex]::match($ExOPServer.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value){
                    # from Connect-ExchangeServerTDO pssession return
                    if([double]$ExVersNum = [regex]::match($PsSession.applicationprivatedata.supportedversions,'(\d+\.\d+)\.(\d+\.\d+)').groups[1].value){
                        switch -regex ([string]$ExVersNum) {
                            '15.2' { $isEx2019 = $true ; $ExVers = 'Ex2019' }
                            '15.1' { $isEx2016 = $true ; $ExVers = 'Ex2016'}
                            '15.0' { $isEx2013 = $true ; $ExVers = 'Ex2013'}
                            '14.*' { $isEx2010 = $true ; $ExVers = 'Ex2010'}
                            '8.*' { $isEx2007 = $true ; $ExVers = 'Ex2007'}
                            '6.5' { $isEx2003 = $true ; $ExVers = 'Ex2003'}
                            '6' {$isEx2000 = $true ; $ExVers = 'Ex2000'} ;
                            default {
                                $smsg = "UNRECOGNIZED ExVersNum.Major.Minor string:$($ExVersNum)! ABORTING!" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                THROW $SMSG ;
                                BREAK ;
                            }
                        } ;
                        $smsg = "`$ExVersNum: $($PsSession.applicationprivatedata.supportedversions)`n$((gv isex*| %{"`n`$$($_.name): `$$($_.value)"}|out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    }else {
                        #$smsg = "UNABLE TO RESOLVE `$ExVersNum from `$ExOPServer.version:$($ExOPServer.version)!" ;
                        $smsg = "UNABLE TO RESOLVE `$ExVersNum from `$PsSession.applicationprivatedata.supportedversions:$($PsSession.applicationprivatedata.supportedversions)!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        throw $smsg ;
                        break ;
                    } ; 
                    TRY{
                        if(get-command -module (get-module |?{$_.name -like 'tmp_*'}).name -name 'get-OrganizationConfig' -ea SilentlyContinue){
                            if(-not ($OrgName = ((get-OrganizationConfig).DistinguishedName.split(',') |?{$_ -like 'DC=*'}) -join '.' -replace 'DC=','')){
                                $smsg = "Missing Exchange Connection! (no (Get-OrganizationConfig).name returned)" ; 
                                throw $smsg ; 
                                $smsg | write-warning  ; 
                            }else{
                                $smsg = "Connected to Orgname: $($OrgName)" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            } ; 
                        }else{
                            $smsg = "Missing 'tmp_*' module with 'get-OrganizationConfig'!" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        } ; 
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = $ErrTrapd ;
                        $smsg += "`n";
                        $smsg += $ErrTrapd.Exception.Message ;
                        if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        CONTINUE ;
                    } ;
                } ; 
                if($useForestWideDYN){
                    #region  ; #*------v USEFORESTWIDEDYN OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT v------
                    $smsg = "(`$useForestWideDYN:$($useForestWideDYN)):Enabling EXoP Forestwide)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = 'Set-AdServerSettings -ViewEntireForest `$True' ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Set-AdServerSettings -ViewEntireForest $True ;
                    #endregion  ; #*------^ END USEFORESTWIDEDYN OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT ^------
                } ;
            } else {
                $smsg = "(`$UseOPDYN:$($UseOPDYN))" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            }  ;  # if-E $UseOPDYN
            #endregion GENERIC_EXOP_SRVR_CONN #*------^ GENERIC_EXOP_SRVR_CONN BP ^------
            #region UseOPDYN #*------v UseOPDYN v------
            if($UseOPDYN -OR $UseOPADDYN){
                #region GENERIC_ADMS_CONN_&_XO #*------v GENERIC ADMS CONN & XO  v------
                if($UseOPADDYN){
                    'load-ADMs' | foreach-object{
                        if(get-command $_ -ErrorAction STOP){} else { 
                            $smsg = "MISSING DEP FUNC:$($_)! must be either local include, or pre-loaded for EXOP connectivity to work!" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            throw $smsg ; 
                            break ; 
                        } ; 
                    } ; 
                } ; 
                $smsg = "(loading ADMS...)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                # always capture load-adms return, it outputs a $true to pipeline on success
                $ADMTLoaded = load-ADMS -Verbose:$FALSE ;
                # 9:32 AM 4/20/2023 trimmed disabled/fw-borked cross-org code
                TRY {
                    if(-not(Get-ADDomain  -ea STOP).DNSRoot){
                        $smsg = "Missing AD Connection! (no (Get-ADDomain).DNSRoot returned)" ; 
                        throw $smsg ; 
                        $smsg | write-warning  ; 
                    } ; 
                    $objforest = get-adforest -ea STOP ; 
                    # Default new UPNSuffix to the UPNSuffix that matches last 2 elements of the forestname.
                    if($forestdom = $UPNSuffixDefault = $objforest.UPNSuffixes | ?{$_ -eq (($objforest.name.split('.'))[-2..-1] -join '.')}){

                    } elseif( $objforest.RootDomain -eq 'cmw.internal'){
                        # cmw doesn't use cmw.internal (forestname), as a UPN suffix, to try to match
                        # they have no default, tho' if we build up in the route, they'd have charlesmachineworks.com
                        $forestdom = $objforest.RootDomain; 
                        $UPNSuffixDefault = 'charlesmachine.works'
                    } else {
                         $smsg = "Unsupported `$objforest.RootDomain ($objforest.RootDomain), aborting!" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        throw $smsg ; 
                        break ; 
                    }
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = $ErrTrapd ;
                    $smsg += "`n";
                    $smsg += $ErrTrapd.Exception.Message ;
                    if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    CONTINUE ;
                } ;        
                #endregion GENERIC_ADMS_CONN_&_XO #*------^ END GENERIC ADMS CONN & XO ^------
            } else {
                $smsg = "(`$UseOPDYN:$($UseOPDYN))" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            }  ;
            #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
            #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller = get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
            # use new get-GCFastXO cross-org dc finde
            # default to Op_ExADRoot forest from $TenOrg Meta
            #if($UseOPDYN -AND -not $domaincontroller){
            if($UseOPDYN -AND -not (get-variable domaincontroller -ea 0)){
                #$domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((get-variable -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};
                # need to debug the above, credential issue?
                # just get it done
                #$domaincontroller = get-GCFast
                # AD – Return one GC in local site: (uses ADMS) Completely dynamic, no installed verb-xxx dependancies, 
                $domaincontroller = (Get-ADDomainController -Filter  {isGlobalCatalog -eq $true -AND Site -eq "$((get-adreplicationsite).name)"}).name| Get-Random ; 
            }  else { 
                # have to defer to get-azuread, or use EXO's native cmds to poll grp members
                # TODO 1/15/2021
                $useEXOforGroups = $true ; 
                $smsg = "$($TenOrg):HAS NO ON-PREM ACTIVEDIRECTORY, DEFERRING ALL GROUP ACCESS & MGMT TO NATIVE EXO CMDS!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
            if($useForestWideDYN -AND -not $GcFwide){
                #region GCFWIDE ; #*------v GCFWIDE OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT: v------
                $smsg = "`$GcFwide = Get-ADDomainController -Discover -Service GlobalCatalog" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $GcFwide = "$((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):3268" ;
                $smsg = "Discovered `$GcFwide:$($GcFwide)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #endregion GCFWIDE ; #*------^ END GCFWIDE OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT ^------
            } ;
            #endregion UseOPDYN #*------^ END UseOPDYN ^------
            #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
            #endregion SERVICE_CONNECTIONS_DEPENDANCYLESS #*======^ END SERVICE_CONNECTIONS_DEPENDANCYLESS ^======

        } ;  # if-E $isBased
    } ;  # PROC-E
    END {
        <# borked by psreadline v1/v2 breaking changes
        if(($PSFgColor = (Get-Variable  -name "$($TenOrg)Meta").value.PSFgColor) -AND ($PSBgColor = (Get-Variable  -name "$($TenOrg)Meta").value.PSBgColor)){
            write-verbose "(setting console colors:$($TenOrg)Meta.PSFgColor:$($PSFgColor),PSBgColor:$($PSBgColor))" ;
            $Host.UI.RawUI.BackgroundColor = $PSBgColor
            $Host.UI.RawUI.ForegroundColor = $PSFgColor ;
        } ;
        #>
    }
}

#*------^ Connect-Ex2010.ps1 ^------


#*------v Connect-Ex2010XO.ps1 v------
Function Connect-Ex2010XO {
    <#
    .SYNOPSIS
    Connect-Ex2010XO - Establish PSS to Ex2010, with multi-org support & validation
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-10-15
    FileName    :
    License     :
    Copyright   :
    Github      : https://github.com/tostka
    Tags        : Powershell,ExchangeOnline,Exchange,RemotePowershell,Connection,MFA
    AddedCredit : ExactMike Perficient
    AddedWebsite:	https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    AddedTwitter:
    AddedCredit2 : Jeremy Bradshaw
    AddedWebsite2:	https://github.com/JeremyTBradshaw
    AddedTwitter2:
    REVISIONS   :
    * 1:30 PM 9/5/2024 added  update-SecurityProtocolTDO() SB to begin
    # 3:18 PM 5/18/2021 somehow lost $credOpTORSID, so flipped lost default $credOPTor -> $credTORSID
    # 11:20 AM 4/21/2021 fixed/suppressed noisy verbose calls
    # 8:34 AM 3/31/2021 added verbose suppress to all import-mods; flipped import-psess & import-mod to splats (cleaner) ; line-wrapped longer post-filters for legib
    * 8:30 AM 10/22/2020 ren'd $TentantTag -> $TenOrg, swapped looping meta resolve with 1-liner approach ; added AcceptedDom caching to the middle status test (suppress one more get-exoaccepteddomain call if possible), replaced all $Meta.value with the $TenOrg version
    * 12:56 PM 10/15/2020 converted connect-exo to Ex2010, adding onprem validation
    .DESCRIPTION
    Connect-Ex2010XO - Establish PSS to Ex2010, with multi-org support & validation
    .PARAMETER  ExchangeServer
    On Prem Exch server to Remote to
    .PARAMETER  ExAdmin
    Use exadmin IIS WebPool for remote EMS[-ExAdmin]
    .PARAMETER  Credential
    Credential object
    .PARAMETER  showDebug
    Debugging Flag [-showDebug]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    Connect-Ex2010XO
    Connect using defaults, and leverage any pre-set $global:credo365TORSID variable
    .EXAMPLE
    connect-exo -CommandPrefix exo -credential (Get-Credential -credential s-todd.kadrie@torolab.com)  ;
    Connect an explicit credential, and use 'exolab' as the cmdlet prefix
    .EXAMPLE
    $cred = get-credential -credential $o365_Torolab_SIDUpn ;
    connect-exo -credential $cred ;
    Pass in a prefab credential object (useful for auto-shifting to MFA - the function will autoresolve MFA reqs based on the cred domain)
    .LINK
    .LINK
    https://github.com/verb-Exch2010
    #>
    [CmdletBinding()]
    [Alias('cxoxo')]
    Param(
        [Parameter(Position = 0, HelpMessage = "Exch server to Remote to")]
        [string]$ExchangeServer,
        [Parameter(HelpMessage = 'Use variant IIS WebPool for remote EMS[-ExAdmin]')]
        $ExAdmin,
        [Parameter(HelpMessage = 'Credential object')]
        [System.Management.Automation.PSCredential]$Credential = $credTORSID,
        [Parameter(HelpMessage = "Debugging Flag [-showDebug]")]
        [switch] $showDebug
    ) ;
    BEGIN{
        $verbose = ($VerbosePreference -eq "Continue") ;
        $CurrentVersionTlsLabel = [Net.ServicePointManager]::SecurityProtocol ; # Tls, Tls11, Tls12 ('Tls' == TLS1.0)  ;
        write-verbose "PRE: `$CurrentVersionTlsLabel : $($CurrentVersionTlsLabel )" ;
        # psv6+ already covers, test via the SslProtocol parameter presense
        if ('SslProtocol' -notin (Get-Command Invoke-RestMethod).Parameters.Keys) {
            $currentMaxTlsValue = [Math]::Max([Net.ServicePointManager]::SecurityProtocol.value__,[Net.SecurityProtocolType]::Tls.value__) ;
            write-verbose "`$currentMaxTlsValue : $($currentMaxTlsValue )" ;
            $newerTlsTypeEnums = [enum]::GetValues('Net.SecurityProtocolType') | Where-Object { $_ -gt $currentMaxTlsValue }
            if($newerTlsTypeEnums){
                write-verbose "Appending upgraded/missing TLS `$enums:`n$(($newerTlsTypeEnums -join ','|out-string).trim())" ;
            } else {
                write-verbose "Current TLS `$enums are up to date with max rev available on this machine" ;
            };
            $newerTlsTypeEnums | ForEach-Object {
                [Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor $_
            } ;
        } ;
        #if(!$rgxExoPsHostName){$rgxExoPsHostName="^(ps\.outlook\.com|outlook\.office365\.com)$" } ;
        # $rgxEx10HostName : ^(lyn|bcc|adl|spb)ms6[4,5][0,1].global.ad.toro.com$
        # we'd need to define all possible hostnames to cover potential span. Should probably build dynamically from $XXXMeta vari
        # can build from $TorMeta.OP_ExADRoot:global.ad.toro.com
        <# on curly, from Ps into EMS:
        get-pssession | fl computername,computertype,state,configurationname,availability,name
        ComputerName      : curlyhoward.cmw.internal
        ComputerType      : RemoteMachine
        State             : Opened
        ConfigurationName : Microsoft.Exchange
        Availability      : Available
        Name              : Session1

        ComputerName      : lynms650.global.ad.toro.com
        ComputerType      : RemoteMachine
        State             : Broken
        ConfigurationName : Microsoft.Exchange
        Availability      : None
        Name              : Exchange2010

        "^\w*\.$($CMWMeta.OP_ExADRoot)$"
        => ^\w*\.cmw.internal$
        #>

        #$sTitleBarTag = "EMS" ;
        $CommandPrefix = $null ;

        $TenOrg=get-TenantTag -Credential $Credential ;
        <#if($TenOrg -ne 'TOR'){
            # explicitly leave this tenant (default) untagged
            $sTitleBarTag += $TenOrg ;
        } ;
        #>
        if($TenOrg){
            switch -regex ($TenOrg){
                '^(CMW|TOR)$'{
                    $sTitleBarTag = @("EMS$($TenOrg.substring(0,1).tolower())") ; # 1st char
                }
                '^TOL$'{
                    $sTitleBarTag = @("EMS$($TenOrg.substring(2,1).tolower())") ; # last char
                } ;
                default{
                    throw "$($TenOrg):unsupported `$TenOrg!" ;
                    break ;
                }
            } ;
        } else {
            $sTitleBarTag = @("EMS") ;
        } ;
        write-verbose "`$sTitleBarTag:$($sTitleBarTag)" ; 

        <#
        $credDom = ($Credential.username.split("\"))[0] ;
        $Metas=(get-variable *meta|Where-Object{$_.name -match '^\w{3}Meta$'}) ;
        foreach ($Meta in $Metas){
            if( ($credDom -eq $Meta.value.legacyDomain) -OR ($credDom -eq $Meta.value.o365_TenantDomain) -OR ($credDom -eq $Meta.value.o365_OPDomain)){
                if($Meta.value.OP_ExADRoot){
                    if(!$Meta.value.OP_rgxEMSComputerName){
                        write-verbose "(adding XXXMeta.OP_rgxEMSComputerName value)"
                        # build vari that will match curlyhoward.cmw.internal|lynms650.global.ad.toro.com etc
                        set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'OP_rgxEMSComputerName' = "^\w*\.$([Regex]::Escape($Meta.value.OP_ExADRoot))$"} ) ;
                    } ;
                } else {
                    throw "Missing `$$($Meta.value.o365_Prefix).OP_ExADRoot value.`nProfile hasn't loaded proper tor-incl-infrastrings file)!"
                } ;
            } ; # if-E $credDom
        } ; # loop-E
        #>
        # non-looping vers:
        #$TenOrg = get-TenantTag -Credential $Credential ;
        #.OP_ExADRoot
        if( (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName ){

        } else {
            #.OP_rgxEMSComputerName
            if((Get-Variable  -name "$($TenOrg)Meta").value.OP_ExADRoot){
                set-Variable  -name "$($TenOrg)Meta" -value ( (Get-Variable  -name "$($TenOrg)Meta").value += @{'OP_rgxEMSComputerName' = "^\w*\.$([Regex]::Escape((Get-Variable  -name "$($TenOrg)Meta").value.OP_ExADRoot))$"} )
            } else {
                $smsg = "Missing `$$((Get-Variable  -name "$($TenOrg)Meta").value.o365_Prefix).OP_ExADRoot value.`nProfile hasn't loaded proper tor-incl-infrastrings file)!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } ;

    } ;  # BEG-E
    PROCESS{
        # if we're using ems-style BasicAuth, clear incompatible existing Rems PSS's
        # ComputerName      : curlyhoward.cmw.internal ;  ComputerType      : RemoteMachine ;  State             : Opened ;  ConfigurationName : Microsoft.Exchange ;  Availability      : Available ;  Name              : Session1 ;   ;
        $rgxRemsPSSName = "^(Session\d|Exchange\d{4})$" ;
        $Rems2Good = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND ($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName) -AND ($_.Availability -eq 'Available') } ;
        # Computername wrong fqdn suffix
        #$Rems2WrongOrg = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND (-not($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName)) -AND ($_.Availability -eq 'Available') } ;
        # above is seeing outlook EXO conns as wrong org, exempt them too: .ComputerName -match $rgxExoPsHostName
        $Rems2WrongOrg = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND (
            $_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND (
            ( -not($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName) ) -AND (
            -not($_.ComputerName -match $rgxExoPsHostName)) ) -AND ($_.Availability -eq 'Available')
        } ;
        $Rems2Broken = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND (
            $_.Name -match $rgxRemsPSSName) -AND ($_.State -like "*Broken*") } ;
        $Rems2Closed = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND (
            $_.Name -match $rgxRemsPSSName) -AND ($_.State -like "*Closed*") } ;

        if ($Rems2Broken.count -gt 0){ for ($index = 0 ;$index -lt $Rems2Broken.count ;$index++){Remove-PSSession -session $Rems2Broken[$index]}  };
        if ($Rems2Closed.count -gt 0){for ($index = 0 ;$index -lt $Rems2Closed.count ; $index++){Remove-PSSession -session $Rems2Closed[$index] } } ;
        if ($Rems2WrongOrg.count -gt 0){for ($index = 0 ;$index -lt $Rems2WrongOrg.count ; $index++){Remove-PSSession -session $Rems2WrongOrg[$index] } } ;
        # preclear until proven *up*
        $bExistingREms = $false ;

        if( Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND ($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName) -AND ($_.Availability -eq 'Available') } ){
            $bExistingREms= $true ;

        } ;
        if($bExistingREms -eq $false){
            #$TorMeta.Ex10Server: dynamic
            #$TorMeta.Ex10ServerXO: lynms650.global.ad.toro.com
            # force unresolved to dyn
            if((Get-Variable  -name "$($TenOrg)Meta").value.Ex10ServerXO){
                write-host -foregroundcolor darkgray "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Adding EMS (connecting to $($TorMeta.Ex10ServerXO))..." ;
            } ;

            $pltNSess = @{
                ConnectionURI = "http://$((Get-Variable  -name "$($TenOrg)Meta").value.Ex10ServerXO)/powershell";
                ConfigurationName = 'Microsoft.Exchange' ;
                name = 'Exchange2010' ;
            } ;
            if ((Get-Variable  -name "$($TenOrg)Meta").value.Ex10WebPoolVariant) {
              # use variant IIS Webpool
              $pltNSess.ConnectionURI = $pltNSess.ConnectionURI.replace("/powershell", "/$((Get-Variable  -name "$($TenOrg)Meta").value.Ex10WebPoolVariant)") ;
            }
            $pltNSess.Add("Credential", $Credential); # just use the passed $Credential vari
            $cMsg = "Connecting to OP Ex20XX ($($credDom))";
            Write-Host $cMsg ;
            write-verbose "`n$((get-date).ToString('HH:mm:ss')):New-PSSession w`n$(($pltNSess|out-string).trim())" ;

            $error.clear() ;
            TRY { $global:E10Sess = New-PSSession @pltNSess -ea STOP
            } CATCH {
                $ErrTrapd = $_ ;
                write-warning "$(get-date -format 'HH:mm:ss'): Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                if ((Get-Variable  -name "$($TenOrg)Meta").value.Ex10WebPoolVariant) {
                  # switch to stock pool and retry
                  $pltNSess.ConnectionURI = $pltNSess.ConnectionURI.replace("/$((Get-Variable  -name "$($TenOrg)Meta").value.Ex10WebPoolVariant)", "/powershell") ;
                  write-warning "$((get-date).ToString('HH:mm:ss')):FAILED TARGETING VARIANT POOL`nRETRY W STOCK POOL: New-PSSession w`n$(($pltNSess|out-string).trim())" ;
                  $global:E10Sess = New-PSSession @pltNSess -ea STOP  ;
                } else {
                    STOP ;
                } ;
            } ; # try-E

            if(!$global:E10Sess){
                write-warning "$((get-date).ToString('HH:mm:ss')):FAILED TO RETURN PSSESSION!`nAUTH FAIL BAD PASSWORD? ABORTING TO AVOID LOCKOUT!" ;
                throw "$((get-date).ToString('HH:mm:ss')):AUTH FAIL BAD PASSWORD? ABORTING TO AVOID LOCKOUT!" ;
                Break ;
            } ;

            $pltIMod=@{Global = $true ;PassThru = $true;DisableNameChecking = $true ; verbose=$true ;} ;
            $pltISess = [ordered]@{
                Session             = $global:E10Sess ;
                DisableNameChecking = $true  ;
                AllowClobber        = $true ;
                ErrorAction         = 'Stop' ;
                Verbose             = $false ;
            } ;
            if ($CommandPrefix) {
                write-host -foregroundcolor white "$((get-date).ToString("HH:mm:ss")):Note: Prefixing this Mod's Cmdlets as [verb]-$($CommandPrefix)[noun]" ;
                $pltIMod.add('Prefix',$CommandPrefix) ;
                $pltISess.add('Prefix',$CommandPrefix) ;
            } ;
            write-verbose "`n$((get-date).ToString('HH:mm:ss')):Import-PSSession w`n$(($pltISess|out-string).trim())`nImport-Module w`n$(($pltIMod|out-string).trim())" ;

            # Verbose:Continue is VERY noisey for module loads. Bracketed suppress:
            if($VerbosePreference = "Continue"){
                $VerbosePrefPrior = $VerbosePreference ;
                $VerbosePreference = "SilentlyContinue" ;
                $verbose = ($VerbosePreference -eq "Continue") ;
            } ;
            Try {
                $Global:E10Mod = Import-Module (Import-PSSession @pltISess) @pltIMod  ;
                #$Global:EOLModule = Import-Module (Import-PSSession @pltISess) -Global -Prefix $CommandPrefix -PassThru -DisableNameChecking   ;
            } catch {
                Write-Warning -Message "Tried but failed to import the EXO PS module.`n`nError message:" ;
                throw $_ ;
            } ;
            # reenable VerbosePreference:Continue, if set, during mod loads
            if($VerbosePrefPrior -eq "Continue"){
                $VerbosePreference = $VerbosePrefPrior ;
                $verbose = ($VerbosePreference -eq "Continue") ;
            } ;
            Add-PSTitleBar $sTitleBarTag -verbose:$($VerbosePreference -eq "Continue")  ;

        } ; #  # if-E $bExistingREms
    } ;  # PROC-E
    END {
        if($bExistingREms -eq $false){
            if( Get-PSSession | where-object {$_.ConfigurationName -eq "Microsoft.Exchange" -AND $_.Name -match $rgxRemsPSSName -AND $_.State -eq "Opened" -AND ($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName) -AND ($_.Availability -eq 'Available') }  ){
                $bExistingREms= $true ;
            } else {
                write-error "(Credential mismatch:disconnecting from existing Ex201X:$($eEXO.Identity) tenant)" ;
                Disconnect-Ex2010 ;
                $bExistingREms = $false ;
            } ;
        } ;
    } ; # END-E
}

#*------^ Connect-Ex2010XO.ps1 ^------


#*------v Connect-ExchangeServerTDO.ps1 v------
Function Connect-ExchangeServerTDO {
        <#
        .SYNOPSIS
        Connect-ExchangeServerTDO.ps1 - Dependancy-less Function that, fed an Exchange server name, or AD SiteName, and optional RoleNames array, 
        will obtain a list of Exchange servers from AD (in the specified scope), and then run the list attempting to PowershellREmote (REMS) connect to each server, 
        stopping at the first successful connection.
        .NOTES
        REVISIONS
        * 3:58 PM 5/14/2025 restored prior dropped earlier rev history (routinely trim for psparamt inclu)
        * 10;07 am 4/30/2025 fixed borked edge conn, typo, and rev logic for Ex & role detection in raw PS - lacks evaris for exchange (EMS/REMS only), so leverage reg & stock install loc hunting to discover setup.exe for vers & role confirm).
        * 2:46 PM 4/22/2025 add: -Version (default to Ex2010), and postfiltered returned ExchangeServers on version. If no -Version, sort on newest Version, then name, -descending.
        * 4:25 PM 1/15/2025 seems to work at this point, move to rebuild
        * 4:49 PM 1/9/2025 reworked connect-exchangeserverTdo() to actually use the credentials passed in, and 
        added the missing import-module $PSS, to _connect-ExOP, to make the session actually functional 
        for running cmds, wo popping cred prompts. 
        * 12:24 PM 12/4/2024 removed bracket bnr echos around _connect-ExOP
        * 3:54 PM 11/26/2024 integrated back TLS fixes, and ExVersNum flip from June; syncd dbg & vx10 copies.
        * 12:57 PM 6/11/2024 Validated, Ex2010 & Ex2019, hub, mail & edge roles: tested ☑️ on CMW mail role (Curly); and Jumpbox; 
        copied in CBH from repo copy, which has been updated/debugged compat on CMW Edge 
        includes local snapin detect & load for edge role (simplest EMS load option for Edge role, from David Paulson's original code; no longer published with Ex2010 compat)
        * 1:30 PM 9/5/2024 added  update-SecurityProtocolTDO() SB to begin
        * 12:49 PM 6/21/2024 flipped PSS Name to Exchange$($ExchVers[dd])
        * 11:28 AM 5/30/2024 fixed failure to recognize existing functional PSSession; Made substantial update in logic, validate works fine with other orgs, and in our local orgs.
        * 4:02 PM 8/28/2023 debuged, updated CBH, renamed connect-ExchangeSErver -> Connect-ExchangeServerTDO (avoid name clashes, pretty common verb-noun combo).
        * 12:36 PM 8/24/2023 init
         .PARAMETER name
        FQDN of a specific Exchange server[-Name EXSERVER.DOMAIN.COM]
        .PARAMETER discover
        Boolean paraameter that drives auto-discovery of target Exchange servers for connection (defaults `$true)[-discover:`$false]
        .PARAMETER credential
        Use specific Credentials[-Credentials [credential object]
            .PARAMETER Site
        Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-Site 'SITENAME']
        .PARAMETER RoleNames
        Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']
        .PARAMETER Version
        Specific Exchange Server Version to connect to('Ex2019|Ex2016|Ex2013|Ex2010|Ex2007|Ex2003|Ex2000')[-Version 'Ex2016']
        .PARAMETER TenOrg
        Tenant Tag (3-letter abbrebiation - defaults to variable `$global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']
        .INPUTS
        None. Does not accepted piped input.(.NET types, can add description)
        .OUTPUTS
        [system.object] Returns a system object containing a successful PSSession
        System.Boolean
        .EXAMPLE
        PS> $PSSession = Connect-ExchangeServerTDO -siteName SITENAME -RoleNames @('HUB','CAS') -verbose 
        Demo's connecting to a functional Hub or CAS server in the SITENAME site with verbose outputs, the `PSSession variable will contain information about the successful connection. Makes automatic Exchangeserver discovery calls into AD (using ADSI) leveraging the separate get-ADExchangeServerTDO()
        .EXAMPLE
        PS> TRY{$Site=[System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name}CATCH{$Site=$env:COMPUTERNAME} ;
        PS> $PSSession = Connect-ExchangeServerTDO -siteName $Site -RoleNames @('HUB','CAS') -verbose ; 
        Demo including support for EdgeRole, which is detected on it's lack of AD Site specification (which gets fed through to call, by setting the Site to the machine itself).
        .EXAMPLE
        PS> $PSSession = Connect-ExchangeServerTDO -siteName SITENAME -RoleNames @('HUB','CAS') -Version Ex2016 -verbose 
        Demo's connecting to a functional Hub or CAS server Version Ex2016 in the SITENAME site with verbose outputs, the `PSSession variable will contain information about the successful connection. Makes automatic Exchangeserver discovery calls into AD (using ADSI) leveraging the separate get-ADExchangeServerTDO()
        #>        
        [CmdletBinding(DefaultParameterSetName='discover')]
        PARAM(
            [Parameter(Position=0,Mandatory=$true,ParameterSetName='name',HelpMessage="FQDN of a specific Exchange server[-Name EXSERVER.DOMAIN.COM]")]
                [String]$name,
            [Parameter(Position=0,ParameterSetName='discover',HelpMessage="Boolean paraameter that drives auto-discovery of target Exchange servers for connection (defaults `$true)[-discover:`$false]")]
                [bool]$discover=$true,
            [Parameter(Position=1,HelpMessage = "Use specific Credentials[-Credentials [credential object]")]
                [Management.Automation.PSCredential]$credential,
            [Parameter(Position=1,HelpMessage="Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-Site 'SITENAME']")]
                [Alias('Site')]
                [string]$SiteName = (gv -name "$($TenOrg)_ADSiteDefaultName" -ea 0).Value,
            [Parameter(Position=2,HelpMessage="Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']")]
                [ValidateSet('MBX','CAS','HUB','UM','MBX','EDGE')]
                [string[]]$RoleNames = @('HUB','CAS'),
            [Parameter(Position=2,HelpMessage="Specific Exchange Server Version to connect to('Ex2019|Ex2016|Ex2013|Ex2010|Ex2007|Ex2003|Ex2000')[-Version 'Ex2016']")]
                [ValidateSet('Ex2019','Ex2016','Ex2013','Ex2010','Ex2007','Ex2003','Ex2000')]
                [string[]]$Version = 'Ex2010',
            [Parameter(Mandatory=$FALSE,HelpMessage="Tenant Tag (3-letter abbrebiation - defaults to global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']")]
                [ValidateNotNullOrEmpty()]
                [string]$TenOrg = $global:o365_TenOrgDefault
        ) ;
        BEGIN{
            $Verbose = ($VerbosePreference -eq 'Continue') ;
            $CurrentVersionTlsLabel = [Net.ServicePointManager]::SecurityProtocol ; # Tls, Tls11, Tls12 ('Tls' == TLS1.0)  ;
      write-verbose "PRE: `$CurrentVersionTlsLabel : $($CurrentVersionTlsLabel )" ;
      # psv6+ already covers, test via the SslProtocol parameter presense
      if ('SslProtocol' -notin (Get-Command Invoke-RestMethod).Parameters.Keys) {
        $currentMaxTlsValue = [Math]::Max([Net.ServicePointManager]::SecurityProtocol.value__,[Net.SecurityProtocolType]::Tls.value__) ;
        write-verbose "`$currentMaxTlsValue : $($currentMaxTlsValue )" ;
        $newerTlsTypeEnums = [enum]::GetValues('Net.SecurityProtocolType') | Where-Object { $_ -gt $currentMaxTlsValue }
        if($newerTlsTypeEnums){
          write-verbose "Appending upgraded/missing TLS `$enums:`n$(($newerTlsTypeEnums -join ','|out-string).trim())" ;
        } else {
          write-verbose "Current TLS `$enums are up to date with max rev available on this machine" ;
        };
        $newerTlsTypeEnums | ForEach-Object {
          [Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor $_
        } ;
      } ;
    
            # 5:15 PM 4/22/2025 on CMW, have to patch version to Ex2016

            #*------v Function _connect-ExOP v------
            function _connect-ExOP{
                    [CmdletBinding()]
                    PARAM(
                        [Parameter(Position=0,Mandatory=$true,HelpMessage="Exchange server AD Summary system object[-Server EXSERVER.DOMAIN.COM]")]
                            [system.object]$Server,
                        [Parameter(Position=1,HelpMessage = "Use specific Credentials[-Credentials [credential object]")]
                            [Management.Automation.PSCredential]$credential
                    );
                    $verbose = $($VerbosePreference -eq "Continue") ;
                    if([double]$ExVersNum = [regex]::match($Server.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value){
                        switch -regex ([string]$ExVersNum) {
                            '15.2' { $isEx2019 = $true ; $ExVers = 'Ex2019' }
                            '15.1' { $isEx2016 = $true ; $ExVers = 'Ex2016'}
                            '15.0' { $isEx2013 = $true ; $ExVers = 'Ex2013'}
                            '14.*' { $isEx2010 = $true ; $ExVers = 'Ex2010'}
                            '8.*' { $isEx2007 = $true ; $ExVers = 'Ex2007'}
                            '6.5' { $isEx2003 = $true ; $ExVers = 'Ex2003'}
                            '6' {$isEx2000 = $true ; $ExVers = 'Ex2000'} ;
                            default {
                                $smsg = "UNRECOGNIZED ExVersNum.Major.Minor string:$($ExVersNum)! ABORTING!" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                THROW $SMSG ;
                                BREAK ;
                            }
                        } ;
                    }else {
                        $smsg = "UNABLE TO RESOLVE `$ExVersNum from `$Server.version:$($Server.version)!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        throw $smsg ;
                        break ;
                    } ;
                    if($Server.RoleNames -eq 'EDGE'){
                        if(($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup')) -or
                            ($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup')) -or
                            $ByPassLocalExchangeServerTest)
                        {
                            if((Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\EdgeTransportRole') -or
                                    (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\EdgeTransportRole'))
                            {
                                $smsg = "We are on Exchange Edge Transport Server"
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                $IsEdgeTransport = $true
                            }
                            TRY {
                                Get-ExchangeServer -ErrorAction Stop | Out-Null
                                $smsg = "Exchange PowerShell Module already loaded."
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                $passed = $true 
                            }CATCH {
                                $smsg = "Failed to run Get-ExchangeServer"
                                if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                if($isLocalExchangeServer){
                                    write-host  "Loading Exchange PowerShell Module..."
                                    TRY{
                                        if($IsEdgeTransport){
                                            # implement local snapins access on edge role: Only way to get access to EMS commands.
                                            [xml]$PSSnapIns = Get-Content -Path "$env:ExchangeInstallPath\Bin\exshell.psc1" -ErrorAction Stop
                                            ForEach($PSSnapIn in $PSSnapIns.PSConsoleFile.PSSnapIns.PSSnapIn){
                                                write-verbose ("Trying to add PSSnapIn: {0}" -f $PSSnapIn.Name)
                                                Add-PSSnapin -Name $PSSnapIn.Name -ErrorAction Stop
                                            } ; 
                                            Import-Module $env:ExchangeInstallPath\bin\Exchange.ps1 -ErrorAction Stop ; 
                                            $passed = $true #We are just going to assume this passed.
                                        }else{
                                            Import-Module $env:ExchangeInstallPath\bin\RemoteExchange.ps1 -ErrorAction Stop
                                            Connect-ExchangeServer -Auto -ClientApplication:ManagementShell
                                            $passed = $true #We are just going to assume this passed.
                                        } 
                                    }CATCH {
                                        $smsg = "Failed to Load Exchange PowerShell Module..." ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                    }                               
                                } ;
                            } FINALLY {
                                if($LoadExchangeVariables -and $passed -and $isLocalExchangeServer){
                                    if($ExInstall -eq $null -or $ExBin -eq $null){
                                        if(Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup'){
                                            $Global:ExInstall = (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup).MsiInstallPath
                                        }else{
                                            $Global:ExInstall = (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup).MsiInstallPath
                                        }

                                        $Global:ExBin = $Global:ExInstall + "\Bin"

                                        $smsg = ("Set ExInstall: {0}" -f $Global:ExInstall)
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                        $smsg = ("Set ExBin: {0}" -f $Global:ExBin)
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                    } ; 
                                } ; 
                            } ; 
                        } else  {
                            $smsg = "Does not appear to be an Exchange 2010 or newer server." ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                        }
                        if(get-command -Name Get-OrganizationConfig -ea 0){
                            $smsg = "Running in connected/Native EMS" ; 
                            if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            Return $true ; 
                        } else { 
                            TRY{
                                $smsg = "Initiating Edge EMS local session (exshell.psc1 & exchange.ps1)" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                # 5;36 PM 5/30/2024 didn't work, went off to nowhere for a long time, and exited the script
                                #& (gcm powershell.exe).path -PSConsoleFile "$($env:ExchangeInstallPath)bin\exshell.psc1" -noexit -command ". '$($env:ExchangeInstallPath)bin\Exchange.ps1'"
                                <# [Adding the Transport Server to Exchange - Mark Lewis Blog](https://marklewis.blog/2020/11/19/adding-the-transport-server-to-exchange/)
                                To access the management console on the transport server, I opened PowerShell then ran
                                exshell.psc1
                                Followed by
                                exchange.ps1
                                At this point, I was able to create a new subscription using he following PowerShel
                                #>
                                invoke-command exshell.psc1 ; 
                                invoke-command exchange.ps1
                                if(get-command -Name Get-OrganizationConfig -ea 0){
                                    $smsg = "Running in connected/Native EMS" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                    Return $true ;
                                } else { return $false };  
                            }CATCH{
                                Write-Error $_ ;
                            } ;
                        } ; 
                    } else {
                        $pltNPSS=@{ConnectionURI="http://$($Server.FQDN)/powershell"; ConfigurationName='Microsoft.Exchange' ; name="Exchange$($ExVersNum.tostring())"} ;
                        $pltIMod=@{Global=$true;PassThru=$true;DisableNameChecking=$true ;} ;
                        # use ExVersUnm dd instead of hardcoded (Exchange2010)
                        if($ExVersNum -ge 15){
                            $smsg = "EXOP.15+:Adding -Authentication Kerberos" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            $pltNPSS.add('Authentication',"Kerberos") ;
                            $pltNPSS.name = $ExVers ;
                        } ;
                        $smsg = "Adding EMS (connecting to $($Server.FQDN))..." ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        $smsg = "New-PSSession w`n$(($pltNPSS|out-string).trim())" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        $ExPSS = New-PSSession @pltNPSS  ;
                        $ExIPSS = Import-PSSession $ExPSS -allowclobber ;
                        # 3:59 PM 1/9/2025 appears credprompting is due to it's missing the import-module $ExIPSS ! 
                        $smsg = "Import-Module w`n$(($pltIMod|out-string).trim())" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        $Global:E10Mod = Import-Module $ExIPSS @pltIMod ;
                        $ExPSS | write-output ;
                        $ExPSS= $ExIPSS = $null ;
                    } ; 
                } ;
            #*------^ END Function _connect-ExOP ^------
            $pltGADX=@{
                ErrorAction='Stop';
            } ;
        } ;
        PROCESS{
            if($PSBoundParameters.ContainsKey('credential')){
                $pltGADX.Add('credential',$credential) ;
            }
            if($SiteName){
                $pltGADX.Add('siteName',$siteName) ;
            } ;
            if($RoleNames){
                $pltGADX.Add('RoleNames',$RoleNames) ;
            } ;
            TRY{
                if($discover){
                    $smsg = "Getting list of Exchange Servers" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                    $exchServers=get-ADExchangeServerTDO @pltGADX | sort responsetime ;
                }else{
                    $exchServers=get-ADExchangeServerTDO @pltGADX | sort responsetime ;
                } ;
                $pltTW=@{
                    'ErrorAction'='Stop';
                } ;
                $pltCXOP = @{
                    verbose = $($VerbosePreference -eq "Continue") ;
                } ;
                if($pltGADX.credential){
                    $pltCXOP.Add('Credential',$pltGADX.credential) ;
                } ;
                if($Version){
                    switch ($Version){
                      'Ex2000'{$rgxExVersNum = '6' } 
                      'Ex2003'{$rgxExVersNum = '6.5' } 
                      'Ex2007'{$rgxExVersNum = '8.*' } 
                      'Ex2010'{$rgxExVersNum = '14.*'} 
                      'Ex2013'{$rgxExVersNum = '15.0' } 
                      'Ex2016'{$rgxExVersNum = '15.1'} 
                      'Ex2019'{$rgxExVersNum = '15.2' } 
                    } ; 
                    $exchServers  = $exchServers | ?{ [double]([regex]::match( $_.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value) -match $rgxExVersNum } ; 

                } else {
                    write-verbose "no -Version: Sorting Newest first, then names, descending" ; 
                    $exchServers  = $exchServers | sort version,name -desc
                } ; 
                $prpPSS = 'Id','Name','ComputerName','ComputerType','State','ConfigurationName','Availability' ; 
                foreach($exServer in $exchServers){
                    $smsg = "testing conn to:$($exServer.name.tostring())..." ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    if(get-command -module (get-module |?{$_.name -like 'tmp_*'}).name -name 'get-OrganizationConfig' -ea SilentlyContinue){
                        if($pssEXOP = Get-PSSession |  where-object { ($_.ConfigurationName -eq 'Microsoft.Exchange') -AND ( $_.runspace.ConnectionInfo.AppName -match '^/(exadmin|powershell)$') -AND ( $_.runspace.ConnectionInfo.Port -eq '80') }){
                            if($pssEXOP.State -ne "Opened" -OR $pssEXOP.Availability -ne "Available"){
                                $pssEXOP | remove-pssession ; $pssEXOP = $null ;
                            } ;
                        } ; 
                    } else {
                        $smsg = "(mangled ExOP conn: disconnect/reconnect...)" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        if($pssEXOP = Get-PSSession |  where-object { ($_.ConfigurationName -eq 'Microsoft.Exchange') -AND ( $_.runspace.ConnectionInfo.AppName -match '^/(exadmin|powershell)$') -AND ( $_.runspace.ConnectionInfo.Port -eq '80') }){
                            if($pssEXOP.State -ne "Opened" -OR $pssEXOP.Availability -ne "Available"){
                                $pssEXOP | remove-pssession ; $pssEXOP = $null ;
                            } ;
                        } ; 
                    } ;
                    if(-not $pssEXOP){
                        $smsg = "Connecting to: $($exServer.FQDN)" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        $smsg = "_connect-ExOP w`n$(($pltCXOP|out-string).trim())" ;
                        $smsg += "`nServer $($exServer.FQDN)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        if($NoTest){
                            $ExPSS =$ExPSS = _connect-ExOP @pltCXOP -Server $exServer
                        } else {
                            TRY{
                                $smsg = "Testing Connection: $($exServer.FQDN)" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                If(test-connection $exServer.FQDN -count 1 -ea 0) {
                                    $smsg = "confirmed pingable..." ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                } else {
                                    $smsg = "Unable to Ping $($exServer.FQDN)" ; ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                } ;
                                $smsg = "Testing WinRm: $($exServer.FQDN)" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                $winrm=Test-WSMan @pltTW -ComputerName $exServer.FQDN ;
                                if($winrm){
                                    $ExPSS = _connect-ExOP @pltCXOP -Server $exServer;
                                } else {
                                    $smsg = "Unable to Test-WSMan $($exServer.FQDN) (skipping)" ; ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                } ;
                            }CATCH{
                                $errMsg="Server: $($exServer.FQDN)] $($_.Exception.Message)" ;
                                Write-Error -Message $errMsg ;
                                continue ;
                            } ;
                        };
                    } else {
                        $smsg = "$((get-date).ToString('HH:mm:ss')):Accepting first valid connection w`n$(($pssEXOP | ft -a $prpPSS|out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $ExPSS = $pssEXOP ; 
                        break ; 
                    }  ;
                } ;
            }CATCH{
                Write-Error $_ ;
            } ;
        } ;
        END{
            if(-not $ExPSS){
                $smsg = "NO SUCCESSFUL CONNECTION WAS MADE, WITH THE SPECIFIED INPUTS!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $smsg = "(returning `$false to the pipeline...)" ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                return $false
            } else{
                if($ExPSS.State -eq "Opened" -AND $ExPSS.Availability -eq "Available"){
                    if(-not ($OrgName = ((get-OrganizationConfig).DistinguishedName.split(',') |?{$_ -like 'DC=*'}) -join '.' -replace 'DC=','')){
                        $smsg = "Missing Exchange Connection! (no (Get-OrganizationConfig).name returned)" ;
                        throw $smsg ;
                        $smsg | write-warning  ;
                    } else {
                        $smsg = "(connected to EXOP.Org:$($orgName))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    return $ExPSS
                } ;
            } ; 
        } ;
    }

#*------^ Connect-ExchangeServerTDO.ps1 ^------


#*------v connect-OPServices.ps1 v------
if(-not (get-childitem function:connect-OPServices -ea 0)){
    function connect-OPServices {
        <#
        .SYNOPSIS
        connect-OPServices - logic wrapper for my histortical scriptblock that resolves creds, svc avail and relevent status, to connect to range of Services (in OnPrem)
        .NOTES
        Version     : 0.0.
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2024-06-07
        FileName    : connect-OPServices
        License     : MIT License
        Copyright   : (c) 2024 Todd Kadrie
        Github      : https://github.com/tostka/verb-AAD
        Tags        : Powershell,AzureAD,Authentication,Test
        AddedCredit :
        AddedWebsite:
        AddedTwitter:
        REVISIONS
        * 9:00 AM 6/3/2025 revised CBH demo, properly handle cross-org conn attempts, incl forestwide spec recovery
        * 4:36 PM 6/2/2025 updated CBH demo to cover cross org fails, wo breaking cloud run (against MGDomain updates .ps1s)
        * 2:56 PM 5/19/2025 updated cross-org access fail, to rnot say missing creds ; rem'd $prefVaris dump (blank values, throws errors)
        3:35 PM 5/16/2025 spliced over local dep internal_funcs (out of the main paramt block) ;  dbgd, few minor fixes; but substantially working
        * 8:16 AM 5/15/2025 init
        .DESCRIPTION
        connect-OPServices - logic wrapper for my histortical scriptblock that resolves creds, svc avail and relevent status, to connect to range of Services (in OnPrem)
        .PARAMETER EnvSummary
        Pre-resolved local environrment summary (product of output of verb-io\resolve-EnvironmentTDO())[-EnvSummary `$rvEnv]
        .PARAMETER NetSummary
        Pre-resolved local network summary (product of output of verb-network\resolve-NetworkLocalTDO())[-NetSummary `$netsettings]
        .PARAMETER XoPSummary
        Pre-resolved local ExchangeServer summary (product of output of verb-ex2010\test-LocalExchangeInfoTDOO())[-XoPSummary `$lclExOP]
        .PARAMETER UseExOP
        Connect to OnPrem ExchangeManagementShell(Remote (Local,Edge))[-UseExOP]
        .PARAMETER useExopNoDep
        Connect to OnPrem ExchangeManagementShell using No Dependancy options)[-useEXO]
        .PARAMETER ExopVers
        Connect to OnPrem ExchangeServer version (Ex2019|Ex2016|Ex2013|Ex2010|Ex2007|Ex2003|Ex2000). An array represents a min/max range of all between; null indicates all versions returned by verb-Ex2010\get-ADExchangeServerTDO())[-useEXO]
        XOP Switch to set ForestWide Exchange EMS scope(e.g. Set-AdServerSettings -ViewEntireForest `$True)[-useForestWide]
        .PARAMETER UseOPAD
        Connect to OnPrem ActiveDirectory powershell module)[-UseOPAD]
        .PARAMETER useExOPVers
        String array to indicate target OnPrem Exchange Server version for connections. If an array is specified, will be assumed to reflect a span of versions to include, connections will aways be to a random server of the latest version specified (Ex2000|Ex2003|Ex2007|Ex2010|Ex2000|Ex2003|Ex2007|Ex2010|Ex2016|Ex2019), used with verb-Ex2010\get-ADExchangeServerTDO() dyn location via ActiveDirectory.[-useExOPVers @('Ex2010','Ex2016')]
        .PARAMETER TenOrg
        Tenant Tag (3-letter abbrebiation)[-TenOrg 'XYZ']
        .PARAMETER Credential
        Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
        .PARAMETER UserRole
        Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
        .PARAMETER useExOPVers
        String array to indicate target OnPrem Exchange Server version to target with connections, if an array, will be assumed to reflect a span of versions to include, connections will aways be to a random server of the latest version specified (Ex2000|Ex2003|Ex2007|Ex2010|Ex2000|Ex2003|Ex2007|Ex2010|Ex2016|Ex2019), used with verb-Ex2010\get-ADExchangeServerTDO() dyn location via ActiveDirectory.[-useExOPVers @('Ex2010','Ex2016')]
        .PARAMETER Silent
        Silent output (suppress status echos)[-silent]
        .INPUTS
        Does not accept piped input
        .OUTPUTS
        None (records transcript file)
        .EXAMPLE
        PS> $PermsRqd = connect-OPServices -path D:\scripts\new-MGDomainRegTDO.ps1 ;
        Typical pass script pass, using the -path param
        .EXAMPLE
        PS> $PermsRqd = connect-OPServices -scriptblock (gcm -name connect-OPServices).definition ;
        Typical function pass, using get-command to return the definition/scriptblock for the subject function.
        .EXAMPLE
        PS> #region CALL_CONNECT_OPSERVICES ; #*======v CALL_CONNECT_OPSERVICES v======
        PS> #$useOP = $false ; 
        PS> if($useOP){
        PS>     $pltCcOPSvcs=[ordered]@{
        PS>         # environment parameters:
        PS>         EnvSummary = $rvEnv ;
        PS>         NetSummary = $netsettings ;
        PS>         XoPSummary = $lclExOP ;
        PS>         # service choices
        PS>         UseExOP = $true ;
        PS>         useForestWide = $true ;
        PS>         useExopNoDep = $false ;
        PS>         ExopVers = 'Ex2010' ;
        PS>         UseOPAD = $true ;
        PS>         useExOPVers = $useExOPVers; # 'Ex2010' ;
        PS>         # Service Connection parameters
        PS>         TenOrg = $TenOrg ; # $global:o365_TenOrgDefault ;
        PS>         Credential = $Credential ;
        PS>         #[ValidateSet("SID","ESVC","LSVC")]
        PS>         UserRole = $UserRole ; # @('SID','ESVC') ;
        PS>         # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
        PS>         silent = $silent ;
        PS>     } ;
        PS>     
        PS>     write-verbose "(Purge no value keys from splat)" ;
        PS>     $mts = $pltCcOPSvcs.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltCcOPSvcs.remove($_.Name)} ; rv mts -ea 0 ;
        PS>     if((get-command connect-OPServices -EA STOP).parameters.ContainsKey('whatif')){
        PS>         $pltCcOPSvcsnDSR.add('whatif',$($whatif))
        PS>     } ;
        PS>     $smsg = "connect-OPServices w`n$(($pltCcOPSvcs|out-string).trim())" ;
        PS>     if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        PS>     $ret_CcOPSvcs = connect-OPServices @pltCcOPSvcs ; 
        PS>     
        PS>     # #region CONFIRM_CCOPRETURN ; #*------v CONFIRM_CCOPRETURN v------
        PS>     # matches each: $plt.useXXX:$true to matching returned $ret.hasXXX:$true
        PS>     $vplt = $pltCcOPSvcs ; $vret = 'ret_CcOPSvcs' ;  ; $ACtionCommand = 'connect-OPServices' ; 
        PS>     $vplt.GetEnumerator() |?{$_.key -match '^use' -ANd $_.value -match $true} | foreach-object{
        PS>         $pltkey = $_ ;
        PS>         $smsg = "$(($pltkey | ft -HideTableHeaders name,value|out-string).trim())" ; 
        PS>         if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        PS>         else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        PS>         $vtests = @() ;  $vFailMsgs = @()  ; 
        PS>         $tprop = $pltkey.name -replace '^use','has';
        PS>         if($rProp = (gv $vret).Value.psobject.properties | ?{$_.name -match $tprop}){
        PS>             $smsg = "$(($rprop | ft -HideTableHeaders name,value |out-string).trim())" ; 
        PS>             if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        PS>             else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        PS>             if($rprop.Value -eq $pltkey.value){
        PS>                 $vtests += $true ; 
        PS>                 $smsg = "Validated: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
        PS>                 if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
        PS>                 else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        PS>                 #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
        PS>             } else {
        PS>                 $smsg = "NOT VALIDATED: $($pltKey.name):$($pltKey.value) => $($rprop.name):$($rprop.value)" ;
        PS>                 $vtests += $false ; 
        PS>                 $vFailMsgs += "`n$($smsg)" ; 
        PS>                 if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        PS>                 else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        PS>             };
        PS>         } else{
        PS>             $smsg = "Unable to locate: $($pltKey.name):$($pltKey.value) to any matching $($rprop.name)!)" ;
        PS>             $smsg = "" ; 
        PS>             if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        PS>             else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        PS>         } ; 
        PS>     } ; 
        PS>     if($useOP -AND $vtests -notcontains $false){
        PS>         $smsg = "==> $($ACtionCommand): confirmed specified connections *all* successful " ; 
        PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
        PS>         else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        PS>         #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
        PS>     }elseif($vtests -contains $false -AND (get-variable ret_CcOPSvcs) -AND (gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper() -ne $env:userdomain){
        PS>         $smsg = "==> $($ACtionCommand): FAILED SOME SPECIFIED CONNECTIONS" ; 
        PS>         $smsg += "`nCROSS-ORG ONPREM CONNECTION: ATTEMPTING TO CONNECT TO ONPREM '$((gv -name "$($tenorg)meta").value.o365_Prefix)' $((gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper()) domain, FROM $($env:userdomain)!" ;
        PS>         $smsg += "`nEXPECTED ERROR, SKIPPING ONPREM ACCESS STEPS (force `$useOP:$false)" ;
        PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        PS>         else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        PS>         $useOP = $false ; 
        PS>     }elseif(-not $useOP -AND -not (get-variable ret_CcOPSvcs)){
        PS>         $smsg = "-useOP: $($useOP), skipped connect-OPServices" ; 
        PS>         if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        PS>         else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        PS>     } else {
        PS>         $smsg = "==> $($ACtionCommand): FAILED SOME SPECIFIED CONNECTIONS" ; 
        PS>         $smsg += "`n`$ret_CcOPSvcs:`n$(($ret_CcOPSvcs|out-string).trim())" ; 
        PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        PS>         else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        PS>         $sdEmail.SMTPSubj = "FAIL Rpt:$($ScriptBaseName):$(get-date -format 'yyyyMMdd-HHmmtt')"
        PS>         $sdEmail.SmtpBody = "`n===Processing Summary:" ;
        PS>         if($vFailMsgs){
        PS>             $sdEmail.SmtpBody += "`n$(($vFailMsgs|out-string).trim())" ; 
        PS>         } ; 
        PS>         $sdEmail.SmtpBody += "`n" ;
        PS>         if($SmtpAttachment){
        PS>             $sdEmail.SmtpAttachment = $SmtpAttachment
        PS>             $sdEmail.smtpBody +="`n(Logs Attached)" ;
        PS>         };
        PS>         $sdEmail.SmtpBody += "Pass Completed $([System.DateTime]::Now)" ;
        PS>         $smsg = "Send-EmailNotif w`n$(($sdEmail|out-string).trim())" ;
        PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        PS>         else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        PS>         Send-EmailNotif @sdEmail ;
        PS>         throw $smsg ; 
        PS>         BREAK ; 
        PS>     } ; 
        PS>     #endregion CONFIRM_CCOPRETURN ; #*------^ END CONFIRM_CCOPRETURN ^------
        PS>     #region CONFIRM_OPFORESTWIDE ; #*------v CONFIRM_OPFORESTWIDE v------    
        PS>     if($useOP -AND $pltCcOPSvcs.useForestWide -AND $ret_CcOPSvcs.hasForestWide -AND $ret_CcOPSvcs.AdGcFwide){
        PS>         $smsg = "==> $($ACtionCommand): confirmed has BOTH .hasForestWide & .AdGcFwide ($($ret_CcOPSvcs.AdGcFwide))" ; 
        PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success } 
        PS>         else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        PS>         #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success        
        PS>     }elseif($pltCcOPSvcs.useForestWide -AND (get-variable ret_CcOPSvcs) -AND (gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper() -ne $env:userdomain){
        PS>         $smsg = "`nCROSS-ORG ONPREM CONNECTION: ATTEMPTING TO CONNECT TO ONPREM '$((gv -name "$($tenorg)meta").value.o365_Prefix)' $((gv -name "$($tenorg)meta").value.o365_opdomain.split('.')[0].toupper()) domain, FROM $($env:userdomain)!" ;
        PS>         $smsg += "`nEXPECTED ERROR, SKIPPING ONPREM FORESTWIDE SPEC" ;
        PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        PS>         else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        PS>         $useOP = $false ; 
        PS>     }elseif($useOP -AND $pltCcOPSvcs.useForestWide -AND -NOT $ret_CcOPSvcs.hasForestWide){
        PS>         $smsg = "==> $($ACtionCommand): MISSING CRITICAL FORESTWIDE SUPPORT COMPONENT:" ; 
        PS>         if(-not $ret_CcOPSvcs.hasForestWide){
        PS>             $smsg += "`n----->$($ACtionCommand): MISSING .hasForestWide (Set-AdServerSettings -ViewEntireForest `$True) " ; 
        PS>         } ; 
        PS>         if(-not $ret_CcOPSvcs.AdGcFwide){
        PS>             $smsg += "`n----->$($ACtionCommand): MISSING .AdGcFwide GC!:`n((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):326) " ; 
        PS>         } ; 
        PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        PS>         else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        PS>         $smsg = "MISSING SOME KEY CONNECTIONS. DO YOU WANT TO IGNORE, AND CONTINUE WITH CONNECTED SERVICES?" ;
        PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
        PS>         else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        PS>         $bRet=Read-Host "Enter YYY to continue. Anything else will exit"  ;
        PS>         if ($bRet.ToUpper() -eq "YYY") {
        PS>             $smsg = "(Moving on), WITH THE FOLLOW PARTIAL CONNECTION STATUS" ;
        PS>             $smsg += "`n`n$(($ret_CcOPSvcs|out-string).trim())" ; 
        PS>             write-host -foregroundcolor green $smsg  ;
        PS>         } else {
        PS>             throw $smsg ; 
        PS>             break ; #exit 1
        PS>         } ;         
        PS>     }; 
        PS>     #endregion CONFIRM_OPFORESTWIDE ; #*------^ END CONFIRM_OPFORESTWIDE ^------
        PS> } ; 
        PS> #endregion CALL_CONNECT_OPSERVICES ; #*======^ END CALL_CONNECT_OPSERVICES ^======             
        Demo leveraging resolve-environmentTDO outputs
        .LINK
        https://bitbucket.org/tostka/verb-dev/
        #>
        ##Requires -Modules AzureAD, verb-AAD
        [CmdletBinding()]
        ## PSV3+ whatif support:[CmdletBinding(SupportsShouldProcess)]
        ###[Alias('Alias','Alias2')]
        PARAM(
            # environment parameters:
            [Parameter(Mandatory=$true,HelpMessage="Pre-resolved local environrment summary (product of output of verb-io\resolve-EnvironmentTDO())[-EnvSummary `$rvEnv]")]
                $EnvSummary, # $rvEnv
            [Parameter(Mandatory=$true,HelpMessage="Pre-resolved local network summary (product of output of verb-network\resolve-NetworkLocalTDO())[-NetSummary `$netsettings]")]
                $NetSummary, # $netsettings
            [Parameter(Mandatory=$true,HelpMessage="Pre-resolved local ExchangeServer summary (product of output of verb-ex2010\test-LocalExchangeInfoTDOO())[-XoPSummary `$lclExOP]")]
                $XoPSummary, # $lclExOP = test-LocalExchangeInfoTDO ;
            # service choices
            # OP switches
            #[Parameter(HelpMessage="Connect to OnPrem ExchangeManagementShell(Remote (Local,Edge))[-UseOP]")]
            #    [switch]$UseOP, # interpolate from below
            [Parameter(HelpMessage="Connect to OnPrem ExchangeManagementShell(Remote (Local,Edge))[-UseExOP]")]
                [switch]$UseExOP,
            [Parameter(HelpMessage="Connect to OnPrem ExchangeManagementShell using No Dependancy options)[-useEXO]")]
                [switch]$useExopNoDep,
            [Parameter(HelpMessage="Connect to OnPrem ExchangeServer version (Ex2019|Ex2016|Ex2013|Ex2010|Ex2007|Ex2003|Ex2000). An array represents a min/max range of all between; null indicates all versions returned by verb-Ex2010\get-ADExchangeServerTDO())[-useEXO]")]
                [AllowNull()]
                [ValidateSet('Ex2019','Ex2016','Ex2013','Ex2010','Ex2007','Ex2003','Ex2000')]
                [string[]]$ExopVers, # = 'Ex2010' # 'Ex2019','Ex2016','Ex2013','Ex2010','Ex2007','Ex2003','Ex2000', Null for All versions
                #if($Version){
                #   $ExopVers = $Version ; #defer to local script $version if set
                #} ;
            [Parameter(HelpMessage="XOP Switch to set ForestWide Exchange EMS scope(e.g. Set-AdServerSettings -ViewEntireForest `$True)[-useForestWide]")]
                [switch]$useForestWide,
            [Parameter(HelpMessage="Connect to OnPrem ActiveDirectory powershell module)[-UseOPAD]")]
                [switch]$UseOPAD,
            #
            # Service Connection parameters
            [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
                [ValidateNotNullOrEmpty()]
                #[ValidatePattern("^\w{3}$")]
                [string]$TenOrg = $global:o365_TenOrgDefault,
            [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
                [System.Management.Automation.PSCredential]$Credential,
            [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
                # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ;
                #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
                # pulling the pattern from global vari w friendly err
                [ValidateScript({
                    if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                    if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ;
                    return $true ;
                })]
                [string[]]$UserRole = @('SID','ESVC'),
                # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
            [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
                [switch] $silent,
            [Parameter(Mandatory=$FALSE,HelpMessage="String array to indicate target OnPrem Exchange Server version for connections. If an array is specified, will be assumed to reflect a span of versions to include, connections will aways be to a random server of the latest version specified (Ex2000|Ex2003|Ex2007|Ex2010|Ex2000|Ex2003|Ex2007|Ex2010|Ex2016|Ex2019), used with verb-Ex2010\get-ADExchangeServerTDO() dyn location via ActiveDirectory.[-useExOPVers @('Ex2010','Ex2016')]")]
                [AllowNull()]
                [ValidateSet('Ex2000','Ex2003','Ex2007','Ex2010','Ex2000','Ex2003','Ex2007','Ex2010','Ex2016','Ex2019')]
                [string[]]$useExOPVers = 'Ex2010'
        );
        BEGIN {
            # for scripts wo support, can use regions to fake BEGIN;PROCESS;END: (tho' can use the real deal in scripts as well as adv funcs, as long as all code is inside the blocks)
            # ps1 faked:#region BEGIN ; #*------v BEGIN v------
            # 8:59 PM 4/23/2025 with issues in CMW - funcs unrecog'd unless loaded before any code use - had to move the entire FUNCTIONS block to the top of BEGIN{}

            #region FUNCTIONS_INTERNAL ; #*======v FUNCTIONS_INTERNAL v======
            # Pull the CUser mod dir out of psmodpaths:
            #$CUModPath = $env:psmodulepath.split(';')|?{$_ -like '*\Users\*'} ;

            #region CONNECT_EXCHANGESERVERTDO ; #*------v Connect-ExchangeServerTDO v------
            if(-not(gi function:Connect-ExchangeServerTDO -ea 0)){
                Function Connect-ExchangeServerTDO {
                    <#
                    .SYNOPSIS
                    Connect-ExchangeServerTDO.ps1 - Dependancy-less Function that, fed an Exchange server name, or AD SiteName, and optional RoleNames array, 
                    will obtain a list of Exchange servers from AD (in the specified scope), and then run the list attempting to PowershellREmote (REMS) connect to each server, 
                    stopping at the first successful connection.
                    .NOTES
                    REVISIONS
                    * 3:58 PM 5/14/2025 restored prior dropped earlier rev history (routinely trim for psparamt inclu)
                    .PARAMETER name
                    FQDN of a specific Exchange server[-Name EXSERVER.DOMAIN.COM]
                    .PARAMETER discover
                    Boolean paraameter that drives auto-discovery of target Exchange servers for connection (defaults `$true)[-discover:`$false]
                    .PARAMETER credential
                    Use specific Credentials[-Credentials [credential object]
                        .PARAMETER Site
                    Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-Site 'SITENAME']
                    .PARAMETER RoleNames
                    Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']
                    .PARAMETER Version
                    Specific Exchange Server Version to connect to('Ex2019|Ex2016|Ex2013|Ex2010|Ex2007|Ex2003|Ex2000')[-Version 'Ex2016']
                    .PARAMETER TenOrg
                    Tenant Tag (3-letter abbrebiation - defaults to variable `$global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']
                    .INPUTS
                    None. Does not accepted piped input.(.NET types, can add description)
                    .OUTPUTS
                    [system.object] Returns a system object containing a successful PSSession
                    System.Boolean
                    .EXAMPLE
                    PS> $PSSession = Connect-ExchangeServerTDO -siteName SITENAME -RoleNames @('HUB','CAS') -verbose 
                    Demo's connecting to a functional Hub or CAS server in the SITENAME site with verbose outputs, the `PSSession variable will contain information about the successful connection. Makes automatic Exchangeserver discovery calls into AD (using ADSI) leveraging the separate get-ADExchangeServerTDO()
                    .EXAMPLE
                    PS> TRY{$Site=[System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name}CATCH{$Site=$env:COMPUTERNAME} ;
                    PS> $PSSession = Connect-ExchangeServerTDO -siteName $Site -RoleNames @('HUB','CAS') -verbose ; 
                    Demo including support for EdgeRole, which is detected on it's lack of AD Site specification (which gets fed through to call, by setting the Site to the machine itself).
                    .EXAMPLE
                    PS> $PSSession = Connect-ExchangeServerTDO -siteName SITENAME -RoleNames @('HUB','CAS') -Version Ex2016 -verbose 
                    Demo's connecting to a functional Hub or CAS server Version Ex2016 in the SITENAME site with verbose outputs, the `PSSession variable will contain information about the successful connection. Makes automatic Exchangeserver discovery calls into AD (using ADSI) leveraging the separate get-ADExchangeServerTDO()
                    #>        
                    [CmdletBinding(DefaultParameterSetName='discover')]
                    PARAM(
                        [Parameter(Position=0,Mandatory=$true,ParameterSetName='name',HelpMessage="FQDN of a specific Exchange server[-Name EXSERVER.DOMAIN.COM]")]
                            [String]$name,
                        [Parameter(Position=0,ParameterSetName='discover',HelpMessage="Boolean paraameter that drives auto-discovery of target Exchange servers for connection (defaults `$true)[-discover:`$false]")]
                            [bool]$discover=$true,
                        [Parameter(Position=1,HelpMessage = "Use specific Credentials[-Credentials [credential object]")]
                            [Management.Automation.PSCredential]$credential,
                        [Parameter(Position=1,HelpMessage="Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-Site 'SITENAME']")]
                            [Alias('Site')]
                            [string]$SiteName = (gv -name "$($TenOrg)_ADSiteDefaultName" -ea 0).Value,
                        [Parameter(Position=2,HelpMessage="Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']")]
                            [ValidateSet('MBX','CAS','HUB','UM','MBX','EDGE')]
                            [string[]]$RoleNames = @('HUB','CAS'),
                        [Parameter(Position=2,HelpMessage="Specific Exchange Server Version to connect to('Ex2019|Ex2016|Ex2013|Ex2010|Ex2007|Ex2003|Ex2000')[-Version 'Ex2016']")]
                            [ValidateSet('Ex2019','Ex2016','Ex2013','Ex2010','Ex2007','Ex2003','Ex2000')]
                            [string[]]$Version = 'Ex2010',
                        [Parameter(Mandatory=$FALSE,HelpMessage="Tenant Tag (3-letter abbrebiation - defaults to global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']")]
                            [ValidateNotNullOrEmpty()]
                            [string]$TenOrg = $global:o365_TenOrgDefault
                    ) ;
                    BEGIN{
                        $Verbose = ($VerbosePreference -eq 'Continue') ;
                        $CurrentVersionTlsLabel = [Net.ServicePointManager]::SecurityProtocol ; # Tls, Tls11, Tls12 ('Tls' == TLS1.0)  ;
                  write-verbose "PRE: `$CurrentVersionTlsLabel : $($CurrentVersionTlsLabel )" ;
                  # psv6+ already covers, test via the SslProtocol parameter presense
                  if ('SslProtocol' -notin (Get-Command Invoke-RestMethod).Parameters.Keys) {
                    $currentMaxTlsValue = [Math]::Max([Net.ServicePointManager]::SecurityProtocol.value__,[Net.SecurityProtocolType]::Tls.value__) ;
                    write-verbose "`$currentMaxTlsValue : $($currentMaxTlsValue )" ;
                    $newerTlsTypeEnums = [enum]::GetValues('Net.SecurityProtocolType') | Where-Object { $_ -gt $currentMaxTlsValue }
                    if($newerTlsTypeEnums){
                      write-verbose "Appending upgraded/missing TLS `$enums:`n$(($newerTlsTypeEnums -join ','|out-string).trim())" ;
                    } else {
                      write-verbose "Current TLS `$enums are up to date with max rev available on this machine" ;
                    };
                    $newerTlsTypeEnums | ForEach-Object {
                      [Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor $_
                    } ;
                  } ;
                
                        # 5:15 PM 4/22/2025 on CMW, have to patch version to Ex2016

                        #*------v Function _connect-ExOP v------
                        function _connect-ExOP{
                                [CmdletBinding()]
                                PARAM(
                                    [Parameter(Position=0,Mandatory=$true,HelpMessage="Exchange server AD Summary system object[-Server EXSERVER.DOMAIN.COM]")]
                                        [system.object]$Server,
                                    [Parameter(Position=1,HelpMessage = "Use specific Credentials[-Credentials [credential object]")]
                                        [Management.Automation.PSCredential]$credential
                                );
                                $verbose = $($VerbosePreference -eq "Continue") ;
                                if([double]$ExVersNum = [regex]::match($Server.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value){
                                    switch -regex ([string]$ExVersNum) {
                                        '15.2' { $isEx2019 = $true ; $ExVers = 'Ex2019' }
                                        '15.1' { $isEx2016 = $true ; $ExVers = 'Ex2016'}
                                        '15.0' { $isEx2013 = $true ; $ExVers = 'Ex2013'}
                                        '14.*' { $isEx2010 = $true ; $ExVers = 'Ex2010'}
                                        '8.*' { $isEx2007 = $true ; $ExVers = 'Ex2007'}
                                        '6.5' { $isEx2003 = $true ; $ExVers = 'Ex2003'}
                                        '6' {$isEx2000 = $true ; $ExVers = 'Ex2000'} ;
                                        default {
                                            $smsg = "UNRECOGNIZED ExVersNum.Major.Minor string:$($ExVersNum)! ABORTING!" ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            THROW $SMSG ;
                                            BREAK ;
                                        }
                                    } ;
                                }else {
                                    $smsg = "UNABLE TO RESOLVE `$ExVersNum from `$Server.version:$($Server.version)!" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    throw $smsg ;
                                    break ;
                                } ;
                                if($Server.RoleNames -eq 'EDGE'){
                                    if(($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup')) -or
                                        ($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup')) -or
                                        $ByPassLocalExchangeServerTest)
                                    {
                                        if((Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\EdgeTransportRole') -or
                                                (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\EdgeTransportRole'))
                                        {
                                            $smsg = "We are on Exchange Edge Transport Server"
                                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                            $IsEdgeTransport = $true
                                        }
                                        TRY {
                                            Get-ExchangeServer -ErrorAction Stop | Out-Null
                                            $smsg = "Exchange PowerShell Module already loaded."
                                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                            $passed = $true 
                                        }CATCH {
                                            $smsg = "Failed to run Get-ExchangeServer"
                                            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                            if($isLocalExchangeServer){
                                                write-host  "Loading Exchange PowerShell Module..."
                                                TRY{
                                                    if($IsEdgeTransport){
                                                        # implement local snapins access on edge role: Only way to get access to EMS commands.
                                                        [xml]$PSSnapIns = Get-Content -Path "$env:ExchangeInstallPath\Bin\exshell.psc1" -ErrorAction Stop
                                                        ForEach($PSSnapIn in $PSSnapIns.PSConsoleFile.PSSnapIns.PSSnapIn){
                                                            write-verbose ("Trying to add PSSnapIn: {0}" -f $PSSnapIn.Name)
                                                            Add-PSSnapin -Name $PSSnapIn.Name -ErrorAction Stop
                                                        } ; 
                                                        Import-Module $env:ExchangeInstallPath\bin\Exchange.ps1 -ErrorAction Stop ; 
                                                        $passed = $true #We are just going to assume this passed.
                                                    }else{
                                                        Import-Module $env:ExchangeInstallPath\bin\RemoteExchange.ps1 -ErrorAction Stop
                                                        Connect-ExchangeServer -Auto -ClientApplication:ManagementShell
                                                        $passed = $true #We are just going to assume this passed.
                                                    } 
                                                }CATCH {
                                                    $smsg = "Failed to Load Exchange PowerShell Module..." ; 
                                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                                }                               
                                            } ;
                                        } FINALLY {
                                            if($LoadExchangeVariables -and $passed -and $isLocalExchangeServer){
                                                if($ExInstall -eq $null -or $ExBin -eq $null){
                                                    if(Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup'){
                                                        $Global:ExInstall = (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup).MsiInstallPath
                                                    }else{
                                                        $Global:ExInstall = (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup).MsiInstallPath
                                                    }
    
                                                    $Global:ExBin = $Global:ExInstall + "\Bin"
    
                                                    $smsg = ("Set ExInstall: {0}" -f $Global:ExInstall)
                                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                                    $smsg = ("Set ExBin: {0}" -f $Global:ExBin)
                                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                                } ; 
                                            } ; 
                                        } ; 
                                    } else  {
                                        $smsg = "Does not appear to be an Exchange 2010 or newer server." ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                                    }
                                    if(get-command -Name Get-OrganizationConfig -ea 0){
                                        $smsg = "Running in connected/Native EMS" ; 
                                        if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                        Return $true ; 
                                    } else { 
                                        TRY{
                                            $smsg = "Initiating Edge EMS local session (exshell.psc1 & exchange.ps1)" ; 
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                            # 5;36 PM 5/30/2024 didn't work, went off to nowhere for a long time, and exited the script
                                            #& (gcm powershell.exe).path -PSConsoleFile "$($env:ExchangeInstallPath)bin\exshell.psc1" -noexit -command ". '$($env:ExchangeInstallPath)bin\Exchange.ps1'"
                                            <# [Adding the Transport Server to Exchange - Mark Lewis Blog](https://marklewis.blog/2020/11/19/adding-the-transport-server-to-exchange/)
                                            To access the management console on the transport server, I opened PowerShell then ran
                                            exshell.psc1
                                            Followed by
                                            exchange.ps1
                                            At this point, I was able to create a new subscription using he following PowerShel
                                            #>
                                            invoke-command exshell.psc1 ; 
                                            invoke-command exchange.ps1
                                            if(get-command -Name Get-OrganizationConfig -ea 0){
                                                $smsg = "Running in connected/Native EMS" ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                                Return $true ;
                                            } else { return $false };  
                                        }CATCH{
                                            Write-Error $_ ;
                                        } ;
                                    } ; 
                                } else {
                                    $pltNPSS=@{ConnectionURI="http://$($Server.FQDN)/powershell"; ConfigurationName='Microsoft.Exchange' ; name="Exchange$($ExVersNum.tostring())"} ;
                                    $pltIMod=@{Global=$true;PassThru=$true;DisableNameChecking=$true ;} ;
                                    # use ExVersUnm dd instead of hardcoded (Exchange2010)
                                    if($ExVersNum -ge 15){
                                        $smsg = "EXOP.15+:Adding -Authentication Kerberos" ;
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                        $pltNPSS.add('Authentication',"Kerberos") ;
                                        $pltNPSS.name = $ExVers ;
                                    } ;
                                    $smsg = "Adding EMS (connecting to $($Server.FQDN))..." ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                    $smsg = "New-PSSession w`n$(($pltNPSS|out-string).trim())" ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                    $ExPSS = New-PSSession @pltNPSS  ;
                                    $ExIPSS = Import-PSSession $ExPSS -allowclobber ;
                                    # 3:59 PM 1/9/2025 appears credprompting is due to it's missing the import-module $ExIPSS ! 
                                    $smsg = "Import-Module w`n$(($pltIMod|out-string).trim())" ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                    $Global:E10Mod = Import-Module $ExIPSS @pltIMod ;
                                    $ExPSS | write-output ;
                                    $ExPSS= $ExIPSS = $null ;
                                } ; 
                            } ;
                        #*------^ END Function _connect-ExOP ^------
                        $pltGADX=@{
                            ErrorAction='Stop';
                        } ;
                    } ;
                    PROCESS{
                        if($PSBoundParameters.ContainsKey('credential')){
                            $pltGADX.Add('credential',$credential) ;
                        }
                        if($SiteName){
                            $pltGADX.Add('siteName',$siteName) ;
                        } ;
                        if($RoleNames){
                            $pltGADX.Add('RoleNames',$RoleNames) ;
                        } ;
                        TRY{
                            if($discover){
                                $smsg = "Getting list of Exchange Servers" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                $exchServers=get-ADExchangeServerTDO @pltGADX | sort responsetime ;
                            }else{
                                $exchServers=get-ADExchangeServerTDO @pltGADX | sort responsetime ;
                            } ;
                            $pltTW=@{
                                'ErrorAction'='Stop';
                            } ;
                            $pltCXOP = @{
                                verbose = $($VerbosePreference -eq "Continue") ;
                            } ;
                            if($pltGADX.credential){
                                $pltCXOP.Add('Credential',$pltGADX.credential) ;
                            } ;
                            if($Version){
                                switch ($Version){
                                  'Ex2000'{$rgxExVersNum = '6' } 
                                  'Ex2003'{$rgxExVersNum = '6.5' } 
                                  'Ex2007'{$rgxExVersNum = '8.*' } 
                                  'Ex2010'{$rgxExVersNum = '14.*'} 
                                  'Ex2013'{$rgxExVersNum = '15.0' } 
                                  'Ex2016'{$rgxExVersNum = '15.1'} 
                                  'Ex2019'{$rgxExVersNum = '15.2' } 
                                } ; 
                                $exchServers  = $exchServers | ?{ [double]([regex]::match( $_.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value) -match $rgxExVersNum } ; 

                            } else {
                                write-verbose "no -Version: Sorting Newest first, then names, descending" ; 
                                $exchServers  = $exchServers | sort version,name -desc
                            } ; 
                            $prpPSS = 'Id','Name','ComputerName','ComputerType','State','ConfigurationName','Availability' ; 
                            foreach($exServer in $exchServers){
                                $smsg = "testing conn to:$($exServer.name.tostring())..." ; 
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                if(get-command -module (get-module |?{$_.name -like 'tmp_*'}).name -name 'get-OrganizationConfig' -ea SilentlyContinue){
                                    if($pssEXOP = Get-PSSession |  where-object { ($_.ConfigurationName -eq 'Microsoft.Exchange') -AND ( $_.runspace.ConnectionInfo.AppName -match '^/(exadmin|powershell)$') -AND ( $_.runspace.ConnectionInfo.Port -eq '80') }){
                                        if($pssEXOP.State -ne "Opened" -OR $pssEXOP.Availability -ne "Available"){
                                            $pssEXOP | remove-pssession ; $pssEXOP = $null ;
                                        } ;
                                    } ; 
                                } else {
                                    $smsg = "(mangled ExOP conn: disconnect/reconnect...)" ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                    if($pssEXOP = Get-PSSession |  where-object { ($_.ConfigurationName -eq 'Microsoft.Exchange') -AND ( $_.runspace.ConnectionInfo.AppName -match '^/(exadmin|powershell)$') -AND ( $_.runspace.ConnectionInfo.Port -eq '80') }){
                                        if($pssEXOP.State -ne "Opened" -OR $pssEXOP.Availability -ne "Available"){
                                            $pssEXOP | remove-pssession ; $pssEXOP = $null ;
                                        } ;
                                    } ; 
                                } ;
                                if(-not $pssEXOP){
                                    $smsg = "Connecting to: $($exServer.FQDN)" ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                    $smsg = "_connect-ExOP w`n$(($pltCXOP|out-string).trim())" ;
                                    $smsg += "`nServer $($exServer.FQDN)" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    if($NoTest){
                                        $ExPSS =$ExPSS = _connect-ExOP @pltCXOP -Server $exServer
                                    } else {
                                        TRY{
                                            $smsg = "Testing Connection: $($exServer.FQDN)" ;
                                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                            If(test-connection $exServer.FQDN -count 1 -ea 0) {
                                                $smsg = "confirmed pingable..." ;
                                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                            } else {
                                                $smsg = "Unable to Ping $($exServer.FQDN)" ; ;
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            } ;
                                            $smsg = "Testing WinRm: $($exServer.FQDN)" ;
                                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                            $winrm=Test-WSMan @pltTW -ComputerName $exServer.FQDN ;
                                            if($winrm){
                                                $ExPSS = _connect-ExOP @pltCXOP -Server $exServer;
                                            } else {
                                                $smsg = "Unable to Test-WSMan $($exServer.FQDN) (skipping)" ; ;
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            } ;
                                        }CATCH{
                                            $errMsg="Server: $($exServer.FQDN)] $($_.Exception.Message)" ;
                                            Write-Error -Message $errMsg ;
                                            continue ;
                                        } ;
                                    };
                                } else {
                                    $smsg = "$((get-date).ToString('HH:mm:ss')):Accepting first valid connection w`n$(($pssEXOP | ft -a $prpPSS|out-string).trim())" ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success }
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    $ExPSS = $pssEXOP ; 
                                    break ; 
                                }  ;
                            } ;
                        }CATCH{
                            Write-Error $_ ;
                        } ;
                    } ;
                    END{
                        if(-not $ExPSS){
                            $smsg = "NO SUCCESSFUL CONNECTION WAS MADE, WITH THE SPECIFIED INPUTS!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $smsg = "(returning `$false to the pipeline...)" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            return $false
                        } else{
                            if($ExPSS.State -eq "Opened" -AND $ExPSS.Availability -eq "Available"){
                                if(-not ($OrgName = ((get-OrganizationConfig).DistinguishedName.split(',') |?{$_ -like 'DC=*'}) -join '.' -replace 'DC=','')){
                                    $smsg = "Missing Exchange Connection! (no (Get-OrganizationConfig).name returned)" ;
                                    throw $smsg ;
                                    $smsg | write-warning  ;
                                } else {
                                    $smsg = "(connected to EXOP.Org:$($orgName))" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success }
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                } ;
                                return $ExPSS
                            } ;
                        } ; 
                    } ;
                } ;
            } ; 
            #endregion CONNECT_EXCHANGESERVERTDO ; #*------^ END Connect-ExchangeServerTDO ^------

            #region GET_ADEXCHANGESERVERTDO ; #*------v get-ADExchangeServerTDO v------
            if(-not(gi function:get-ADExchangeServerTDO -ea 0)){
                Function get-ADExchangeServerTDO {
                    <#
                    .SYNOPSIS
                    get-ADExchangeServerTDO.ps1 - Returns Exchangeserver summary(s) from AD records
                    .NOTES
                    Version     : 3.0.1
                    Author      : Todd Kadrie
                    Website     : http://www.toddomation.com
                    Twitter     : @tostka / http://twitter.com/tostka
                    CreatedDate : 2015-09-03
                    FileName    : get-ADExchangeServerTDO.ps1
                    License     : (none-asserted)
                    Copyright   : (none-asserted)
                    Github      : https://github.com/tostka/verb-Ex2010
                    Tags        : Powershell, ActiveDirectory, Exchange, Discovery
                    AddedCredit : Mike Pfeiffer
                    AddedWebsite: mikepfeiffer.net
                    AddedTwitter: URL
                    AddedCredit : Sammy Krosoft 
                    AddedWebsite: http://aka.ms/sammy
                    AddedTwitter: URL
                    AddedCredit : Brian Farnsworth
                    AddedWebsite: https://codeandkeep.com/
                    AddedTwitter: URL
                    REVISIONS
                    * 3:57 PM 11/26/2024 updated simple write-host,write-verbose with full pswlt support;  syncd dbg & vx10 copies.
                    * 12:57 PM 6/11/2024 Validated, Ex2010 & Ex2019, hub, mail & edge roles: tested ☑️ on CMW mail role (Curly); and Jumpbox; copied in CBH from repo copy, which has been updated/debugged compat on CMW Edge 
                    * 2:05 PM 8/28/2023 REN -> Get-ExchangeServerInSite -> get-ADExchangeServerTDO (aliased orig); to better steer profile-level options - including in cmw org, added -TenOrg, and default Site to constructed vari, targeting new profile $XXX_ADSiteDefault vari; Defaulted -Roles to HUB,CAS as well.
                    * 3:42 PM 8/24/2023 spliced together combo of my long-standing, and some of the interesting ideas BF's version had. Functional prod:
                        - completely removed ActiveDirectory module dependancies from BF's code, and reimplemented in raw ADSI calls. Makes it fully portable, even into areas like Edge DMZ roles, where ADMS would never be installed.

                    * 3:17 PM 8/23/2023 post Edge testing: some logic fixes; add: -Names param to filter on server names; -Site & supporting code, to permit lookup against sites *not* local to the local machine (and bypass lookup on the local machine) ; 
                        ren $Ex10siteDN -> $ExOPsiteDN; ren $Ex10configNC -> $ExopconfigNC
                    * 1:03 PM 8/22/2023 minor cleanup
                    * 10:31 AM 4/7/2023 added CBH expl of postfilter/sorting to draw predictable pattern 
                    * 4:36 PM 4/6/2023 validated Psv51 & Psv20 and Ex10 & 16; added -Roles & -RoleNames params, to perform role filtering within the function (rather than as an external post-filter step). 
                    For backward-compat retain historical output field 'Roles' as the msexchcurrentserverroles summary integer; 
                    use RoleNames as the text role array; 
                        updated for psv2 compat: flipped hash key lookups into properties, found capizliation differences, (psv2 2was all lower case, wouldn't match); 
                    flipped the [pscustomobject] with new... psobj, still psv2 doesn't index the hash keys ; updated for Ex13+: Added  16  "UM"; 20  "CAS, UM"; 54  "MBX" Ex13+ ; 16385 "CAS" Ex13+ ; 16439 "CAS, HUB, MBX" Ex13+
                    Also hybrided in some good ideas from SammyKrosoft's Get-SKExchangeServers.psm1 
                    (emits Version, Site, low lvl Roles # array, and an array of Roles, for post-filtering); 
                    # 11:20 AM 4/21/2021 fixed/suppressed noisy verbose calls
                    * 12:08 PM 5/15/2020 fixed vpn issue: Try/Catch'd around recently failing $ADSite::GetComputerSite().GetDirectoryEntry().distinguishedName qry
                    * 11:22 AM 3/13/2020 Get-ExchangeServerInSite added a ping-test, to only return matches that are pingable, added -NoPing param, to permit (faster) untested bypass
                    * 6:59 PM 1/15/2020 cleanup
                    # 10:03 AM 11/16/2018 Get-ExchangeServerInSite:can't do AD-related functions when not AD authentictaed (home, pre-vpn connect). Added if/then test on status and abort balance when false.
                    * 11/18/18 BF's posted rev
                    # 12:10 PM 8/1/2017 updated example code at bottom, to accommodate variant sites
                    # 11:28 AM 3/31/2016 validated that latest round of updates are still functional
                    #1:58 PM 9/3/2015 - added pshelp and some docs
                    #April 12, 2010 - web version
                    .DESCRIPTION
                    get-ADExchangeServerTDO.ps1 - Returns Exchangeserver summary(s) from AD records

                    Hybrided together ideas from Brian Farnsworth's blog post
                    [PowerShell - ActiveDirectory and Exchange Servers – CodeAndKeep.Com – Code and keep calm...](https://codeandkeep.com/PowerShell-ActiveDirectory-Exchange-Part1/)
                    ... with much older concepts from  Sammy Krosoft, and much earlier Mike Pfeiffer. 

                    - Subbed in MP's use of ADSI for ActiveDirectory Ps mod cmds - it's much more dependancy-free; doesn't require explicit install of the AD ps module
                    ADSI support is built into windows.
                    - spliced over my addition of Roles, RoleNames, Name & NoTest params, for prefiltering and suppressing testing.


                    [briansworth · GitHub](https://github.com/briansworth)

                    Uses an ADSI DirectorySearcher to search the current Active Directory site for Exchange on-prem servers.
                            Intent is to discover connection points for Powershell, wo the need to preload/pre-connect to Exchange.

                            But, as a non-Exchange-Management-Shell-dependant info source on Exchange Server configs, it can be used before connection, with solely AD-available data, to check configuration spes on the subject server(s). 

                            For example, this query will return sufficient data under Version to indicate which revision of Exchange is in use:


                            Returned object (in array):
                            Site      : {ADSITENAME}
                            Roles     : {64}
                            Version   : {Version 15.1 (Build 32375.7)}
                            Name      : SERVERNAME
                            RoleNames : EDGE
                            FQDN      : SERVERNAME.DOMAIN.TLD

                            ... includes the post-filterable Role property ($_.Role -contains 'CAS') which reflects the following
                            installed-roles ('msExchCurrentServerRoles') on the discovered servers
                                2   {"MBX"} # Ex10
                                4   {"CAS"}
                                16  {"UM"}
                                20  {"CAS, UM" -split ","} # 
                                32  {"HUB"}
                                36  {"CAS, HUB" -split ","}
                                38  {"CAS, HUB, MBX" -split ","}
                                54  {"MBX"} # Ex13+
                                64  {"EDGE"}
                                16385   {"CAS"} # Ex13+
                                16439   {"CAS, HUB, MBX"  -split ","} # Ex13+
                    .PARAMETER Roles
                    Array of msExchCurrentServerRoles 'role' integers to be filtered against (2|4|16|20|32|36|38|54|64|16385|16439)[-Roles @(38,16385)]
                    .PARAMETER RoleNames
                    Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']
                    .PARAMETER Server
                    Array of Server name strings to be filtered against[-Server 'SERVER1','SERVER2']
                    .PARAMETER SiteName
                    Name of specific AD SiteName to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-SiteName 'SITENAME']
                    .PARAMETER TenOrg
                    Tenant Tag (3-letter abbrebiation - defaults to variable `$global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']
                    .PARAMETER NoPing
                    Switch to suppress default 'pingable' test (e.g. returns all matches, no testing)[-NoPing]
                    .INPUTS
                    None. Does not accepted piped input.(.NET types, can add description)
                    .OUTPUTS
                    None. Returns no objects or output (.NET types)
                    System.Boolean
                    [| get-member the output to see what .NET obj TypeName is returned, to use here]
                    System.Array of System.Object's
                    .EXAMPLE
                    PS> If(!($ExchangeServer)){$ExchangeServer = (get-ADExchangeServerTDO| ?{$_.RoleNames -contains 'CAS' -OR $_.RoleNames -contains 'HUB' -AND ($_.FQDN -match "^SITECODE") } | Get-Random ).FQDN
                    Return a random Hub Cas Role server in the local Site with a fqdn beginning SITECODE
                    .EXAMPLE
                    PS> $localADExchserver = get-ADExchangeServerTDO -Names $env:computername -SiteName ([System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().name)
                    Demo, if run from an Exchange server, return summary details about the local server (-SiteName isn't required, is default imputed from local server's Site, but demos explicit spec for remote sites)
                    .EXAMPLE
                    PS> $regex = '(' + [regex]($ADSiteCodeUK,$ADSiteCodeAU -join "|") + ')'
                    PS> switch -regex ($($env:computername).substring(0,3)){
                    PS>    "$($ADSiteCodeUS)" {$tExRole=36 } ;
                    PS>    "$($regex)" {$tExRole= 38 }  default { write-error "$((get-date).ToString('HH:mm:ss')):UNRECOGNIZED SERVER PREFIX!."; } ;
                    PS> } ;
                    PS> $exhubcas = (get-ADExchangeServerTDO |?{($_.roles -eq $tExRole) -AND ($_.FQDN -match "$($env:computername.substring(0,3)).*")} | Get-Random ).FQDN ;
                    Use a switch block to select different role combo targets for a given server fqdn prefix string.
                    .EXAMPLE
                    PS> $ExchangeServer = get-ADExchangeServerTDO | ?{$_.Roles -match '(4|20|32|36|38|16385|16439)'} | select -expand fqdn | get-random ; 
                    Another/Older approach filtering on the Roles integer (targeting combos with Hub or CAS in the mix)
                    .EXAMPLE
                    PS> $ret = get-ADExchangeServerTDO -Roles @(4,20,32,36,38,16385,16439) -verbose 
                    Demo use of the -Roles param, feeding it an array of Role integer values to be filtered against. In this case, the Role integers that include a CAS or HUB role.
                    .EXAMPLE
                    PS> $ret = get-ADExchangeServerTDO -RoleNames 'HUB','CAS' -verbose ;
                    Demo use of the -RoleNames param, feeding it the array 'HUB','CAS' Role name strings to be filtered against
                    PS> $ret = get-ADExchangeServerTDO -Names 'SERVERName' -verbose ;
                    Demo use of the -RoleNames param, feeding it the array 'HUB','CAS' Role name strings to be filtered against
                    .EXAMPLE
                    PS> $ExchangeServer = get-ADExchangeServerTDO | sort version,roles,name | ?{$_.rolenames -contains 'CAS'}  | select -last 1 | select -expand fqdn ;
                    Demo post sorting & filtering, to deliver a rule-based predictable pattern for server selection: 
                    Above will always pick the highest Version, 'CAS' RoleName containing, alphabetically last server name (that is pingable). 
                    And should stick to that pattern, until the servers installed change, when it will shift to the next predictable box.
                    .EXAMPLE
                    PS> $ExOPServer = get-ADExchangeServerTDO -Name LYNMS650 -SiteName Lyndale
                    PS> if([double]$ExVersNum = [regex]::match($ExOPServer.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value){
                    PS>     switch -regex ([string]$ExVersNum) {
                    PS>         '15\.2' { $isEx2019 = $true ; $ExVers = 'Ex2019' }
                    PS>         '15\.1' { $isEx2016 = $true ; $ExVers = 'Ex2016'}
                    PS>         '15\.0' { $isEx2013 = $true ; $ExVers = 'Ex2013'}
                    PS>         '14\..*' { $isEx2010 = $true ; $ExVers = 'Ex2010'}
                    PS>         '8\..*' { $isEx2007 = $true ; $ExVers = 'Ex2007'}
                    PS>         '6\.5' { $isEx2003 = $true ; $ExVers = 'Ex2003'}
                    PS>         '6|6\.0' {$isEx2000 = $true ; $ExVers = 'Ex2000'} ;
                    PS>         default {
                    PS>             $smsg = "UNRECOGNIZED ExchangeServer.AdminDisplayVersion.Major.Minor string:$($ExOPServer.version)! ABORTING!" ;
                    PS>             write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                    PS>         }
                    PS>     } ; 
                    PS> }else {
                    PS>     $smsg = "UNABLE TO RESOLVE `$ExVersNum from `$ExOPServer.version:$($ExOPServer.version)!" ; 
                    PS>     write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ; 
                    PS>     throw $smsg ; 
                    PS>     break ; 
                    PS> } ; 
                    Demo of parsing the returned Version property, into the proper Exchange Server revision.      
                    .LINK
                    https://github.com/tostka/verb-XXX
                    .LINK
                    https://bitbucket.org/tostka/powershell/
                    .LINK
                    http://mikepfeiffer.net/2010/04/find-exchange-servers-in-the-local-active-directory-site-using-powershell/
                    .LINK
                    https://github.com/SammyKrosoft/Search-AD-Using-Plain-PowerShell/blob/master/Get-SKExchangeServers.psm1
                    .LINK
                    https://github.com/tostka/verb-Ex2010
                    .LINK
                    https://codeandkeep.com/PowerShell-ActiveDirectory-Exchange-Part1/
                    #>
                    [CmdletBinding()]
                    [Alias('Get-ExchangeServerInSite')]
                    PARAM(
                        [Parameter(Position=0,HelpMessage="Array of Server name strings to be filtered against[-Server 'SERVER1','SERVER2']")]
                            [string[]]$Server,
                        [Parameter(Position=1,HelpMessage="Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-SiteName 'SITENAME']")]
                            [Alias('Site')]
                            [string]$SiteName = (gv -name "$($TenOrg)_ADSiteDefaultName" -ea 0).Value,
                        [Parameter(Position=2,HelpMessage="Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']")]
                            [ValidateSet('MBX','CAS','HUB','UM','MBX','EDGE')]
                            [string[]]$RoleNames = @('HUB','CAS'),
                        [Parameter(HelpMessage="Array of msExchCurrentServerRoles 'role' integers to be filtered against (2|4|16|20|32|36|38|54|64|16385|16439)[-Roles @(38,16385)]")]
                            [ValidateSet(2,4,16,20,32,36,38,54,64,16385,16439)]
                            [int[]]$Roles,
                        [Parameter(HelpMessage="Switch to suppress default 'pingable' test (e.g. returns all matches, no testing)[-NoTest]")]
                            [Alias('NoPing')]
                            [switch]$NoTest,
                        [Parameter(HelpMessage="Milliseconds of max timeout to wait during port 80 test (defaults 100)[-SpeedThreshold 500]")]
                            [int]$SpeedThreshold=100,
                        [Parameter(Mandatory=$FALSE,HelpMessage="Tenant Tag (3-letter abbrebiation - defaults to global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']")]
                            [ValidateNotNullOrEmpty()]
                            [string]$TenOrg = $global:o365_TenOrgDefault,
                        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials[-Credentials [credential object]]")]
                            [System.Management.Automation.PSCredential]$Credential
                    ) ;
                    BEGIN{
                        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
                        $Verbose = ($VerbosePreference -eq 'Continue') ;
                        $_sBnr="#*======v $(${CmdletName}): v======" ;
                        $smsg = $_sBnr ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    PROCESS{
                        TRY{
                            $configNC = ([ADSI]"LDAP://RootDse").configurationNamingContext ;
                            $search = new-object DirectoryServices.DirectorySearcher([ADSI]"LDAP://$configNC") ;
                            $bLocalEdge = $false ; 
                            if($Sitename -eq $env:COMPUTERNAME){
                                $smsg = "`$SiteName -eq `$env:COMPUTERNAME:$($SiteName):$($env:COMPUTERNAME)" ; 
                                $smsg += "`nThis computer appears to be an EdgeRole system (non-ADConnected)" ; 
                                $smsg += "`n(Blanking `$sitename and continuing discovery)" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                #$bLocalEdge = $true ; 
                                $SiteName = $null ; 
                
                            } ; 
                            If($siteName){
                                $smsg = "Getting Site: $siteName" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                $objectClass = "objectClass=site" ;
                                $objectName = "name=$siteName" ;
                                $search.Filter = "(&($objectClass)($objectName))" ;
                                $site = ($search.Findall()) ;
                                $siteDN = ($site | select -expand properties).distinguishedname  ;
                            } else {
                                $smsg = "(No -Site specified, resolving site from local machine domain-connection...)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                                else{ write-host -foregroundcolor green "$($smsg)" } ;
                                TRY{$siteDN = [System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().GetDirectoryEntry().distinguishedName}
                                CATCH [System.Management.Automation.MethodInvocationException]{
                                    $ErrTrapd=$Error[0] ;
                                    if(($ErrTrapd.Exception -match 'The computer is not in a site.') -AND $env:ExchangeInstallPath){
                                        $smsg = "$($env:computername) is non-ADdomain-connected" ;
                                        $smsg += "`nand has `$env:ExchangeInstalled populated: Likely Edge Server" ;
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                                        else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        $vers = (get-item "$($env:ExchangeInstallPath)\Bin\Setup.exe").VersionInfo.FileVersionRaw ; 
                                        $props = @{
                                            Name=$env:computername;
                                            FQDN = ([System.Net.Dns]::gethostentry($env:computername)).hostname;
                                            Version = "Version $($vers.major).$($vers.minor) (Build $($vers.Build).$($vers.Revision))" ; 
                                            #"$($vers.major).$($vers.minor)" ; 
                                            #$exServer.serialNumber[0];
                                            Roles = [System.Object[]]64 ;
                                            RoleNames = @('EDGE');
                                            DistinguishedName =  "CN=$($env:computername),CN=Servers,CN=Exchange Administrative Group (FYDIBOHF23SPDLT),CN=Administrative Groups,CN=First Organization,CN=Microsoft Exchange,CN=Services,CN=Configuration,CN={nnnnnnnn-FAKE-GUID-nnnn-nnnnnnnnnnnn}" ;
                                            Site = [System.Object[]]'NOSITE'
                                            ResponseTime = if($rsp){$rsp.ResponseTime} else { 0} ;
                                            NOTE = "This summary object, returned for a non-AD-connected EDGE server, *approximates* what would be returned on an AD-connected server" ;
                                        } ;
                        
                                        $smsg = "(-NoTest:Defaulting Fast:`$true)" ;
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                        $props.add('Fast',$true) ;
                        
                                        return (New-Object -TypeName PsObject -Property $props) ;
                                    }elseif(-not $env:ExchangeInstallPath){
                                        $smsg = "Non-Domain Joined machine, with NO ExchangeInstallPath e-vari: `nExchange is not installed locally: local computer resolution fails:`nPlease specify an explicit -Server, or -SiteName" ;
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        $false | write-output ;
                                    } else {
                                        $smsg = "$($env:computername) is both NON-Domain-joined -AND lacks an Exchange install (NO ExchangeInstallPath e-vari)`nPlease specify an explicit -Server, or -SiteName" ;
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        $false | write-output ;
                                    };
                                } CATCH {
                                    $siteDN =$ExOPsiteDN ;
                                    write-warning "`$siteDN lookup FAILED, deferring to hardcoded `$ExOPsiteDN string in infra file!" ;
                                } ;
                            } ;
                            $smsg = "Getting Exservers in Site:$($siteDN)" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            $search = new-object DirectoryServices.DirectorySearcher([ADSI]"LDAP://$configNC") ;
                            $objectClass = "objectClass=msExchExchangeServer" ;
                            $version = "versionNumber>=1937801568" ;
                            $site = "msExchServerSite=$siteDN" ;
                            $search.Filter = "(&($objectClass)($version)($site))" ;
                            $search.PageSize = 1000 ;
                            [void] $search.PropertiesToLoad.Add("name") ;
                            [void] $search.PropertiesToLoad.Add("msexchcurrentserverroles") ;
                            [void] $search.PropertiesToLoad.Add("networkaddress") ;
                            [void] $search.PropertiesToLoad.Add("msExchServerSite") ;
                            [void] $search.PropertiesToLoad.Add("serialNumber") ;
                            [void] $search.PropertiesToLoad.Add("DistinguishedName") ;
                            $exchServers = $search.FindAll() ;
                            $Aggr = @() ;
                            foreach($exServer in $exchServers){
                                $fqdn = ($exServer.Properties.networkaddress |
                                    Where-Object{$_ -match '^ncacn_ip_tcp:'}).split(':')[1] ;
                                if($NoTest){} else {
                                    $rsp = test-connection $fqdn -count 1 -ea 0 ;
                                } ;
                                $props = @{
                                    Name = $exServer.Properties.name[0]
                                    FQDN=$fqdn;
                                    Version = $exServer.Properties.serialnumber
                                    Roles = $exserver.Properties.msexchcurrentserverroles
                                    RoleNames = $null ;
                                    DistinguishedName = $exserver.Properties.distinguishedname;
                                    Site = @("$($exserver.Properties.msexchserversite -Replace '^CN=|,.*$')") ;
                                    ResponseTime = if($rsp){$rsp.ResponseTime} else { 0} ;
                                } ;
                                $props.RoleNames = switch ($exserver.Properties.msexchcurrentserverroles){
                                    2       {"MBX"}
                                    4       {"CAS"}
                                    16      {"UM"}
                                    20      {"CAS;UM".split(';')}
                                    32      {"HUB"}
                                    36      {"CAS;HUB".split(';')}
                                    38      {"CAS;HUB;MBX".split(';')}
                                    54      {"MBX"}
                                    64      {"EDGE"}
                                    16385   {"CAS"}
                                    16439   {"CAS;HUB;MBX".split(';')}
                                }
                                if($NoTest){
                                    $smsg = "(-NoTest:Defaulting Fast:`$true)" ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                    $props.add('Fast',$true) ;
                                }else {
                                    $props.add('Fast',[boolean]($rsp.ResponseTime -le $SpeedThreshold)) ;
                                };
                                $Aggr += New-Object -TypeName PsObject -Property $props ;
                            } ;
                            $httmp = @{} ;
                            if($Roles){
                                [regex]$rgxRoles = ('(' + (($roles |%{[regex]::escape($_)}) -join '|') + ')') ;
                                $matched =  @( $aggr | ?{$_.Roles -match $rgxRoles}) ;
                                foreach($m in $matched){
                                    if($httmp[$m.name]){} else {
                                        $httmp[$m.name] = $m ;
                                    } ;
                                } ;
                            } ;
                            if($RoleNames){
                                foreach ($RoleName in $RoleNames){
                                    $matched = @($Aggr | ?{$_.RoleNames -contains $RoleName} ) ;
                                    foreach($m in $matched){
                                        if($httmp[$m.name]){} else {
                                            $httmp[$m.name] = $m ;
                                        } ;
                                    } ;
                                } ;
                            } ;
                            if($Server){
                                foreach ($Name in $Server){
                                    $matched = @($Aggr | ?{$_.Name -eq $Name} ) ;
                                    foreach($m in $matched){
                                        if($httmp[$m.name]){} else {
                                            $httmp[$m.name] = $m ;
                                        } ;
                                    } ;
                                } ;
                            } ;
                            if(($httmp.Values| measure).count -gt 0){
                                $Aggr  = $httmp.Values ;
                            } ;
                            $smsg = "Returning $((($Aggr|measure).count|out-string).trim()) match summaries to pipeline..." ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            $Aggr | write-output ;
                        }CATCH{
                            Write-Error $_ ;
                        } ;
                    } ;
                    END{
                        $smsg = "$($_sBnr.replace('=v','=^').replace('v=','^='))" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                } ;
            }
            #endregion GET_ADEXCHANGESERVERTDO ;#*------^ END Function get-ADExchangeServerTDO ^------ ;

            #region load_ADMS  ; #*------v load-ADMS v------
            if(-not(gi function:load-ADMS -ea 0)){
                function load-ADMS {
                    <#
                    .NOTES
                    REVISIONS   :
                    * 4:08 PM 5/14/2025 added alias import-adms
                    .INPUTS
                    None.
                    .OUTPUTS
                    Outputs $True/False load-status
                    .EXAMPLE
                    PS> $ADMTLoaded = load-ADMS ; Write-Debug "`$ADMTLoaded: $ADMTLoaded" ;
                    .EXAMPLE
                    PS> $ADMTLoaded = load-ADMS -Cmdlet get-aduser,get-adcomputer ; Write-Debug "`$ADMTLoaded: $ADMTLoaded" ;
                    Load solely the specified cmdlets from ADMS
                    .EXAMPLE
                    # load ADMS
                    PS> $reqMods+="load-ADMS".split(";") ;
                    PS> if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
                    PS> write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):(loading ADMS...)" ;
                    PS> load-ADMS | out-null ;
                    #load-ADMS -cmdlet get-aduser,Set-ADUser,Get-ADGroupMember,Get-ADDomainController,Get-ADObject,get-adforest | out-null ;
                    Demo a load from the verb-ADMS.ps1 module, with opt specific -Cmdlet set
                    .EXAMPLE
                    PS> if(connect-ad){write-host 'connected'}else {write-warning 'unable to connect'}  ;
                    Variant capturing & testing returned (returns true|false), using the alias name (if don't cap|eat return, you'll get a 'True' in console
                    #>
                    [CmdletBinding()]
                    [Alias('connect-AD')]
                    PARAM(
                        [Parameter(HelpMessage="Specifies an array of cmdlets that this cmdlet imports from the module into the current session. Wildcard characters are permitted[-Cmdlet get-aduser]")]
                        [ValidateNotNullOrEmpty()]$Cmdlet
                    ) ;
                    $Verbose = ($VerbosePreference -eq 'Continue') ;
                    # focus specific cmdlet loads to SPEED them UP!
                    $tMod = "ActiveDirectory" ;
                    $ModsReg=Get-Module -Name $tMod -ListAvailable ;
                    $ModsLoad=Get-Module -name $tMod ;
                    $pltAD=@{Name=$tMod ; ErrorAction="Stop"; Verbose = ($VerbosePreference -eq 'Continue') } ;
                    if($Cmdlet){$pltAD.add('Cmdlet',$Cmdlet) } ;
                    if ($ModsReg) {
                        if (!($ModsLoad)) {
                            $env:ADPS_LoadDefaultDrive = 0 ;
                            import-module @pltAD;
                            if(get-command Add-PSTitleBar -ea 0){
                                Add-PSTitleBar 'ADMS' -verbose:$($VerbosePreference -eq "Continue") ;
                            } ; 
                            return $TRUE;
                        } else {
                            return $TRUE;
                        } # if-E ;
                    } else {
                        Write-Error {"$((get-date).ToString('HH:mm:ss')):($env:computername) does not have AD Mgmt Tools installed!";};
                        return $FALSE
                    } # if-E ;
                } ;
            } ; 
            #endregion load_ADMS ; #*----------^END Function load-ADMS ^---------- 

            #region GET_GCFAST ; #*------v get-GCFast v------
            if(-not(gi function:get-GCFast -ea 0)){
                function get-GCFast {
                    <#
                    .NOTES
                    REVISIONS   :
                    * 2:39 PM 1/23/2025 added -exclude (exclude array of dcs by name), -ServerPrefix (exclude on leading prefix of name) params, added expanded try/catch, swapped out w-h etc for wlt calls
                    .PARAMETER  Domain
                    Which AD Domain [Domain fqdn]
                    .PARAMETER  Site
                    DCs from which Site name (defaults to AD lookup against local computer's Site)
                    .PARAMETER Exclude
                    Array of Domain controller names in target site/domain to exclude from returns (work around temp access issues)
                    .PARAMETER ServerPrefix
                    Prefix string to filter for, in returns (e.g. 'ABC' would only return DCs with name starting 'ABC')
                    .PARAMETER SpeedThreshold
                    Threshold in ms, for AD Server response time(defaults to 100ms)
                    .INPUTS
                    None. Does not accepted piped input.
                    .OUTPUTS
                    Returns one DC object, .Name is name pointer
                    .EXAMPLE
                    PS> get-gcfast -domain dom.for.domain.com -site Site
                    Lookup a Global domain gc, with Site specified (whether in Site or not, will return remote site dc's)
                    .EXAMPLE
                    PS> get-gcfast -domain dom.for.domain.com
                    Lookup a Global domain gc, default to Site lookup from local server's perspective
                    .EXAMPLE    
                    PS> if($domaincontroller = get-gcfast -Exclude ServerBad -Verbose){
                    PS>     write-warning "Changing DomainControler: Waiting 20seconds, for RelSync..." ;
                    PS>     start-sleep -Seconds 20 ;
                    PS> } ; 
                    Demo acquireing a new DC, excluding a caught bad DC, and waiting before moving on, to permit ADRerplication from prior dc to attempt to ensure full sync of changes. 
                    PS> get-gcfast -ServerPrefix ABC -verbose
                    Demo use of -ServerPrefix to only return DCs with servernames that begin with the string 'ABC'
                    .EXAMPLE
                    PS> $adu=$null ;
                    PS> $Exit = 0 ;
                    PS> Do {
                    PS>     TRY {
                    PS>         $adu = get-aduser -id $rmbx.DistinguishedName -server $domainController -Properties $adprops -ea 0| select $adprops ;
                    PS>         $Exit = $DoRetries ;
                    PS>     }CATCH [System.Management.Automation.RuntimeException] {
                    PS>         if ($_.Exception.Message -like "*ResourceUnavailable*") {
                    PS>             $ErrorTrapped=$Error[0] ;
                    PS>             $smsg = "Failed to exec cmd because: $($ErrorTrapped.Exception.Message )" ;
                    PS>             if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    PS>             else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    PS>             # re-quire a new DC
                    PS>             $badDC = $domaincontroller ; 
                    PS>             $smsg = "PROBLEM CONTACTING $(domaincontroller)!:Resource unavailable: $($ErrorTrapped.Exception.Message)" ; 
                    PS>             $smsg += "get-GCFast() an alterate DC" ; 
                    PS>             if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    PS>             else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    PS>             if($domaincontroller = get-gcfast -Exclude $$badDC -Verbose){
                    PS>                 write-warning "Changing DomainController:($($badDC)->$($domaincontroller)):Waiting 20seconds, for ReplSync..." ;
                    PS>                 start-sleep -Seconds 20 ;
                    PS>             } ;                             
                    PS>         }else {
                    PS>             throw $Error[0] ;
                    PS>         } ; 
                    PS>     } CATCH {
                    PS>         $ErrorTrapped=$Error[0] ;
                    PS>         Start-Sleep -Seconds $RetrySleep ;
                    PS>         $Exit ++ ;
                    PS>         $smsg = "Failed to exec cmd because: $($ErrorTrapped)" ;
                    PS>         $smsg += "`nTry #: $Exit" ;
                    PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    PS>         else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    PS>         If ($Exit -eq $DoRetries) {
                    PS>             $smsg =  "Unable to exec cmd!" ;
                    PS>             if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    PS>             else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    PS>         } ;
                    PS>         Continue ;
                    PS>     }  ;
                    PS> } Until ($Exit -eq $DoRetries) ;
                    Retry demo that includes aquisition of a new DC, excluding a caught bad DC, and waiting before moving on, to permit ADRerplication from prior dc to attempt to ensure full sync of changes. 
                    #>
                    [CmdletBinding()]
                    PARAM(
                        [Parameter(Position = 0, Mandatory = $False, HelpMessage = "Optional: DCs from what Site name? (default=Discover)")]
                            [string]$Site,
                        [Parameter(HelpMessage = 'Target AD Domain')]
                            [string]$Domain,
                        [Parameter(HelpMessage = 'Array of Domain controller names in target site/domain to exclude from returns (work around temp access issues)')]
                            [string[]]$Exclude,
                        [Parameter(HelpMessage = "Prefix string to filter for, in returns (e.g. 'ABC' would only return DCs with name starting 'ABC')")]
                            [string]$ServerPrefix,
                        [Parameter(HelpMessage = 'Threshold in ms, for AD Server response time(defaults to 100ms)')]
                            $SpeedThreshold = 100
                    ) ;
                    $Verbose = $($PSBoundParameters['Verbose'] -eq $true)
                    $SpeedThreshold = 100 ;
                    $rgxSpbDCRgx = 'CN=EDCMS'
                    $ErrorActionPreference = 'SilentlyContinue' ; # Set so we don't see errors for the connectivity test
                    $env:ADPS_LoadDefaultDrive = 0 ; 
                    $sName = "ActiveDirectory"; 
                    TRY{
                        if ( -not(Get-Module | Where-Object { $_.Name -eq $sName }) ) {
                            $smsg = "Adding ActiveDirectory Module (`$script:ADPSS)" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            $script:AdPSS = Import-Module $sName -PassThru -ea Stop ;
                        } ;
                        if (-not $Domain) {
                            $Domain = (get-addomain -ea Stop).DNSRoot ; # use local domain
                            $smsg = "Defaulting domain: $Domain";
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        }
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 

                    # Get all the local domain controllers
                    if ((-not $Site)) {
                        # if no site, look the computer's Site Up in AD
                        TRY{
                            $Site = [System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name ;
                            $smsg = "Using local machine Site: $($Site)";
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        } CATCH {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ; 
                    } ;

                    # gc filter
                    #$LocalDCs = Get-ADDomainController -filter { (isglobalcatalog -eq $true) -and (Site -eq $Site) } ;
                    # ISSUE: ==3:26 pm 3/7/2024: NO LOCAL SITE DC'S IN SPB
                    # os: LOGONSERVER=\\EDCMS8100
                    TRY{
                        $LocalDCs = Get-ADDomainController -filter { (isglobalcatalog -eq $true) -and (Site -eq $Site) -and (Domain -eq $Domain) } -ErrorAction STOP
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                    if( $LocalDCs){
                        $smsg = "`Discovered `$LocalDCs:`n$(($LocalDCs|out-string).trim())" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    } elseif($Site -eq 'Spellbrook'){
                        $smsg = "Get-ADDomainController -filter { (isglobalcatalog -eq `$true) -and (Site -eq $($Site)) -and (Domain -eq $($Domain)}"
                        $smsg += "`nFAILED to return DCs, and `$Site -eq Spellbrook:" 
                        $smsg += "`ndiverting to $($rgxSpbDCRgx) dcs in entire Domain:" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        TRY{
                            $LocalDCs = Get-ADDomainController -filter { (isglobalcatalog -eq $true) -and (Domain -eq $Domain) } -EA STOP | 
                                ?{$_.ComputerObjectDN -match $rgxSpbDCRgx } 
                        } CATCH {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ; 
                    } ; 

                    # any dc filter
                    #$LocalDCs = Get-ADDomainController -filter {(Site -eq $Site)} ;

                    $PotentialDCs = @() ;
                    # Check connectivity to each DC against $SpeedThreshold
                    if ($LocalDCs) {
                        foreach ($LocalDC in $LocalDCs) {
                            $TCPClient = New-Object System.Net.Sockets.TCPClient ;
                            $Connect = $TCPClient.BeginConnect($LocalDC.Name, 389, $null, $null) ;
                            $Wait = $Connect.AsyncWaitHandle.WaitOne($SpeedThreshold, $False) ;
                            if ($TCPClient.Connected) {
                                $PotentialDCs += $LocalDC.Name ;
                                $Null = $TCPClient.Close() ;
                            } # if-E
                        } ;
                        if($Exclude){
                            $smsg = "-Exclude specified:`n$((($exclude -join ',')|out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            foreach($excl in $Exclude){
                                $PotentialDCs = $PotentialDCs |?{$_ -ne $excl} ; 
                            } ; 
                        } ; 
                        if($ServerPrefix){
                            $smsg = "-ServerPrefix specified: $($ServerPrefix)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                            $PotentialDCs = $PotentialDCs |?{$_ -match "^$($ServerPrefix)" } ; 
        
                        }
                        write-host -foregroundcolor yellow  
                        $smsg = "`$PotentialDCs: $PotentialDCs";
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $DC = $PotentialDCs | Get-Random ;

                        $smsg = "(returning random domaincontroller from result to pipeline:$($DC)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $DC | write-output  ;
                    } else {
                        write-host -foregroundcolor yellow  "NO DCS RETURNED BY GET-GCFAST()!";
                        write-output $false ;
                    } ;
                }  ; 
            } ; 
            #endregion GET_GCFAST ; #*------^ END get-GCFast ^------

            #endregion FUNCTIONS_INTERNAL ; #*======^ END FUNCTIONS_INTERNAL ^======

            #region CONSTANTS_AND_ENVIRO ; #*======v CONSTANTS_AND_ENVIRO v======
            #region ENVIRO_DISCOVER ; #*------v ENVIRO_DISCOVER v------
            <#
            $Verbose = [boolean]($VerbosePreference -eq 'Continue') ;
            $rPSCmdlet = $PSCmdlet ; # an object that represents the cmdlet or advanced function that's being run. Available on functions w CmdletBinding (& $args will not be available). (Blank on non-CmdletBinding/Non-Adv funcs).
            $rPSScriptRoot = $PSScriptRoot ; # the full path of the executing script's parent directory., PS2: valid only in script modules (.psm1). PS3+:it's valid in all scripts. (Funcs: ParentDir of the file that hosts the func)
            $rPSCommandPath = $PSCommandPath ; # the full path and filename of the script that's being run, or file hosting the funct. Valid in all scripts.
            $rMyInvocation = $MyInvocation ; # populated only for scripts, function, and script blocks.
            # - $MyInvocation.MyCommand.Name returns name of a function, to identify the current command,  name of the current script (pop'd w func name, on Advfuncs)
            # - Ps3+:$MyInvocation.PSScriptRoot : full path to the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
            # - Ps3+:$MyInvocation.PSCommandPath : full path and filename of the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
            #     ** note: above pair contain information about the _invoker or calling script_, not the current script
            $rPSBoundParameters = $PSBoundParameters ;
            #>
            #region PREF_VARI_DUMP ; #*------v PREF_VARI_DUMP v------
            <#$script:prefVaris = @{
                whatifIsPresent = $whatif.IsPresent
                whatifPSBoundParametersContains = $rPSBoundParameters.ContainsKey('WhatIf') ;
                whatifPSBoundParameters = $rPSBoundParameters['WhatIf'] ;
                WhatIfPreferenceIsPresent = $WhatIfPreference.IsPresent ; # -eq $true
                WhatIfPreferenceValue = $WhatIfPreference;
                WhatIfPreferenceParentScopeValue = (Get-Variable WhatIfPreference -Scope 1).Value ;
                ConfirmPSBoundParametersContains = $rPSBoundParameters.ContainsKey('Confirm') ;
                ConfirmPSBoundParameters = $rPSBoundParameters['Confirm'];
                ConfirmPreferenceIsPresent = $ConfirmPreference.IsPresent ; # -eq $true
                ConfirmPreferenceValue = $ConfirmPreference ;
                ConfirmPreferenceParentScopeValue = (Get-Variable ConfirmPreference -Scope 1).Value ;
                VerbosePSBoundParametersContains = $rPSBoundParameters.ContainsKey('Confirm') ;
                VerbosePSBoundParameters = $rPSBoundParameters['Verbose'] ;
                VerbosePreferenceIsPresent = $VerbosePreference.IsPresent ; # -eq $true
                VerbosePreferenceValue = $VerbosePreference ;
                VerbosePreferenceParentScopeValue = (Get-Variable VerbosePreference -Scope 1).Value;
                VerboseMyInvContains = '-Verbose' -in $rPSBoundParameters.UnboundArguments ;
                VerbosePSBoundParametersUnboundArgumentContains = '-Verbose' -in $rPSBoundParameters.UnboundArguments
            } ;
            write-verbose "`n$(($script:prefVaris.GetEnumerator() | Sort-Object Key | Format-Table Key,Value -AutoSize|out-string).trim())`n" ;
            #>
            #endregion PREF_VARI_DUMP ; #*------^ END PREF_VARI_DUMP ^------
            #region RV_ENVIRO ; #*------v RV_ENVIRO v------
            <#
            $pltRvEnv=[ordered]@{
                PSCmdletproxy = $rPSCmdlet ;
                PSScriptRootproxy = $rPSScriptRoot ;
                PSCommandPathproxy = $rPSCommandPath ;
                MyInvocationproxy = $rMyInvocation ;
                PSBoundParametersproxy = $rPSBoundParameters
                verbose = [boolean]($PSBoundParameters['Verbose'] -eq $true) ;
            } ;
            write-verbose "(Purge no value keys from splat)" ;
            $mts = $pltRVEnv.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltRVEnv.remove($_.Name)} ; rv mts -ea 0 -whatif:$false -confirm:$false;
            $smsg = "resolve-EnvironmentTDO w`n$(($pltRVEnv|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $rvEnv = resolve-EnvironmentTDO @pltRVEnv ;
            $smsg = "`$rvEnv returned:`n$(($rvEnv |out-string).trim())" ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            #>
            #endregion RV_ENVIRO ; #*------^ END RV_ENVIRO ^------
            #region NETWORK_INFO ; #*======v NETWORK_INFO v======
            #$NetSummary = resolve-NetworkLocalTDO ;
            if($env:Userdomain){
                switch($env:Userdomain){
                    'CMW'{
                        #$logon_SID = $CMW_logon_SID
                    }
                    'TORO'{
                        #$o365_SIDUpn = $o365_Toroco_SIDUpn ;
                        #$logon_SID = $TOR_logon_SID ;
                    }
                    $env:COMPUTERNAME{
                        $smsg = "%USERDOMAIN% -EQ %COMPUTERNAME%: $($env:computername) => non-domain-connected, likely edge role Ex server!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        if($NetSummary.Workgroup){
                            $smsg = "WorkgroupName:$($NetSummary.Workgroup)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        } ;
                    } ;
                    default{
                        $smsg = "$($env:userdomain):UNRECOGIZED/UNCONFIGURED USER DOMAIN STRING!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        THROW $SMSG
                        BREAK ;
                    }
                } ;
            } ;  # $env:Userdomain-E
            #endregion NETWORK_INFO ; #*======^ END NETWORK_INFO ^======
            #region TEST_EXOPLOCAL ; #*------v TEST_EXOPLOCAL v------
            #
            #$XoPSummary = test-LocalExchangeInfoTDO ;
            write-verbose "Expand returned NoteProperty properties into matching local variables" ;
            if($host.version.major -gt 2){
                $XoPSummary.PsObject.Properties | ?{$_.membertype -eq 'NoteProperty'} | foreach-object{set-variable -name $_.name -value $_.value -verbose -whatif:$false -Confirm:$false ;} ;
            }else{
                write-verbose "Psv2 lacks the above expansion capability; just create simpler variable set" ;
                $ExVers = $XoPSummary.ExVers ; $isLocalExchangeServer = $XoPSummary.isLocalExchangeServer ; $IsEdgeTransport = $XoPSummary.IsEdgeTransport ;
            } ;
            #endregion TEST_EXOPLOCAL ; #*------^ END TEST_EXOPLOCAL ^------
            #

            #endregion ENVIRO_DISCOVER ; #*------^ END ENVIRO_DISCOVER ^------
            #region TLS_LATEST_FORCE ; #*------v TLS_LATEST_FORCE v------
            $CurrentVersionTlsLabel = [Net.ServicePointManager]::SecurityProtocol ; # Tls, Tls11, Tls12 ('Tls' == TLS1.0)  ;
            write-verbose "PRE: `$CurrentVersionTlsLabel : $($CurrentVersionTlsLabel )" ;
            # psv6+ already covers, test via the SslProtocol parameter presense
            if ('SslProtocol' -notin (Get-Command Invoke-RestMethod).Parameters.Keys) {
                $currentMaxTlsValue = [Math]::Max([Net.ServicePointManager]::SecurityProtocol.value__,[Net.SecurityProtocolType]::Tls.value__) ;
                write-verbose "`$currentMaxTlsValue : $($currentMaxTlsValue )" ;
                $newerTlsTypeEnums = [enum]::GetValues('Net.SecurityProtocolType') | Where-Object { $_ -gt $currentMaxTlsValue }
                if($newerTlsTypeEnums){
                    write-verbose "Appending upgraded/missing TLS `$enums:`n$(($newerTlsTypeEnums -join ','|out-string).trim())" ;
                } else {
                    write-verbose "Current TLS `$enums are up to date with max rev available on this machine" ;
                };
                $newerTlsTypeEnums | ForEach-Object {
                    [Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor $_
                } ;
            } ;
            #endregion TLS_LATEST_FORCE ; #*------^ END TLS_LATEST_FORCE ^------

            #region COMMON_CONSTANTS ; #*------v COMMON_CONSTANTS v------

            if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
            if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
            if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
            if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval
            if(-not $ThrottleMs){$ThrottleMs = 50 ;}
            if(-not $rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,
            if(-not $rgxCertThumbprint){$rgxCertThumbprint = '[0-9a-fA-F]{40}' } ; # if it's a 40char hex string -> cert thumbprint
            if(-not $rgxSmtpAddr){$rgxSmtpAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; } ; # email addr/UPN
            if(-not $rgxDomainLogon){$rgxDomainLogon = '^[a-zA-Z][a-zA-Z0-9\-\.]{0,61}[a-zA-Z]\\\w[\w\.\- ]+$' } ; # DOMAIN\samaccountname
            if(-not $exoMbxGraceDays){$exoMbxGraceDays = 30} ;
            if(-not $XOConnectionUri ){$XOConnectionUri = 'https://outlook.office365.com'} ;
            if(-not $SCConnectionUri){$SCConnectionUri = 'https://ps.compliance.protection.outlook.com'} ;
            #$rgxADDistNameGAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 1 ) -join ',')"
            #$rgxADDistNameAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 2 ) -join ',')"

            write-verbose "Coerce configured but blank Resultsize to Unlimited" ;
            if(get-variable -name resultsize -ea 0){
                if( ($null -eq $ResultSize) -OR ('' -eq $ResultSize) ){$ResultSize = 'unlimited' }
                elseif($Resultsize -is [int]){} else {throw "Resultsize must be an integer or the string 'unlimited' (or blank)"} ;
            } ;
            #$ComputerName = $env:COMPUTERNAME ;
            #$NoProf = [bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};
            # XXXMeta derived constants:
            # - AADU Licensing group checks
            # calc the rgxLicGrpName fr the existing $xxxmeta.rgxLicGrpDN: (get-variable tormeta).value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
            #$rgxLicGrpName = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
            # use the dn vers LicGrouppDN = $null ; # | ?{$_ -match $tormeta.rgxLicGrpDN}
            #$rgxLicGrpDN = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN
            # email trigger vari, it will be semi-delimd list of mail-triggering events
            $script:PassStatus = $null ;
            # TenOrg or other looped-specific PassStatus (auto supported by 7pswlt)
            #New-Variable -Name PassStatus_$($tenorg) -scope Script -Value $null ;
            [array]$SmtpAttachment = $null ;
            #write-verbose "start-Timer:Master" ;
            $swM = [Diagnostics.Stopwatch]::StartNew() ;
            # $ByPassLocalExchangeServerTest = $true # rough in, code exists below for exempting service/regkey testing on this variable status. Not yet implemented beyond the exemption code, ported in from orig source.
            #endregion COMMON_CONSTANTS ; #*------^ END COMMON_CONSTANTS ^------

            #region LOCAL_CONSTANTS ; #*------v LOCAL_CONSTANTS v------
            # BELOW TRIGGERS/DRIVES TEST_MODS: array of: "[modname];[modDLUrl,or pscmdline install]"
            <#$tDepModules = @("Microsoft.Graph.Authentication;https://www.powershellgallery.com/packages/Microsoft.Graph/",
            "ExchangeOnlineManagement;https://www.powershellgallery.com/packages/ExchangeOnlineManagement/",
            "ActiveDirectory;get-windowscapability -name RSAT* -Online | ?{$_.name -match 'Rsat\.ActiveDirectory'} | %{Add-WindowsCapability -online -name $_.name}"
            #,"AzureAD;https://www.powershellgallery.com/packages/AzureAD"
            ) ;
            #>
            $tDepModules = @() ; 
            if($useEXO){$tDepModules += @("ExchangeOnlineManagement;https://www.powershellgallery.com/packages/ExchangeOnlineManagement/")} ; 
            if($UseMSOL){$tDepModules += @("MSOnline;https://www.powershellgallery.com/packages/MSOnline/")} ; 
            if($UseAAD){$tDepModules += @("AzureAD;https://www.powershellgallery.com/packages/AzureAD/")} ; 
            if($useEXO){$tDepModules += @("ExchangeOnlineManagement;https://www.powershellgallery.com/packages/ExchangeOnlineManagement/")} ; 
            if($UseMG){$tDepModules += @("Microsoft.Graph.Authentication;https://www.powershellgallery.com/packages/Microsoft.Graph/")} ; 
            if($UseOPAD){$tDepModules += @("ActiveDirectory;get-windowscapability -name RSAT* -Online | ?{$_.name -match 'Rsat\.ActiveDirectory'} | %{Add-WindowsCapability -online -name $_.name}")} ; 
       
            #region ENCODED_CONTANTS ; #*------v ENCODED_CONTANTS v------
            # ENCODED CONsTANTS & SUPPORT FUNCTIONS:
            #region 2B4 ; #*------v 2B4 v------
            if(-not (get-command 2b4 -ea 0)){function 2b4{[CmdletBinding()][Alias('convertTo-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str|%{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))}  };} ; } ;
            #endregion 2B4 ; #*------^ END 2B4 ^------
            #region 2B4C ; #*------v 2B4C v------
            # comma-quoted return
            if(-not (get-command 2b4c -ea 0)){function 2b4c{ [CmdletBinding()][Alias('convertto-Base64StringCommaQuoted')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ;BEGIN{$outs = @()} PROCESS{[array]$outs += $str | %{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))} ; } END {'"' + $(($outs) -join '","') + '"' | out-string | set-clipboard } ; } ; } ;
            #endregion 2B4C ; #*------^ END 2B4C ^------
            #region FB4 ; #*------v FB4 v------
            # DEMO: $SitesNameList = 'THluZGFsZQ==','U3BlbGxicm9vaw==','QWRlbGFpZGU=' | fb4 ;
            if(-not (get-command fb4 -ea 0)){function fb4{[CmdletBinding()][Alias('convertFrom-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str | %{ [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($_)) }; } ; } ; };
            #endregion FB4 ; #*------^ END FB4 ^------
            # FOLLOWING CONSTANTS ARE USED FOR DEPENDANCY-LESS CONNECTIONS
            if(-not $CMW_logon_SID){$CMW_logon_SID = 'Q01XXGQtdG9kZC5rYWRyaWU=' | fb4 } ;
            if(-not $o365_Toroco_SIDUpn){$o365_Toroco_SIDUpn = 'cy10b2RkLmthZHJpZUB0b3JvLmNvbQ==' | fb4 } ;
            if(-not $TOR_logon_SID){$TOR_logon_SID = 'VE9ST1xrYWRyaXRzcw==' | fb4 } ;

            #endregion ENCODED_CONTANTS ; #*------^ END ENCODED_CONTANTS ^------

            #endregion CONSTANTS_AND_ENVIRO ; #*======^ CONSTANTS_AND_ENVIRO ^======

            #region SUBMAIN ; #*======v SUB MAIN v======

            #region TEST_MODS ; #*------v TEST_MODS v------
            if($tDepModules){
                foreach($tmod in $tDepModules){
                    $tmodName,$tmodURL = $tmod.split(';') ;
                    if (-not(Get-Module $tmodName -ListAvailable)) {
                        $smsg = "This script requires a recent version of the $($tmodName) PowerShell module. Download it here:`n$($tmodURL )";
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn }
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        return
                    } else {
                        write-verbose "$tModName confirmed available" ;
                    } ;
                } ;
            } ;
            #endregion TEST_MODS ; #*------^ END TEST_MODS ^------

            # return status obj
            <#
            $ret_ccOPs = [ordered]@{
                CredentialOP = $null ; 
                # OP switches
                hasExOP = $false ;
                xOPPssession = $null ; 
                ExopVers = $null ;
                hasForestWide = $false ;
                AdGcFwide = $null ; 
                AdDomainController = $null ; 
                hasOPAD = $false ;
                ADForestRoot = $null ; 
                ADforestDom = $null ; 
                ADUPNSuffixDefault = $null ; 
            } ; 
            #>
            if($host.version.major -ge 3){$ret_ccOPs=[ordered]@{Dummy = $null ;} }
            else {$ret_ccOPs = $ret_ccOPs = @{Dummy = $null ;} } ;
            if($ret_ccOPs.keys -contains 'dummy'){$ret_ccOPs.remove('Dummy') };
            $fieldsBoolean = 'hasExOP','hasForestWide','hasOPAD' | select -unique | sort ; $fieldsBoolean | % { $ret_ccOPs.add($_,$false) } ;
            $fieldsnull = 'CredentialOP','ExopVers','AdGcFwide','AdDomainController','ADForestRoot','ADforestDom','ADUPNSuffixDefault' | select -unique | sort ; $fieldsnull | % { $ret_ccOPs.add($_,$null) } ;
            
            # PRETUNE STEERING separately *before* pasting in balance of region
            # THIS BLOCK DEPS ON VERB-* FANCY CRED/AUTH HANDLING MODULES THAT *MUST* BE INSTALLED LOCALLY TO FUNCTION
            # NOTE: *DOES* INCLUDE *PARTIAL* DEP-LESS $useExopNoDep=$true OPT THAT LEVERAGES Connect-ExchangeServerTDO, VS connect-ex2010 & CREDS ARE ASSUMED INHERENT TO THE ACCOUNT)
            # Connect-ExchangeServerTDO HAS SUBSTANTIAL BENEFIT, OF WORKING SEAMLESSLY ON EDGE SERVER AND RANGE OF DOMAIN-=CONNECTED EXOP ROLES
            <#
            $useO365 = $true ;
            $useEXO = $true ;
            $UseOP=$true ;
            $UseExOP=$true ;
            $useExopNoDep = $true ; # switch to use Connect-ExchangeServerTDO, vs connect-ex2010 (creds are assumed inherent to the account)
            $ExopVers = 'Ex2010' # 'Ex2019','Ex2016','Ex2013','Ex2010','Ex2007','Ex2003','Ex2000', Null for All versions
            if($Version){
                $ExopVers = $Version ; #defer to local script $version if set
            } ;
            $useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
            $UseOPAD = $true ;
            $UseMSOL = $false ; # should be hard disabled now in o365
            $UseAAD = $false  ;
            $UseMG = $true ;
            #>
            
            if($env:userdomain -eq $env:computername){
                $isNonDomainServer = $true ;
                $UseOPAD = $false ;
            }
            if($IsEdgeTransport){
                $UseExOP = $true ;
                if($IsEdgeTransport -AND $psise){
                    $smsg = "powershell_ISE UNDER Exchange Edge Transport role!"
                    $smsg += "`nThis script is likely to fail the get-messagetrackingLog calls with Access Denied errors"
                    $smsg += "`nif run with this combo."
                    $smsg += "`nEXIT POWERSHELL ISE, AND RUN THIS DIRECTLY UNDER EMS FOR EDGE USE";
                    $smsg += "`n(bug appears to be a conflict in Remote EMS v EMS access permissions, not resolved yet)" ;
                    write-warning $msgs ;
                } ;
            } ;
            $UseOP = [boolean]($UseOP -OR $UseExOP -OR $UseOPAD) ;
            #*------^ END STEERING VARIS ^------
            # assert Org from Credential specs (if not param'd)
            # 1:36 PM 7/7/2023 and revised again -  revised the -AND, for both, logic wasn't working
            if($TenOrg){
                $smsg = "Confirmed populated `$TenOrg" ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            } elseif(-not($tenOrg) -and $Credential){
                $smsg = "(unconfigured `$TenOrg: asserting from credential)" ;
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                if((get-command get-TenantTag).Parameters.keys -contains 'silent'){
                    $TenOrg = get-TenantTag -Credential $Credential -silent ;;
                }else {
                    $TenOrg = get-TenantTag -Credential $Credential ;
                }
            } else {
                # if not using Credentials or a TargetTenants/TenOrg loop, default the $TenOrg on the $env:USERDOMAIN
                $smsg = "(unconfigured `$TenOrg & *NO* `$Credential: fallback asserting from `$env:USERDOMAIN)" ;
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                switch -regex ($env:USERDOMAIN){
                    ([regex]('(' + (( @($TORMeta.legacyDomain,$CMWMeta.legacyDomain)  |foreach-object{[regex]::escape($_)}) -join '|') + ')')).tostring() {$TenOrg = $env:USERDOMAIN.substring(0,3).toupper() } ;
                    $TOLMeta.legacyDomain {$TenOrg = 'TOL' }
                    $env:COMPUTERNAME {
                        # non-domain-joined, no domain, but the $NetSummary.fqdn has a dns suffix that can be steered.
                        if($NetSummary.fqdn){
                            switch -regex (($NetSummary.fqdn.split('.') | select -last 2 ) -join '.'){
                              'toro\.com$' {$tenorg = 'TOR' ; } ;
                              '(charlesmachineworks\.com|cmw\.internal)$' { $TenOrg = 'CMW'} ;
                              '(torolab\.com|snowthrower\.com)$'  { $TenOrg = 'TOL'} ;
                              default {throw "UNRECOGNIZED DNS SUFFIX!:$(($NetSummary.fqdn.split('.') | select -last 2 ) -join '.')" ; break ; } ;
                            } ;
                        }else{
                            throw "NIC.ip $($NetSummary.ipaddress) does not PTR resolve to a DNS A with a full fqdn!" ;
                        } ;
                    } ;
                    default {throw "UNRECOGNIZED `$env:USERDOMAIN!:$($env:USERDOMAIN)" ; exit ; } ;
                } ;
            } ;
            
            #region GENERIC_EXOP_CREDS_N_SRVR_CONN #*------v GENERIC EXOP CREDS N SRVR CONN BP v------
            # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
            #$UseOP=$true ; 
            #$UseExOP=$true ;
            #$useExopNoDep = $true # switch to use Connect-ExchangeServerTDO, vs connect-ex2010 (creds are assumed inherent to the account) 
            #$useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
            <# no onprem dep
            if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
                $UseOP = $UseExOP = $true ;
                $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ;
                if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            } else {
                $UseOP = $UseExOP = $false ;
                $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ;
                if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            } ;
            #>
            if($UseOP){
                if($env:userdomain -eq (get-variable "$($Tenorg)Meta" -ea 0).value.legacydomain){
                    $smsg = "(confirmed alignment: `$env:userdomain -eq $($Tenorg)Meta.legacydomain$((get-variable "$($Tenorg)Meta" -ea 0).value.legacydomain))" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                }else{
                    $smsg = "-TenOrg:$($TenOrg) specified, but LOCAL LOGON IS IN $($env:USERDOMAIN)!" ; 
                    $smsg += "`nTHERE _CAN BE NO_ ONPREM EXCHANGE CONNECTION FROM THE LOGON DOMAIN TO THE ONPREM $($TenOrg) ONPREM DOMAIN! (fw blocked)" ;
                    $SMSG += "`nSETTING `$useOP:`$false & `$UseOPAD: `$false!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $UseOP = $false ; $UseOPAD = $false ; 
                }
            }
            if($UseOP){
                <#if($useExopNoDep){
                    # Connect-ExchangeServerTDO use: creds are implied from the PSSession creds; assumed to have EXOP perms
                    # 3:14 PM 1/9/2025 no they aren't, it still wants explicit creds to connect - I've just been doing rx10 and pre-initiating
                } else {
                #>
                # useExopNoDep: at this point creds are *not* implied from the PS context creds. So have to explicitly pass in $creds on the new-Pssession etc, 
                # so we always need the EXOP creds block, or at worst an explicit get-credential prompt to gather when can't find in enviro or profile. 
                #*------v GENERIC EXOP CREDS N SRVR CONN BP v------
                if($TenOrg -ne 'CMW'){
                    if(get-item function:get-HybridOPCredentials -ea STOP){
                        # do the OP creds too
                        $OPCred=$null ;
                        # default to the onprem svc acct
                        # userrole='ESVC','SID'
                        #$pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
                        # userrole='SID','ESVC'
                        #$pltGHOpCred=@{TenOrg=$TenOrg ;userrole='SID','ESVC'; verbose=$($verbose)} ;
                        # defer to param
                        $pltGHOpCred=@{TenOrg=$TenOrg ;userrole=$userRole ; verbose=$($verbose)} ;
                        $smsg = "get-HybridOPCredentials w`n$(($pltGHOpCred|out-string).trim())" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                            # make it script scope, so we don't have to predetect & purge before using new-variable
                            if(get-Variable -Name "cred$($tenorg)OP" -scope Script -ea 0 ){ remove-Variable -Name "cred$($tenorg)OP" -scope Script } ;
                            New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred -whatif:$false -confirm:$false; ;
                            $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } else {
                            $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                            $script:PassStatus += $statusdelta ;
                            set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                            $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                            Break ;
                        } ;
                        $smsg= "Using OnPrem/EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        <### CALLS ARE IN FORM: (cred$($tenorg))
                        $pltRX10 = @{
                            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                            #verbose = $($verbose) ;
                            Verbose = $FALSE ; 
                        } ;
                        $1stConn = $false ; # below uses silent suppr for both x10 & xo!
                        if($1stConn){
                            $pltRX10.silent = $pltRXO.silent = $false ;
                        } else {
                            $pltRX10.silent = $pltRXO.silent =$true ;
                        } ;
                        if($pltRX10){ReConnect-Ex2010 @pltRX10 }
                        else {ReConnect-Ex2010 }
                        #$pltRx10 creds & .username can also be used for local ADMS connections
                        ###>
                        $pltRX10 = @{
                            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                            #verbose = $($verbose) ;
                            Verbose = $FALSE ; 
                        } ;
                        if($silent -AND ((get-command Reconnect-Ex2010).Parameters.keys -contains 'silent')){
                            $pltRX10.add('Silent',[boolean]$silent) ;
                        } ;
                        # defer cx10/rx10, until just before get-recipients qry
                        # connect to ExOP X10
                    } elseif((get-variable "$($Tenorg)Meta" -ea 0).value.OP_SIDAcct){
                        $smsg = "Unable to resolve stock creds: Input suitable creds for OnPrem $($TenOrg): (defaulting to discovered OP_SIDAcct)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        $pltRX10 = @{
                            Credential = Get-Credential -Credential (get-variable "$($Tenorg)Meta" -ea 0).value.OP_SIDAcct ; ;
                            #verbose = $($verbose) ;
                            Verbose = $FALSE ; 
                        } ;
                        if($silent -AND ((get-command Reconnect-Ex2010).Parameters.keys -contains 'silent')){
                            $pltRX10.add('Silent',[boolean]$silent) ;
                        } ;
                    }else{
                        $smsg = "Unable to resolve stock creds: Input suitable creds for OnPrem $($TenOrg):" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $pltRX10 = @{
                            Credential = Get-Credential ; 
                            #verbose = $($verbose) ;
                            Verbose = $FALSE ; 
                        } ;
                        if($silent -AND ((get-command Reconnect-Ex2010).Parameters.keys -contains 'silent')){
                            $pltRX10.add('Silent',[boolean]$silent) ;
                        } ;
                    }; 
                } ; # skip above on CMW, the mods aren't installed
                
            } else {
                $smsg = "(`$useOP:$($UseOP))" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            }  ;  # if-E $UseOP
            #endregion GENERIC_EXOP_CREDS_N_SRVR_CONN #*------^ END GENERIC EXOP CREDS N SRVR CONN BP ^------

            if($pltRX10.Credential){
                $ret_ccOPs.CredentialOP = $pltRX10.Credential ; 
            }else{
                if($UseOP -eq $false){
                    $smsg = "-UseOP:$($useOP): Disabled OnPrem (cross-org?): Expected blank credential set fOR Connect-ExchangeServerTDO!" ; 
                    $smsg += "`n$(($pltRX10|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                } else {
                    $smsg = "UNABLE TO RESOLVE A CREDENTIAL SET FOR Connect-ExchangeServerTDO!" ; 
                    $smsg += "`n$(($pltRX10|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    throw $smsg ; 
                    BREAK ; 
                } ; 
            } ; 

        } ; # BEG-E
        PROCESS {

            #region SERVICE_CONNECTIONS #*======v SERVICE_CONNECTIONS v======

            #region USEOP ; #*------v USEOP v------
            if($UseOP){
                #region USEEXOP ; #*------v USEEXOP v------
                if($useEXOP){
                    if($useExopNoDep){ 
                        $smsg = "(Using ExOP:Connect-ExchangeServerTDO(), connect to local ComputerSite)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;           
                        TRY{
                            $Site=[System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name 
                        }CATCH{$Site=$env:COMPUTERNAME} ;
                        $pltCcX10=[ordered]@{
                            siteName = $Site ;
                            RoleNames = @('HUB','CAS') ;
                            verbose  = $($rPSBoundParameters['Verbose'] -eq $true)
                            Credential = $pltRX10.Credential ; 
                        } ;
                        if($ExopVers){
                            $pltCcX10.add('Version',$ExopVers) ; 
                            write-verbose "(Adding specified -Version:$($ExopVers) to `$pltCcX10)"
                        } ; 
                        # 5:15 PM 4/22/2025 on CMW, have to patch version to Ex2016
                        #if($env:userdomain -eq 'CMW'){
                        if($TenOrg -eq 'CMW'){
                            if($pltCcX10.keys -contains 'Version'){
                                $pltCcX10.version = 'Ex2016' ; 
                            } else { $pltCcX10.add('version','Ex2016') } ;
                        } ; 
                        $smsg = "Connect-ExchangeServerTDO w`n$(($pltCcX10|out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #$PSSession = Connect-ExchangeServerTDO -siteName $Site -RoleNames @('HUB','CAS') -verbose ; 
                        $PSSession = Connect-ExchangeServerTDO @pltCcX10 ; 
                    } else {
                        if($pltRX10){
                            #ReConnect-Ex2010XO @pltRX10 ;
                            ReConnect-Ex2010 @pltRX10 ;
                        } else { Reconnect-Ex2010 ; } ;
                        #Add-PSSnapin -Name 'Microsoft.Exchange.Management.PowerShell.SnapIn'
                        #TK: add: test Exch & AD functional connections
                        TRY{
                            if(get-command -module (get-module |?{$_.name -like 'tmp_*'}).name -name 'get-OrganizationConfig'){} else {
                                $smsg = "(mangled Ex10 conn: dx10,rx10...)" ; 
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                disconnect-ex2010 ; reconnect-ex2010 ; 
                            } ; 
                            if(-not ($OrgName = ((get-OrganizationConfig).DistinguishedName.split(',') |?{$_ -like 'DC=*'}) -join '.' -replace 'DC=','')){
                                $smsg = "Missing Exchange Connection! (no (Get-OrganizationConfig).name returned)" ; 
                                throw $smsg ; 
                                $smsg | write-warning  ; 
                            } else{
                                $ret_ccOPs.hasExOP = $true ;
                                $ret_ccOPs.xOPPssession = $PSSession ; 

                            } ;  
                        } CATCH {
                            $ErrTrapd=$Error[0] ;
                            $smsg = $ErrTrapd ;
                            $smsg += "`n";
                            $smsg += $ErrTrapd.Exception.Message ;
                            if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            CONTINUE ;
                        } ;
                    }
                } ; 
                #endregion USEEXOP ; #*------^ END USEEXOP ^------
                #region USEFORESTWIDE ; #*------v USEFORESTWIDE v------
                if($useForestWide){
                    #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT v------
                    $smsg = "(`$useForestWide:$($useForestWide)):Enabling EXoP Forestwide)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = 'Set-AdServerSettings -ViewEntireForest `$True' ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Set-AdServerSettings -ViewEntireForest $True
                    if((get-AdServerSettings).viewentireforest -eq $true){ ;
                        $ret_ccOPs.hasForestWide = $true ;
                    }else{
                        $ret_ccOPs.hasForestWide = $false ;
                    } ;
                    #endregion  ; #*------^ END OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT ^------
                } ;
                #endregion USEFORESTWIDE ; #*------^ END USEFORESTWIDE ^------
            } else {
                $smsg = "(`$useOP:$($UseOP))" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            }  ;  # if-E $UseOP
            #endregion USEOP ; #*------^ END USEOP ^------

            #region UseOPAD #*------v UseOPAD v------
            if($UseOP -OR $UseOPAD){
                if($isNonDomainServer){
                    $smsg = "(non-Domain-connected server:Skipping GENERIC ADMS CONN) "  
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                }else {
                    #region GENERIC_ADMS_CONN_&_XO #*------v GENERIC ADMS CONN & XO  v------
                    $smsg = "(loading ADMS...)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    # always capture load-adms return, it outputs a $true to pipeline on success
                    if($ADMTLoaded = load-ADMS -Verbose:$FALSE){
                        $ret_ccOPs.hasOPAD = $true ; 
                    }
                    # 9:32 AM 4/20/2023 trimmed disabled/fw-borked cross-org code
                    TRY {
                        if(-not($ADForestRoot = Get-ADDomain  -ea STOP).DNSRoot){
                            $smsg = "Missing AD Connection! (no (Get-ADDomain).DNSRoot returned)" ; 
                            throw $smsg ; 
                            $smsg | write-warning  ; 
                            $ret_ccOPs.hasOPAD = $false ; 
                            $ret_ccOPs.ADForestRoot = $null ; 
                        } else{
                            $ret_ccOPs.hasOPAD = $true ; 
                            $ret_ccOPs.ADForestRoot = $ADForestRoot ;  
                        } ; 
                        $objforest = get-adforest -ea STOP ; 
                        # Default new UPNSuffix to the UPNSuffix that matches last 2 elements of the forestname.
                        $forestdom = $UPNSuffixDefault = $objforest.UPNSuffixes | ?{$_ -eq (($objforest.name.split('.'))[-2..-1] -join '.')} ; 
                        $ret_ccOPs.ADforestDom = $forestdom ; 
                        $ret_ccOPs.ADUpnSuffixDefault = $forestdom  ; 
                        if($useForestWide){
                            #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE AD GC QRY SUPPORT v------
                            $smsg = "(`$useForestWide:$($useForestWide)):Enabling AD Forestwide)" ; 
                            if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $smsg = 'Set-AdServerSettings -ViewEntireForest `$True' ;
                            if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #TK 9:44 AM 10/6/2022 need org wide for rolegrps in parent dom (only for onprem RBAC, not EXO)
                            if($GcFwide = "$((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):3268"){
                                $ret_ccOPs.AdGcFwide = $GcFwide ; 
                            }else{
                                $smsg = "UNABLE TO RESOLVE A ForestWide GlobalDomainController (port 3268)!" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            }
                            #endregion  ; #*------^ END  OPTIONAL CODE TO ENABLE FOREST-WIDE AD GC QRY SUPPORT  ^------
                        } ;    
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = $ErrTrapd ;
                        $smsg += "`n";
                        $smsg += $ErrTrapd.Exception.Message ;
                        if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        CONTINUE ;
                    } ;        
                    #endregion GENERIC_ADMS_CONN_&_XO #*------^ END GENERIC ADMS CONN & XO ^------
                } ; 
            } else {
                $smsg = "(`$UseOPAD:$($UseOPAD))" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            }  ;
            #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
            #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller = get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
            # use new get-GCFastXO cross-org dc finde
            # default to Op_ExADRoot forest from $TenOrg Meta
            #if($UseOP -AND -not $domaincontroller){
            if($UseOP -AND -not $isNonDomainServer -AND -not (get-variable domaincontroller -ea 0)){
                #$domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((get-variable -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};
                # need to debug the above, credential issue?
                # just get it done
                $domaincontroller = get-GCFast
            }elseif($isNonDomainServer){
                $smsg = "(non-ADDomain-connected, skipping divert to EXO group resolution)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            }  else { 
                # have to defer to get-azuread, or use EXO's native cmds to poll grp members
                # TODO 1/15/2021
                $useEXOforGroups = $true ; 
                $smsg = "$($TenOrg):HAS NO ON-PREM ACTIVEDIRECTORY, DEFERRING ALL GROUP ACCESS & MGMT TO NATIVE EXO CMDS!" ; 
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
            if(-not $isNonDomainServer -AND ($UseOPAD -OR $UseOP) -AND $useForestWide -AND -not $GcFwide){
                #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT: v------
                $smsg = "`$GcFwide = Get-ADDomainController -Discover -Service GlobalCatalog" ;
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $GcFwide = "$((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):3268" ;
                $smsg = "Discovered `$GcFwide:$($GcFwide)" ; 
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #endregion  ; #*------^ END OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT ^------
            } ;
            if($domaincontroller){
                $ret_ccOPs.AdDomainController = $domaincontroller ; 
            } ; 
            #endregion UseOPAD #*------^ END UseOPAD ^------

            <#
            if($VerbosePreference = "Continue"){
                $VerbosePrefPrior = $VerbosePreference ;
                $VerbosePreference = "SilentlyContinue" ;
                $verbose = ($VerbosePreference -eq "Continue") ;
            } ;
            disconnect-exo ;
            if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
            else { reconnect-EXO @pltRXOC } ;
            # reenable VerbosePreference:Continue, if set, during mod loads
            if($VerbosePrefPrior -eq "Continue"){
                $VerbosePreference = $VerbosePrefPrior ;
                $verbose = ($VerbosePreference -eq "Continue") ;
            } ;
            #>
            
            #endregion SERVICE_CONNECTIONS #*======^ END SERVICE_CONNECTIONS ^======

        } ; # PROC-E
        END {
            $swM.Stop() ;
            $smsg = ("Elapsed Time: {0:dd}d {0:hh}h {0:mm}m {0:ss}s {0:fff}ms" -f $swM.Elapsed) ;
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            <#
            # return status obj
            $ret_ccOPs = [ordered]@{
                CredentialOP = $null ; 
                # OP switches
                hasExOP = $false ;
                ExopVers = $null ;
                hasForestWide = $false ;
                hasOPAD = $false ;
                #
            } ; 
            #>
            $smsg = "Returning connection summary to pipeline:`n$(($ret_ccOPs|out-string).trim())`n" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            [pscustomobject]$ret_ccOPs | write-output ;
        } ; # END-E
    } ;
}

#*------^ connect-OPServices.ps1 ^------


#*------v cx10cmw.ps1 v------
function cx10cmw {
    <#
    .SYNOPSIS
    cx10cmw - Connect-EX2010 to specified on-prem Exchange
    .DESCRIPTION
    Connect-EX2010 - Connect-EX2010 to specified on-prem Exchange
    .EXAMPLE
    cx10cmw
    #>
    [CmdletBinding()] 
    [Alias('cxOPcmw')]
    Param()
    $Verbose = ($VerbosePreference -eq 'Continue') ;
    $pltGHOpCred=@{TenOrg="CMW" ;userrole=@('ESVC','LSVC','SID') ;verbose=$($verbose)} ;
    if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
        Connect-EX2010 -cred $OPCred -Verbose:($VerbosePreference -eq 'Continue') ; 
    } else {
        $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole $($UserRole -join '|') value!"
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
        exit ;
    } ;
}

#*------^ cx10cmw.ps1 ^------


#*------v cx10tol.ps1 v------
function cx10tol {
    <#
    .SYNOPSIS
    cx10tol - Connect-EX2010 to specified on-prem Exchange
    .DESCRIPTION
    Connect-EX2010 - Connect-EX2010 to specified on-prem Exchange
    .NOTES
    REVISIONS   :
    # 11:20 AM 4/21/2021 fixed/suppressed noisy verbose calls
    .EXAMPLE
    cx10tol
    #>
    [CmdletBinding()] 
    [Alias('cxOPtol')]
    Param()
    $Verbose = ($VerbosePreference -eq 'Continue') ;
    $pltGHOpCred=@{TenOrg="TOL" ;userrole=@('ESVC','LSVC','SID') ;verbose=$($verbose)} ;
    if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
        Connect-EX2010 -cred $OPCred #-Verbose:($VerbosePreference -eq 'Continue') ; 
    } else {
        $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole $($UserRole -join '|') value!"
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
        exit ;
    } ;
}

#*------^ cx10tol.ps1 ^------


#*------v cx10tor.ps1 v------
function cx10tor {
    <#
    .SYNOPSIS
    cx10tor - Connect-EX2010 to specified on-prem Exchange
    .DESCRIPTION
    Connect-EX2010 - Connect-EX2010 to specified on-prem Exchange
    .NOTES
    REVISIONS   :
    # 3:18 PM 5/18/2021 somehow lost $credOpTORSID, so flipped lost default $credOPTor -> $credTORSID
    # 11:20 AM 4/21/2021 fixed/suppressed noisy verbose calls
    .EXAMPLE
    cx10tor
    #>
    [CmdletBinding()] 
    [Alias('cxOPtor')]
    Param([Parameter(HelpMessage = 'Credential object')][System.Management.Automation.PSCredential]$Credential = $credTorSID)
    $Verbose = ($VerbosePreference -eq 'Continue') ;
    if(!$Credential){
        $pltGHOpCred=@{TenOrg="TOR" ;userrole=@('SID','ESVC','LSVC') ;verbose=$($verbose)} ;
        if($Credential=(get-HybridOPCredentials @pltGHOpCred).cred){
            #Connect-EX2010 -cred $credTorSID #-Verbose:($VerbosePreference -eq 'Continue') ; 
        } else {
            $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole $($UserRole -join '|') value!"
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break ;
        } ;
    } ; 
    Connect-EX2010 -cred $Credential #-Verbose:($VerbosePreference -eq 'Continue') ; 
}

#*------^ cx10tor.ps1 ^------


#*------v disable-ForestView.ps1 v------
Function disable-ForestView {
<#
.SYNOPSIS
disable-ForestView.ps1 - Disable Exchange onprem AD ViewEntireForest setting (permits org-wide object access, wo use of proper explicit -domaincontroller sub.domain.com)
.NOTES
Version     : 1.0.2
Author      : Todd Kadrie
Website     : http://www.toddomation.com
Twitter     : @tostka / http://twitter.com/tostka
CreatedDate : 2020-10-26
FileName    :
License     : MIT License
Copyright   : (c) 2020 Todd Kadrie
Github      : https://github.com/tostka/verb-XXX
Tags        : Powershell
REVISIONS
* 11:40 AM 5/14/2021 added -ea 0 to the gv tests (suppresses not-found error when called without logging config)
* 10:56 AM 4/2/2021 cleaned up; added recstat & wlt
* 11:44 AM 3/5/2021 variant of toggle-fv
.DESCRIPTION
disable-ForestView.ps1 - Disable Exchange onprem AD ViewEntireForest setting (permits org-wide object access, wo use of proper explicit -domaincontroller sub.domain.com)
.INPUTS
None. Does not accepted piped input.
.OUTPUTS
None. Returns no objects or output
.EXAMPLE
disable-ForestView
.LINK
https://github.com/tostka/verb-ex2010
.LINK
#>
[CmdletBinding()]
PARAM() ;
    # toggle forest view
    if (get-command -name set-AdServerSettings){
        if ((get-AdServerSettings).ViewEntireForest ) {
              write-verbose "(set-AdServerSettings -ViewEntireForest `$False)"
              set-AdServerSettings -ViewEntireForest $False
        } ;
    } else {
        #-=-record a STATUSERROR=-=-=-=-=-=-=
        $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
        if(Get-Variable passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
        if(Get-Variable -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
        #-=-=-=-=-=-=-=-=
        $smsg = "MISSING:set-AdServerSettings`nOPEN an Exchange OnPrem connection FIRST!"
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        BREAK ;
    } ;
}

#*------^ disable-ForestView.ps1 ^------


#*------v Disconnect-Ex2010.ps1 v------
Function Disconnect-Ex2010 {
  <#
    .SYNOPSIS
    Disconnect-Ex2010 - Clear Remote Exch2010 Mgmt Shell connection
    .NOTES
    Author: Todd Kadrie
    Website:	http://toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    AddedCredit : Inspired by concept code by ExactMike Perficient, Global Knowl... (Partner)
    AddedWebsite:	https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    Version     : 1.1.0
    CreatedDate : 2020-02-24
    FileName    : Connect-Ex2010()
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Exchange,ExchangeOnline
    REVISIONS   :
    * 3:11 PM 7/15/2024 needed to change CHKPREREQ to check for presence of prop, not that it had a value (which fails as $false); hadn't cleared $MetaProps = ...,'DOESNTEXIST' ; confirmed cxo working non-based
    * 10:47 AM 7/11/2024 cleared debugging NoSuch etc meta tests
    * 1:34 PM 6/21/2024 ren $Global:E10Sess -> $Global:EXOPSess ; add: prereq checks, and $isBased support, to devert into most connect-exchangeServerTDO, get-ADExchangeServerTDO 100% generic fall back support; sketched in Ex2013 disconnect support
    # 11:12 AM 10/25/2021 added trailing null $Global:E10Sess  (to avoid false conn detects on that test)
    # 9:44 AM 7/27/2021 add -PsTitleBar EMS[ctl] support by dyn gathering range of all 1st & last $Meta.Name[0,2] values
    # 11:20 AM 4/21/2021 fixed/suppressed noisy verbose calls
    * 1:14 PM 3/1/2021 added color reset
    * 4:13 PM 10/22/2020 added pretest of $Global:*'s before running at remove-module (suppresses errors)
    * 12:23 PM 5/27/2020 updated cbh, moved aliases:Disconnect-EMSR','dx10' win func
    * 10:51 AM 2/24/2020 updated attrib
    * 6:59 PM 1/15/2020 cleanup
    * 8:01 AM 11/1/2017 added Remove-PSTitlebar 'EMS', and Disconnect-PssBroken to the bottom - to halt growth of unrepaired broken connections. Updated example to pretest for reqMods
    * 12:54 PM 12/9/2016 cleaned up, add pshelp, implented and debugged as part of verb-Ex2010 set
    * 2:37 PM 12/6/2016 ported to local EMSRemote
    * 2/10/14 posted version
    .DESCRIPTION
    Disconnect-Ex2010 - Clear Remote Exch2010 Mgmt Shell connection
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    $reqMods="Remove-PSTitlebar".split(";") ;
    $reqMods | % {if( !(test-path function:$_ ) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing $($_) function. EXITING." } } ;
    Disconnect-Ex2010 ;
    .LINK
    #>
    [CmdletBinding()]
    [Alias('Disconnect-EMSR','dx10')]
    Param()
    BEGIN{
        
        #region CHKPREREQ ; #*------v CHKPREREQ v------
        # critical dependancy Meta variables
        $MetaNames = ,'TOR','CMW','TOL' #,'NOSUCH' ;
        # critical dependancy Meta variable properties
        $MetaProps = 'Ex10Server','Ex10WebPoolVariant','ExRevision','ExViewForest','ExOPAccessFromToro','legacyDomain' #,'DOESNTEXIST' ;
        # critical dependancy parameters
        $gvNames = 'Credential'
        $isBased = $true ; $gvMiss = @() ; $ppMiss = @() ;
        foreach($met in $metanames){
            write-verbose "chk:`$$($met)Meta" ;
            if(-not (gv -name "$($met)Meta" -ea 0)){$isBased = $false; $gvMiss += "$($met)Meta" } ;
            if($MetaProps){
                foreach($mp in $MetaProps){
                    write-verbose "chk:`$$($met)Meta.$($mp)" ;
                    #if(-not (gv -name "$($met)Meta" -ea 0).value[$mp]){ # testing has a value, not is present as a spec!
                    if(-not (gv -name "$($met)Meta" -ea 0).value.keys -contains $mp){
                        $isBased = $false; $ppMiss += "$($met)Meta.$($mp)"
                    } ;
                } ;
            } ;
        } ;
        if($gvNames){
            foreach($gvN in $gvNames){
                write-verbose "chk:`$$($gvN)" ;
                if(-not (gv -name "$($gvN)" -ea 0)){$isBased = $false; $gvMiss += "$($gvN)" } ;
            } ;
        } ;
        if($gvmiss){write-warning "Missing Dependant Meta variables:`n$(($gvMiss |%{"`$$($_)" }) -join ',')" } ;
        if($ppMiss){write-warning "Missing Dependant Meta vari properties:`n$(($ppMiss |%{"`$$($_)" }) -join ',')" } ;
        if(-not $isBased){ write-warning  "missing critical dependancy profile config!" } ;
        #endregion CHKPREREQ ; #*------^ END CHKPREREQ ^------

        if($Global:E10Mod){$Global:E10Mod | Remove-Module -Force -verbose:$($false) } ;
        if($Global:EXOPSess){$Global:EXOPSess | Remove-PSSession -verbose:$($false)} ;
        if($isBased){
            $Metas=(get-variable *meta|?{$_.name -match '^\w{3}Meta$'}).name ; 
            # 7:56 AM 11/1/2017 remove titlebar tag
            #Remove-PSTitlebar 'EMS' -verbose:$($VerbosePreference -eq "Continue")  ;
            # 9:21 AM 7/27/2021 expand to cover EMS[tlc]
            #Remove-PSTitlebar 'EMS[ctl]' -verbose:$($VerbosePreference -eq "Continue")  ;
            # make it fully dyn: build range of all meta 1sts & last chars
            [array]$chrs = $metas.substring(0,3).substring(0,1) ; 
            $chrs+= $metas.substring(0,3).substring(2,1) ; 
            $chrs=$chrs.tolower()|select -unique ;
            $sTitleBarTag = "EMS$('[' + (($chrs |%{[regex]::escape($_)}) -join '') + ']')" ; 
            write-verbose "remove PSTitleBarstring:$($sTitleBarTag)" ; 
            Remove-PSTitlebar $sTitleBarTag -verbose:$($VerbosePreference -eq "Continue")  ;
        }  ; 
        # should pull TenOrg if no other mounted 
        <#$sXopDesig = 'xp' ;
        $sXoDesig = 'xo' ;
        #>
        #$xxxMeta.rgxOrgSvcs : $ExchangeServer = (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server|get-random ;
        # normally would be org specific, but we don't have a cred or a TenOrg ref to resolve, so just check xx's version
        # -replace 'EMS','' -replace '\(\|','(' -replace '\|\)',')'
        #if($host.ui.RawUI.WindowTitle -notmatch ((Get-Variable  -name "TorMeta").value.rgxOrgSvcs-replace 'EMS','' -replace '\(\|','(' -replace '\|\)',')' )){
        # drop the current tag being removed from the rgx...
        <# # at this point, if we're no longer using explict Org tag (EMS[tlc] instead), don't need to remove, they'll come out with the EMS removel
        [regex]$rgxsvcs = ('(' + (((Get-Variable  -name "TorMeta").value.OrgSvcs |?{$_ -ne 'EMS'} |%{[regex]::escape($_)}) -join '|') + ')') ;
        if($host.ui.RawUI.WindowTitle -notmatch $rgxsvcs){
            write-verbose "(removing TenOrg reference from PSTitlebar)" ; 
            #Remove-PSTitlebar $TenOrg ;
            # split the rgx into an array of tags
            #sTitleBarTag = (((Get-Variable  -name "TorMeta").value.rgxOrgSvcs) -replace '(\\s\(|\)\\s)','').split('|') ; 
            # no remove all meta tenorg tags - shouldn't be cross-org connecting
            #$Metas=(get-variable *meta|?{$_.name -match '^\w{3}Meta$'}).name ; 
            $sTitleBarTag = $metas.substring(0,3) ; 
            Remove-PSTitlebar $sTitleBarTag -verbose:$($VerbosePreference -eq "Continue") ;
        } else {
            write-verbose "(detected matching OrgSvcs in PSTitlebar: *not* removing TenOrg reference)" ; 
        } ; 
        #>
    }  # BEG-E
    PROCESS{
        # kill any other sessions using distinctive name; add verbose, to ensure they're echo'd that they were missed
        #Get-PSSession | Where-Object { $_.name -eq 'Exchange2010' } | Remove-PSSession -verbose:$($false);
        <# Ex2013 [PS] C:\scripts>get-pssession | fl name,configuration
        Name              : Session1
        ConfigurationName : Microsoft.Exchange
        ComputerName      : server.domain.tld
        #>
        Get-PSSession | Where-Object { $_.ConfigurationName='Microsoft.Exchange'} | Remove-PSSession -verbose:$($false); #version agnostic
        Get-PSSession | Where-Object { $_.name -match 'Exchange2010' } | Remove-PSSession -verbose:$($false); # my older customized connection filtering
        

        # should splice in Ex2013/16 support as well
        # kill any broken PSS, self regen's even for L13 leave the original borked and create a new 'Session for implicit remoting module at C:\Users\', toast them, they don't reopen. Same for Ex2010 REMS, identical new PSS, indistinguishable from the L13 regen, except the random tmp_xxxx.psm1 module name. Toast them, it's just a growing stack of broken's
        Disconnect-PssBroken ;
        #[console]::ResetColor()  # reset console colorscheme
        # null $Global:EXOPSess 
        if($Global:EXOPSess){$Global:EXOPSess = $null } ; 
    } ;  # PROC-E
}

#*------^ Disconnect-Ex2010.ps1 ^------


#*------v enable-ForestView.ps1 v------
Function enable-ForestView {
    <#
    .SYNOPSIS
    enable-ForestView.ps1 - Enable Exchange onprem AD ViewEntireForest setting (permits org-wide object access, wo use of proper explicit -domaincontroller sub.domain.com)
    .NOTES
    Version     : 1.0.2
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2020-10-26
    FileName    : enable-ForestView
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    REVISIONS
    * 11:40 AM 5/14/2021 added -ea 0 to the gv tests (suppresses not-found error when called without logging config)
    * 10:56 AM 4/2/2021 cleaned up; added recstat & wlt
    * 11:43 AM 3/5/2021 variant of toggle-fv
    .DESCRIPTION
    enable-ForestView.ps1 - Enable Exchange onprem AD ViewEntireForest setting (permits org-wide object access, wo use of proper explicit -domaincontroller sub.domain.com)
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output
    .EXAMPLE
    enable-ForestView
    .LINK
    https://github.com/tostka/verb-ex2010
    .LINK
    #>
    [CmdletBinding()]
    PARAM() ;
    # toggle forest view
    if (get-command -name set-AdServerSettings){
        if (!(get-AdServerSettings).ViewEntireForest ) {
              write-verbose "(set-AdServerSettings -ViewEntireForest `$False)" ;
              set-AdServerSettings -ViewEntireForest $TRUE  ;
        } ;
    } else {
        #-=-record a STATUSERROR=-=-=-=-=-=-=
        $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
        if(Get-Variable passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
        if(Get-Variable -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
        #-=-=-=-=-=-=-=-=
        $smsg = "MISSING:set-AdServerSettings`nOPEN an Exchange OnPrem connection FIRST!"
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        BREAK ;
    } ;
}

#*------^ enable-ForestView.ps1 ^------


#*------v get-ADExchangeServerTDO.ps1 v------
Function get-ADExchangeServerTDO {
        <#
        .SYNOPSIS
        get-ADExchangeServerTDO.ps1 - Returns Exchangeserver summary(s) from AD records
        .NOTES
        Version     : 3.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2015-09-03
        FileName    : get-ADExchangeServerTDO.ps1
        License     : (none-asserted)
        Copyright   : (none-asserted)
        Github      : https://github.com/tostka/verb-Ex2010
        Tags        : Powershell, ActiveDirectory, Exchange, Discovery
        AddedCredit : Mike Pfeiffer
        AddedWebsite: mikepfeiffer.net
        AddedTwitter: URL
        AddedCredit : Sammy Krosoft 
        AddedWebsite: http://aka.ms/sammy
        AddedTwitter: URL
        AddedCredit : Brian Farnsworth
        AddedWebsite: https://codeandkeep.com/
        AddedTwitter: URL
        REVISIONS
        * 10;05 am 4/30/2025 fixed code for Edge role in raw PS, missing evaris for Ex: added discovery from reg & stock file system dirs for version etc.
        * 3:57 PM 11/26/2024 updated simple write-host,write-verbose with full pswlt support;  syncd dbg & vx10 copies.
        * 12:57 PM 6/11/2024 Validated, Ex2010 & Ex2019, hub, mail & edge roles: tested ☑️ on CMW mail role (Curly); and Jumpbox; copied in CBH from repo copy, which has been updated/debugged compat on CMW Edge 
        * 2:05 PM 8/28/2023 REN -> Get-ExchangeServerInSite -> get-ADExchangeServerTDO (aliased orig); to better steer profile-level options - including in cmw org, added -TenOrg, and default Site to constructed vari, targeting new profile $XXX_ADSiteDefault vari; Defaulted -Roles to HUB,CAS as well.
        * 3:42 PM 8/24/2023 spliced together combo of my long-standing, and some of the interesting ideas BF's version had. Functional prod:
            - completely removed ActiveDirectory module dependancies from BF's code, and reimplemented in raw ADSI calls. Makes it fully portable, even into areas like Edge DMZ roles, where ADMS would never be installed.

        * 3:17 PM 8/23/2023 post Edge testing: some logic fixes; add: -Names param to filter on server names; -Site & supporting code, to permit lookup against sites *not* local to the local machine (and bypass lookup on the local machine) ; 
            ren $Ex10siteDN -> $ExOPsiteDN; ren $Ex10configNC -> $ExopconfigNC
        * 1:03 PM 8/22/2023 minor cleanup
        * 10:31 AM 4/7/2023 added CBH expl of postfilter/sorting to draw predictable pattern 
        * 4:36 PM 4/6/2023 validated Psv51 & Psv20 and Ex10 & 16; added -Roles & -RoleNames params, to perform role filtering within the function (rather than as an external post-filter step). 
        For backward-compat retain historical output field 'Roles' as the msexchcurrentserverroles summary integer; 
        use RoleNames as the text role array; 
            updated for psv2 compat: flipped hash key lookups into properties, found capizliation differences, (psv2 2was all lower case, wouldn't match); 
        flipped the [pscustomobject] with new... psobj, still psv2 doesn't index the hash keys ; updated for Ex13+: Added  16  "UM"; 20  "CAS, UM"; 54  "MBX" Ex13+ ; 16385 "CAS" Ex13+ ; 16439 "CAS, HUB, MBX" Ex13+
        Also hybrided in some good ideas from SammyKrosoft's Get-SKExchangeServers.psm1 
        (emits Version, Site, low lvl Roles # array, and an array of Roles, for post-filtering); 
        # 11:20 AM 4/21/2021 fixed/suppressed noisy verbose calls
        * 12:08 PM 5/15/2020 fixed vpn issue: Try/Catch'd around recently failing $ADSite::GetComputerSite().GetDirectoryEntry().distinguishedName qry
        * 11:22 AM 3/13/2020 Get-ExchangeServerInSite added a ping-test, to only return matches that are pingable, added -NoPing param, to permit (faster) untested bypass
        * 6:59 PM 1/15/2020 cleanup
        # 10:03 AM 11/16/2018 Get-ExchangeServerInSite:can't do AD-related functions when not AD authentictaed (home, pre-vpn connect). Added if/then test on status and abort balance when false.
        * 11/18/18 BF's posted rev
        # 12:10 PM 8/1/2017 updated example code at bottom, to accommodate variant sites
        # 11:28 AM 3/31/2016 validated that latest round of updates are still functional
        #1:58 PM 9/3/2015 - added pshelp and some docs
        #April 12, 2010 - web version
        .DESCRIPTION
        get-ADExchangeServerTDO.ps1 - Returns Exchangeserver summary(s) from AD records

        Hybrided together ideas from Brian Farnsworth's blog post
        [PowerShell - ActiveDirectory and Exchange Servers – CodeAndKeep.Com – Code and keep calm...](https://codeandkeep.com/PowerShell-ActiveDirectory-Exchange-Part1/)
        ... with much older concepts from  Sammy Krosoft, and much earlier Mike Pfeiffer. 

        - Subbed in MP's use of ADSI for ActiveDirectory Ps mod cmds - it's much more dependancy-free; doesn't require explicit install of the AD ps module
        ADSI support is built into windows.
        - spliced over my addition of Roles, RoleNames, Name & NoTest params, for prefiltering and suppressing testing.


        [briansworth · GitHub](https://github.com/briansworth)

        Uses an ADSI DirectorySearcher to search the current Active Directory site for Exchange on-prem servers.
                Intent is to discover connection points for Powershell, wo the need to preload/pre-connect to Exchange.

                But, as a non-Exchange-Management-Shell-dependant info source on Exchange Server configs, it can be used before connection, with solely AD-available data, to check configuration spes on the subject server(s). 

                For example, this query will return sufficient data under Version to indicate which revision of Exchange is in use:


                Returned object (in array):
                Site      : {ADSITENAME}
                Roles     : {64}
                Version   : {Version 15.1 (Build 32375.7)}
                Name      : SERVERNAME
                RoleNames : EDGE
                FQDN      : SERVERNAME.DOMAIN.TLD

                ... includes the post-filterable Role property ($_.Role -contains 'CAS') which reflects the following
                installed-roles ('msExchCurrentServerRoles') on the discovered servers
                    2   {"MBX"} # Ex10
                    4   {"CAS"}
                    16  {"UM"}
                    20  {"CAS, UM" -split ","} # 
                    32  {"HUB"}
                    36  {"CAS, HUB" -split ","}
                    38  {"CAS, HUB, MBX" -split ","}
                    54  {"MBX"} # Ex13+
                    64  {"EDGE"}
                    16385   {"CAS"} # Ex13+
                    16439   {"CAS, HUB, MBX"  -split ","} # Ex13+
        .PARAMETER Roles
        Array of msExchCurrentServerRoles 'role' integers to be filtered against (2|4|16|20|32|36|38|54|64|16385|16439)[-Roles @(38,16385)]
        .PARAMETER RoleNames
        Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']
        .PARAMETER Server
        Array of Server name strings to be filtered against[-Server 'SERVER1','SERVER2']
        .PARAMETER SiteName
        Name of specific AD SiteName to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-SiteName 'SITENAME']
        .PARAMETER TenOrg
        Tenant Tag (3-letter abbrebiation - defaults to variable `$global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']
        .PARAMETER NoPing
        Switch to suppress default 'pingable' test (e.g. returns all matches, no testing)[-NoPing]
        .INPUTS
        None. Does not accepted piped input.(.NET types, can add description)
        .OUTPUTS
        None. Returns no objects or output (.NET types)
        System.Boolean
        [| get-member the output to see what .NET obj TypeName is returned, to use here]
        System.Array of System.Object's
        .EXAMPLE
        PS> If(!($ExchangeServer)){$ExchangeServer = (get-ADExchangeServerTDO| ?{$_.RoleNames -contains 'CAS' -OR $_.RoleNames -contains 'HUB' -AND ($_.FQDN -match "^SITECODE") } | Get-Random ).FQDN
        Return a random Hub Cas Role server in the local Site with a fqdn beginning SITECODE
        .EXAMPLE
        PS> $localADExchserver = get-ADExchangeServerTDO -Names $env:computername -SiteName ([System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().name)
        Demo, if run from an Exchange server, return summary details about the local server (-SiteName isn't required, is default imputed from local server's Site, but demos explicit spec for remote sites)
        .EXAMPLE
        PS> $regex = '(' + [regex]($ADSiteCodeUK,$ADSiteCodeAU -join "|") + ')'
        PS> switch -regex ($($env:computername).substring(0,3)){
        PS>    "$($ADSiteCodeUS)" {$tExRole=36 } ;
        PS>    "$($regex)" {$tExRole= 38 }  default { write-error "$((get-date).ToString('HH:mm:ss')):UNRECOGNIZED SERVER PREFIX!."; } ;
        PS> } ;
        PS> $exhubcas = (get-ADExchangeServerTDO |?{($_.roles -eq $tExRole) -AND ($_.FQDN -match "$($env:computername.substring(0,3)).*")} | Get-Random ).FQDN ;
        Use a switch block to select different role combo targets for a given server fqdn prefix string.
        .EXAMPLE
        PS> $ExchangeServer = get-ADExchangeServerTDO | ?{$_.Roles -match '(4|20|32|36|38|16385|16439)'} | select -expand fqdn | get-random ; 
        Another/Older approach filtering on the Roles integer (targeting combos with Hub or CAS in the mix)
        .EXAMPLE
        PS> $ret = get-ADExchangeServerTDO -Roles @(4,20,32,36,38,16385,16439) -verbose 
        Demo use of the -Roles param, feeding it an array of Role integer values to be filtered against. In this case, the Role integers that include a CAS or HUB role.
        .EXAMPLE
        PS> $ret = get-ADExchangeServerTDO -RoleNames 'HUB','CAS' -verbose ;
        Demo use of the -RoleNames param, feeding it the array 'HUB','CAS' Role name strings to be filtered against
        PS> $ret = get-ADExchangeServerTDO -Names 'SERVERName' -verbose ;
        Demo use of the -RoleNames param, feeding it the array 'HUB','CAS' Role name strings to be filtered against
        .EXAMPLE
        PS> $ExchangeServer = get-ADExchangeServerTDO | sort version,roles,name | ?{$_.rolenames -contains 'CAS'}  | select -last 1 | select -expand fqdn ;
        Demo post sorting & filtering, to deliver a rule-based predictable pattern for server selection: 
        Above will always pick the highest Version, 'CAS' RoleName containing, alphabetically last server name (that is pingable). 
        And should stick to that pattern, until the servers installed change, when it will shift to the next predictable box.
        .EXAMPLE
        PS> $ExOPServer = get-ADExchangeServerTDO -Name LYNMS650 -SiteName Lyndale
        PS> if([double]$ExVersNum = [regex]::match($ExOPServer.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value){
        PS>     switch -regex ([string]$ExVersNum) {
        PS>         '15\.2' { $isEx2019 = $true ; $ExVers = 'Ex2019' }
        PS>         '15\.1' { $isEx2016 = $true ; $ExVers = 'Ex2016'}
        PS>         '15\.0' { $isEx2013 = $true ; $ExVers = 'Ex2013'}
        PS>         '14\..*' { $isEx2010 = $true ; $ExVers = 'Ex2010'}
        PS>         '8\..*' { $isEx2007 = $true ; $ExVers = 'Ex2007'}
        PS>         '6\.5' { $isEx2003 = $true ; $ExVers = 'Ex2003'}
        PS>         '6|6\.0' {$isEx2000 = $true ; $ExVers = 'Ex2000'} ;
        PS>         default {
        PS>             $smsg = "UNRECOGNIZED ExchangeServer.AdminDisplayVersion.Major.Minor string:$($ExOPServer.version)! ABORTING!" ;
        PS>             write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
        PS>         }
        PS>     } ; 
        PS> }else {
        PS>     $smsg = "UNABLE TO RESOLVE `$ExVersNum from `$ExOPServer.version:$($ExOPServer.version)!" ; 
        PS>     write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ; 
        PS>     throw $smsg ; 
        PS>     break ; 
        PS> } ; 
        Demo of parsing the returned Version property, into the proper Exchange Server revision.      
        .LINK
        https://github.com/tostka/verb-XXX
        .LINK
        https://bitbucket.org/tostka/powershell/
        .LINK
        http://mikepfeiffer.net/2010/04/find-exchange-servers-in-the-local-active-directory-site-using-powershell/
        .LINK
        https://github.com/SammyKrosoft/Search-AD-Using-Plain-PowerShell/blob/master/Get-SKExchangeServers.psm1
        .LINK
        https://github.com/tostka/verb-Ex2010
        .LINK
        https://codeandkeep.com/PowerShell-ActiveDirectory-Exchange-Part1/
        #>
        [CmdletBinding()]
        [Alias('Get-ExchangeServerInSite')]
        PARAM(
            [Parameter(Position=0,HelpMessage="Array of Server name strings to be filtered against[-Server 'SERVER1','SERVER2']")]
                [string[]]$Server,
            [Parameter(Position=1,HelpMessage="Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-SiteName 'SITENAME']")]
                [Alias('Site')]
                [string]$SiteName = (gv -name "$($TenOrg)_ADSiteDefaultName" -ea 0).Value,
            [Parameter(Position=2,HelpMessage="Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']")]
                [ValidateSet('MBX','CAS','HUB','UM','MBX','EDGE')]
                [string[]]$RoleNames = @('HUB','CAS'),
            [Parameter(HelpMessage="Array of msExchCurrentServerRoles 'role' integers to be filtered against (2|4|16|20|32|36|38|54|64|16385|16439)[-Roles @(38,16385)]")]
                [ValidateSet(2,4,16,20,32,36,38,54,64,16385,16439)]
                [int[]]$Roles,
            [Parameter(HelpMessage="Switch to suppress default 'pingable' test (e.g. returns all matches, no testing)[-NoTest]")]
                [Alias('NoPing')]
                [switch]$NoTest,
            [Parameter(HelpMessage="Milliseconds of max timeout to wait during port 80 test (defaults 100)[-SpeedThreshold 500]")]
                [int]$SpeedThreshold=100,
            [Parameter(Mandatory=$FALSE,HelpMessage="Tenant Tag (3-letter abbrebiation - defaults to global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']")]
                [ValidateNotNullOrEmpty()]
                [string]$TenOrg = $global:o365_TenOrgDefault,
            [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials[-Credentials [credential object]]")]
                [System.Management.Automation.PSCredential]$Credential
        ) ;
        BEGIN{
            ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
            $Verbose = ($VerbosePreference -eq 'Continue') ;
            $_sBnr="#*======v $(${CmdletName}): v======" ;
            $smsg = $_sBnr ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ;
        PROCESS{
            TRY{
                $configNC = ([ADSI]"LDAP://RootDse").configurationNamingContext ;
                $search = new-object DirectoryServices.DirectorySearcher([ADSI]"LDAP://$configNC") ;
                $bLocalEdge = $false ; 
                if($Sitename -eq $env:COMPUTERNAME){
                    $smsg = "`$SiteName -eq `$env:COMPUTERNAME:$($SiteName):$($env:COMPUTERNAME)" ; 
                    $smsg += "`nThis computer appears to be an EdgeRole system (non-ADConnected)" ; 
                    $smsg += "`n(Blanking `$sitename and continuing discovery)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    #$bLocalEdge = $true ; 
                    $SiteName = $null ; 
    
                } ; 
                If($siteName){
                    $smsg = "Getting Site: $siteName" ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                    $objectClass = "objectClass=site" ;
                    $objectName = "name=$siteName" ;
                    $search.Filter = "(&($objectClass)($objectName))" ;
                    $site = ($search.Findall()) ;
                    $siteDN = ($site | select -expand properties).distinguishedname  ;
                } else {
                    $smsg = "(No -Site specified, resolving site from local machine domain-connection...)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                    else{ write-host -foregroundcolor green "$($smsg)" } ;
                    TRY{$siteDN = [System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().GetDirectoryEntry().distinguishedName}
                    CATCH [System.Management.Automation.MethodInvocationException]{
                        $ErrTrapd=$Error[0] ;
                        if(($ErrTrapd.Exception -match 'The computer is not in a site.') -AND $env:ExchangeInstallPath){
                            $smsg = "$($env:computername) is non-ADdomain-connected" ;
                            $smsg += "`nand has `$env:ExchangeInstalled populated: Likely Edge Server" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                            else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $vers = (get-item "$($env:ExchangeInstallPath)\Bin\Setup.exe").VersionInfo.FileVersionRaw ; 
                            $props = @{
                                Name=$env:computername;
                                FQDN = ([System.Net.Dns]::gethostentry($env:computername)).hostname;
                                Version = "Version $($vers.major).$($vers.minor) (Build $($vers.Build).$($vers.Revision))" ; 
                                #"$($vers.major).$($vers.minor)" ; 
                                #$exServer.serialNumber[0];
                                Roles = [System.Object[]]64 ;
                                RoleNames = @('EDGE');
                                DistinguishedName =  "CN=$($env:computername),CN=Servers,CN=Exchange Administrative Group (FYDIBOHF23SPDLT),CN=Administrative Groups,CN=First Organization,CN=Microsoft Exchange,CN=Services,CN=Configuration,CN={nnnnnnnn-FAKE-GUID-nnnn-nnnnnnnnnnnn}" ;
                                Site = [System.Object[]]'NOSITE'
                                ResponseTime = if($rsp){$rsp.ResponseTime} else { 0} ;
                                NOTE = "This summary object, returned for a non-AD-connected EDGE server, *approximates* what would be returned on an AD-connected server" ;
                            } ;
            
                            $smsg = "(-NoTest:Defaulting Fast:`$true)" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            $props.add('Fast',$true) ;
            
                            return (New-Object -TypeName PsObject -Property $props) ;
                        }elseif(-not $env:ExchangeInstallPath){
                            $smsg = "Non-Domain Joined machine, with NO ExchangeInstallPath e-vari: `nExchange is not installed locally: local computer resolution fails:`nPlease specify an explicit -Server, or -SiteName" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $false | write-output ;
                        } else {
                            $smsg = "$($env:computername) is both NON-Domain-joined -AND lacks an Exchange install (NO ExchangeInstallPath e-vari)`nPlease specify an explicit -Server, or -SiteName" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $false | write-output ;
                        };
                    } CATCH {
                        $siteDN =$ExOPsiteDN ;
                        write-warning "`$siteDN lookup FAILED, deferring to hardcoded `$ExOPsiteDN string in infra file!" ;
                    } ;
                } ;
                $smsg = "Getting Exservers in Site:$($siteDN)" ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                $search = new-object DirectoryServices.DirectorySearcher([ADSI]"LDAP://$configNC") ;
                $objectClass = "objectClass=msExchExchangeServer" ;
                $version = "versionNumber>=1937801568" ;
                $site = "msExchServerSite=$siteDN" ;
                $search.Filter = "(&($objectClass)($version)($site))" ;
                $search.PageSize = 1000 ;
                [void] $search.PropertiesToLoad.Add("name") ;
                [void] $search.PropertiesToLoad.Add("msexchcurrentserverroles") ;
                [void] $search.PropertiesToLoad.Add("networkaddress") ;
                [void] $search.PropertiesToLoad.Add("msExchServerSite") ;
                [void] $search.PropertiesToLoad.Add("serialNumber") ;
                [void] $search.PropertiesToLoad.Add("DistinguishedName") ;
                $exchServers = $search.FindAll() ;
                $Aggr = @() ;
                foreach($exServer in $exchServers){
                    $fqdn = ($exServer.Properties.networkaddress |
                        Where-Object{$_ -match '^ncacn_ip_tcp:'}).split(':')[1] ;
                    if($NoTest){} else {
                        $rsp = test-connection $fqdn -count 1 -ea 0 ;
                    } ;
                    $props = @{
                        Name = $exServer.Properties.name[0]
                        FQDN=$fqdn;
                        Version = $exServer.Properties.serialnumber
                        Roles = $exserver.Properties.msexchcurrentserverroles
                        RoleNames = $null ;
                        DistinguishedName = $exserver.Properties.distinguishedname;
                        Site = @("$($exserver.Properties.msexchserversite -Replace '^CN=|,.*$')") ;
                        ResponseTime = if($rsp){$rsp.ResponseTime} else { 0} ;
                    } ;
                    $props.RoleNames = switch ($exserver.Properties.msexchcurrentserverroles){
                        2       {"MBX"}
                        4       {"CAS"}
                        16      {"UM"}
                        20      {"CAS;UM".split(';')}
                        32      {"HUB"}
                        36      {"CAS;HUB".split(';')}
                        38      {"CAS;HUB;MBX".split(';')}
                        54      {"MBX"}
                        64      {"EDGE"}
                        16385   {"CAS"}
                        16439   {"CAS;HUB;MBX".split(';')}
                    }
                    if($NoTest){
                        $smsg = "(-NoTest:Defaulting Fast:`$true)" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        $props.add('Fast',$true) ;
                    }else {
                        $props.add('Fast',[boolean]($rsp.ResponseTime -le $SpeedThreshold)) ;
                    };
                    $Aggr += New-Object -TypeName PsObject -Property $props ;
                } ;
                $httmp = @{} ;
                if($Roles){
                    [regex]$rgxRoles = ('(' + (($roles |%{[regex]::escape($_)}) -join '|') + ')') ;
                    $matched =  @( $aggr | ?{$_.Roles -match $rgxRoles}) ;
                    foreach($m in $matched){
                        if($httmp[$m.name]){} else {
                            $httmp[$m.name] = $m ;
                        } ;
                    } ;
                } ;
                if($RoleNames){
                    foreach ($RoleName in $RoleNames){
                        $matched = @($Aggr | ?{$_.RoleNames -contains $RoleName} ) ;
                        foreach($m in $matched){
                            if($httmp[$m.name]){} else {
                                $httmp[$m.name] = $m ;
                            } ;
                        } ;
                    } ;
                } ;
                if($Server){
                    foreach ($Name in $Server){
                        $matched = @($Aggr | ?{$_.Name -eq $Name} ) ;
                        foreach($m in $matched){
                            if($httmp[$m.name]){} else {
                                $httmp[$m.name] = $m ;
                            } ;
                        } ;
                    } ;
                } ;
                if(($httmp.Values| measure).count -gt 0){
                    $Aggr  = $httmp.Values ;
                } ;
                $smsg = "Returning $((($Aggr|measure).count|out-string).trim()) match summaries to pipeline..." ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                $Aggr | write-output ;
            }CATCH{
                Write-Error $_ ;
            } ;
        } ;
        END{
            $smsg = "$($_sBnr.replace('=v','=^').replace('v=','^='))" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 }
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ;
    }

#*------^ get-ADExchangeServerTDO.ps1 ^------


#*------v get-DAGDatabaseCopyStatus.ps1 v------
function get-DAGDatabaseCopyStatus {
    <#
    .SYNOPSIS
    get-DAGDatabaseCopyStatus.ps1 - Retrieve MailboxDatabaseCopyStatus for an entire DatabaseAvailabilityGroup
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2022-04-25
    FileName    : get-DAGDatabaseCopyStatus.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Powershell,Exchange,ExchangeOnline,ActiveDirectory
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 2:16 PM 6/24/2024: rem'd out #Requires -RunasAdministrator; sec chgs in last x mos wrecked RAA detection
    4:23 PM 3/21/2023 typo, missing trailing , on $name param def
    11:08 AM 4/25/2022 init
    .DESCRIPTION
    get-DAGDatabaseCopyStatus.ps1 - Retrieve MailboxDatabaseCopyStatus for an entire DatabaseAvailabilityGroup
    .PARAMETER  users
    Array of user descriptors: displayname, emailaddress, UPN, samaccountname (checks clipboard where unspecified)
    .PARAMETER ADDisabledOnly
    Switch to exclude users solely on ADUser.disabled (not Disabled OU presense), or with that have the ADUser below an OU matching '*OU=(Disabled|TERMedUsers)'  [-ADDisabledOnly]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    Returns a System.Object[] object to pipeline, with subsets of processed users as 'Enabled' (ADUser.enabled),'Disabled', and 'Contacts' properties.
    .EXAMPLE
    PS> $rpt = get-DAGDatabaseCopyStatus -users 'username1','user2@domain.com','[distinguishedname]' ;
    PS> $rpt | export-csv -nottype ".\pathto\usersummaries-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
    Processes local/remotemailbox & ADUser details on three specified users (alias,email address, DN). Summaries are returned to pipeline, and assigned to the $rpt variable, which is then exported to csv.
    .EXAMPLE
    PS> $rpt = get-DAGDatabaseCopyStatus -users 'username1','user2@domain.com','[distinguishedname]' -ADDisabledOnly ;
    PS> $rpt | export-csv -nottype ".\pathto\usersummaries-ENABLEDUSERS-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
    Processes local/remotemailbox & ADUser details on three specified users (alias,email address, DN).
    And allocate as 'Disabled', accounts that are *solely* ADUser.disabled
    (e.g. considers users below OU's with names like 'OU=Disabled*' as 'Enabled' users),
    and then exports to csv.
    .EXAMPLE
    $rpt = get-DAGDatabaseCopyStatus -users 'username1','user2@domain.com','[distinguishedname]' ;
    $rpt.enabled | export-csv -nottype ".\pathto\usersummaries-ENABLEDUSERS-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
    Process specified identifiers, and export solely the 'Enabled' users returned to csv.
    .LINK
    https://github.com/tostka/verb-ex2010
    .LINK
    #>
    ###Requires -Version 5
    #Requires -Modules ActiveDirectory, MSOnline, AzureAD, ExchangeOnlineManagement, verb-AAD, verb-ADMS
    ##Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    ##[Alias('ulu')]
    PARAM(
        [Parameter(Position=0,Mandatory=$true,ValueFromPipeline=$true,HelpMessage="DatabaseAvailabilityGroup Name")]
        #[ValidateNotNullOrEmpty()]
        #[Alias('ALIAS1', 'ALIAS2')]
        [array]$Name,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2
    ) ;
    BEGIN{
        $Verbose = ($VerbosePreference -eq 'Continue') ;

        $rgxDisabledOUs = '.*OU=(Disabled|TERMedUsers).*' ;
        if(!$users){
            $users= (get-clipboard).trim().replace("'",'').replace('"','') ;
            if($users){
                write-verbose "No -users specified, detected value on clipboard:`n$($users)" ;
            } else {
                write-warning "No -users specified, nothing matching dname, emailaddress or samaccountname, found on clipboard. EXITING!" ;
                Break ;
            } ;
        } ;
        $ttl = ($users|measure).count ;
        if($ttl -lt 10){
            write-verbose "($(($users|measure).count)) user(s) specified:`n'$($users -join "','")'" ;
        } else {
            write-verbose "($(($users|measure).count)) user(s) specified (-gt 10, suppressing details)" ;
        }

        rx10 -Verbose:$false ; #rxo  -Verbose:$false ; #cmsol  -Verbose:$false ;
        connect-ad -Verbose:$false;

        $propsmbx='Database','UseDatabaseRetentionDefaults','SingleItemRecoveryEnabled','RetentionPolicy','ProhibitSendQuota',
            'ProhibitSendReceiveQuota','SamAccountName','ServerName','UseDatabaseQuotaDefaults','IssueWarningQuota','Office',
            'UserPrincipalName','Alias','OrganizationalUnit  global.ad.toro.com/TERMedUsers','DisplayName','EmailAddresses',
            'HiddenFromAddressListsEnabled','LegacyExchangeDN','PrimarySmtpAddress','RecipientType','RecipientTypeDetails',
            'WindowsEmailAddress','DistinguishedName','CustomAttribute1','CustomAttribute2','CustomAttribute3','CustomAttribute4',
            'CustomAttribute5','CustomAttribute6','CustomAttribute7','CustomAttribute8','CustomAttribute9','CustomAttribute10',
            'CustomAttribute11','CustomAttribute12','CustomAttribute13','CustomAttribute14','CustomAttribute15''EmailAddressPolicyEnabled',
            'WhenChanged','WhenCreated' ;
        $propsadu = "accountExpires","CannotChangePassword","Company","Compound","Country","countryCode","Created","Department",
            "Description","DisplayName","DistinguishedName","Division","EmployeeID","EmployeeNumber","employeeType","Enabled","Fax",
            "GivenName","homeMDB","homeMTA","info","Initials","lastLogoff","lastLogon","LastLogonDate","mail","mailNickname","Manager",
            "mobile","MobilePhone","Modified","Name","Office","OfficePhone","Organization","physicalDeliveryOfficeName","POBox","PostalCode",
            "SamAccountName","sAMAccountType","State","StreetAddress","Surname","Title","UserPrincipalName",'CustomAttribute1',
            'CustomAttribute2','CustomAttribute3','CustomAttribute4','CustomAttribute5','CustomAttribute6','CustomAttribute7',
            'CustomAttribute8','CustomAttribute9','CustomAttribute10','CustomAttribute11','CustomAttribute12','CustomAttribute13',
            'CustomAttribute14','CustomAttribute15','EmailAddressPolicyEnabled',"whenChanged","whenCreated" ;
        $propsMC = 'ExternalEmailAddress','Alias','DisplayName','EmailAddresses','PrimarySmtpAddress','RecipientType',
            'RecipientTypeDetails','WindowsEmailAddress','Name','DistinguishedName','Identity','CustomAttribute1','CustomAttribute2',
            'CustomAttribute3','CustomAttribute4','CustomAttribute5','CustomAttribute6','CustomAttribute7','CustomAttribute8',
            'CustomAttribute9','CustomAttribute10','CustomAttribute11','CustomAttribute12','CustomAttribute13','CustomAttribute14',
            'CustomAttribute15','EmailAddressPolicyEnabled','whenChanged','whenCreated' ;
    }
    PROCESS{
        $Procd=0 ;$pct = 0 ;
        $aggreg =@() ; $contacts =@() ; $UnResolved = @() ; $Failed = @() ;
        $pltGRcp=[ordered]@{identity=$null;erroraction='STOP';resultsize=1;} ;
        $pltGMbx=[ordered]@{identity=$null;erroraction='STOP'} ;
        $pltGadu=[ordered]@{Identity = $null ; Properties='*' ;errorAction='STOP'} ;
        foreach ($usr in $users){
            $procd++ ; $pct = '{0:p0}' -f ($procd/$ttl) ;
            $rrcp = $mbx = $mc = $mbxspecs = $adspecs = $summary = $NULL ;
            #write-verbose "processing:$($usr)" ;
            $sBnrS="`n#*------v PROCESSING ($($procd)/$($ttl)):$($usr)`t($($pct)) v------" ;
            if($verbose){
                write-verbose "$((get-date).ToString('HH:mm:ss')):$($sBnrS)" ;
            } else {
                write-host "." -NoNewLine ;
            } ;

            TRY {
                $pltGRcp.identity = $usr ;
                write-verbose "get-recipient  w`n$(($pltGRcp|out-string).trim())" ;
                $rrcp = get-recipient @pltGRcp ;
                if($rrcp){
                    $pltgmbx.identity = $rrcp.PrimarySmtpAddress ;
                    switch ($rrcp.recipienttype){
                        'MailUser'{
                            write-verbose "get-remotemailbox  w`n$(($pltgmbx|out-string).trim())" ;
                            $mbx = get-remotemailbox @pltgmbx
                        }
                        'UserMailbox' {
                            write-verbose "get-mailbox w`n$(($pltgmbx|out-string).trim())" ;
                            $mbx = get-mailbox @pltgmbx ;
                        }
                        'MailContact' {
                            write-verbose "get-mailcontact w`n$(($pltgmbx|out-string).trim())" ;
                            $mc = get-mailcontact @pltgmbx ;
                        }
                        default {throw "$($rrcp.alias):Unsupported RecipientType:$($rrcp.recipienttype)" }
                    } ;
                    if(-not($mc)){
                        $mbxspecs =  $mbx| select $propsmbx ;
                        $pltGadu.identity = $mbx.samaccountname ;
                        write-verbose "Get-ADUser w`n$(($pltGadu|out-string).trim())" ;
                        Try {
                            $adspecs =Get-ADUser @pltGadu | select $propsadu ;
                        } CATCH [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException] {
                            $smsg = "(no matching ADuser found:$($pltGadu.identity))" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } catch {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } ;
                        $summary = @{} ;
                        foreach($object_properties in $mbxspecs.PsObject.Properties) {
                            $summary.add($object_properties.Name,$object_properties.Value) ;
                        } ;
                        foreach($object_properties in $adspecs.PsObject.Properties) {
                            $summary.add("AD$($object_properties.Name)",$object_properties.Value) ;
                        } ;
                        $aggreg+= New-Object PSObject -Property $summary ;

                    } else {
                        $smsg = "Resolved user for $($usr) is RecipientType:$($mc.RecipientType)`nIt is not a local mail object, or AD object, and simply reflects a pointer to an external mail recipient.`nThis object is being added to the 'Contacts' section of the output.." ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $contacts += $mc | select $propsMC ;
                    } ;
                } else {
                    # in ISE $Error[0] is empty
                    #$ErrTrapd=$Error[0] ;
                    #if($ErrTrapd.Exception -match "couldn't\sbe\sfound\son"){
                        $UnResolved += $pltGRcp.identity ;
                    #} else {
                        #$Failed += $pltGRcp.identity ;
                    #} ;
                } ;
            } CATCH [System.Management.Automation.RemoteException] {
                # catch error never gets here (at least not in ISE)
                $ErrTrapd=$Error[0] ;
                if($ErrTrapd.Exception -match "couldn't\sbe\sfound\son"){
                    $UnResolved += $pltGRcp.identity ;
                } else {
                    $Failed += $pltGRcp.identity ;
                } ;
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $Failed += $pltGRcp.identity ;
            } ;

            if($verbose){
                write-verbose "$((get-date).ToString('HH:mm:ss')):$($sBnrS.replace('-v','-^').replace('v-','^-'))" ; ;
            } ;

        } ;
    }
    END{
        if(-not($ADDisabledOnly)){
            $Report = [ordered]@{
                Enabled = $Aggreg|?{($_.ADEnabled -eq $true ) -AND -not($_.distinguishedname -match $rgxDisabledOUs) } ;#?{$_.adDisabled -ne $true -AND -not($_.distinguishedname -match $rgxDisabledOUs)}
                Disabled = $Aggreg|?{($_.ADEnabled -eq $False) } ;
                Contacts = $contacts ;
                Unresolved = $Unresolved ;
                Failed = $Failed;
            } ;
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):outputing $(($Report.Enabled|measure).count) Enabled User summaries,`nand $(($Report.Disabled|measure).count) ADUser.Disabled or Disabled/TERM-OU account summaries`nand $(($Report.Contacts|measure).count) users resolved to MailContacts" ;
        } else {
            $Report = [ordered]@{
                Enabled = $Aggreg|?{($_.ADEnabled -eq $true) -AND -not($_.distinguishedname -match $rgxDisabledOUs) } ;#?{$_.adDisabled -ne $true -AND -not($_.distinguishedname -match $rgxDisabledOUs)}
                Disabled = $Aggreg|?{($_.ADEnabled -eq $False) -OR ($_.distinguishedname -match $rgxDisabledOUs) } ;
                Contacts = $contacts ;
                Unresolved = $Unresolved ;
                Failed = $Failed;
            } ;
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):outputing $(($Report.Enabled|measure).count) Enabled User summaries,`nand $(($Report.Disabled|measure).count) ADUser.Disabled`nand $(($Report.Contacts|measure).count) users resolved to MailContacts" ;
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):-ADDisabledOnly specified: 'Disabled' output are *solely* ADUser.Disabled (no  Disabled/TERM-OU account filtering applied)`nand $(($Report.Contacts|measure).count) users resolved to MailContacts" ;
        } ;
        New-Object PSObject -Property $Report | write-output ;

     } ;
 }

#*------^ get-DAGDatabaseCopyStatus.ps1 ^------


#*------v Get-ExchServerFromExServersGroup.ps1 v------
Function Get-ExchServerFromExServersGroup {
  <#
    .SYNOPSIS
    Get-ExchServerFromExServersGroup - Returns the name of an Exchange server by drawing a random box from ad.DOMAIN.com\Exchange Servers grp & regex matches for desired site hubCas names.
    .NOTES
    Author: Todd Kadrie
    Website:	http://tintoys.blogspot.com
    REVISIONS   :
    * 10:02 AM 5/15/2020 pushed the post regex into a infra string & defaulted param, so this could work with any post-filter ;ren Get-ExchServerInLYN -> Get-ExchServerFromExServersGroup
    * 6:59 PM 1/15/2020 cleanup
    # 10:44 AM 9/2/2016 - initial tweak
    .PARAMETER  ServerRegex
    Server filter Regular Expression[-ServerRegex '^CN=(SITE1|SITE2)BOX1[0,1].*$']
    .DESCRIPTION
    Get-ExchServerFromExServersGroup - Returns the name of an Exchange server by drawing a random box from ad.DOMAIN.com\Exchange Servers grp & regex matches for desired site hubCas names.
    Leverages the ActiveDirectory module Get-ADGroupMember cmdlet
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns the name of an Exchange server in the local AD site.
    .EXAMPLE
    .\Get-ExchServerFromExServersGroup
    Draw random matching ex server with defaulted settings
    .EXAMPLE
    .\Get-ExchServerFromExServersGroup -ServerRegex '^CN=SITEPREFIX.*$'
    Draw random matching ex server with explicit ServerRegex match
    .LINK
    #>
    #Requires -Modules ActiveDirectory
    PARAM(
        [Parameter(HelpMessage="Server filter Regular Expression[-ServerRegex '^CN=(SITE1|SITE2)BOX1[0,1].*$']")]
        $ServerRegex=$rgxLocalHubCAS,
        [Parameter(HelpMessage="AD ParentDomain fqdn [-ADParentDomain 'ROOTDOMAIN.DOMAIN.com']")]
        $ADParentDomain=$DomTORParentfqdn
    ) ;
    (Get-ADGroupMember -Identity 'Exchange Servers' -server $DomTORParentfqdn |
        Where-Object { $_.distinguishedname -match $ServerRegex }).name |
            get-random | write-output ;
}

#*------^ Get-ExchServerFromExServersGroup.ps1 ^------


#*------v get-ExRootSiteOUs.ps1 v------
function get-ExRootSiteOUs {
    <#
    .SYNOPSIS
    get-ExRootSiteOUs.ps1 - Gather & return array of objects for root OU's matching a regex filter on the DN (if target OUs have a consistent name structure)
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-30
    FileName    : get-ExRootSiteOUs.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Powershell,Exchange,ExchangeOnline,ActiveDirectory
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    # 12:34 PM 8/4/2021 ren'd getADSiteOus -> get-ExRootSiteOUs (avoid overlap with verb-adms\get-ADRootSiteOus())
    # 12:49 PM 7/25/2019 get-ExRootSiteOUs:updated $RegexBanned to cover TAC (no users or DL resource 
      OUs - appears to be variant of LYN w a single disabled users (obsolete disabled 
      TimH acct) 
    # 12:08 PM 6/20/2019 init vers
    .DESCRIPTION
    get-ExRootSiteOUs.ps1 - Gather & return array of objects for root OU's matching a regex filter on the DN (if target OUs have a consistent name structure)
    .DESCRIPTION
    Convert the passed-in ADUser object RecipientType from RemoteUserMailbox to RemoteSharedMailbox.
    .PARAMETER  Regex
    OU DistinguishedName regex, to identify 'Site' OUs [-Regex [regularexpression]]
    .PARAMETER RegexBanned
    OU DistinguishedName regex, to EXCLUDE non-legitimate 'Site' OUs [-RegexBanned [regularexpression]]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns an array of Site OU distinguishedname strings
    .EXAMPLE
    $SiteOUs=get-ExRootSiteOUs ;
    Retrieve the DNS for the default SiteOU
    .LINK
    https://github.com/tostka/verb-exo
    #>
    [CmdletBinding()]
    ##[Alias('ulu')]
    Param(
        [Parameter(Position = 0, HelpMessage = "OU DistinguishedName regex, to identify 'Site' OUs [-ADUser [regularexpression]]")]
        [ValidateNotNullOrEmpty()][string]$Regex = '^OU=(\w{3}|PACRIM),DC=global,DC=ad,DC=toro((lab)*),DC=com$',
        [Parameter(Position = 0, HelpMessage = "OU DistinguishedName regex, to EXCLUDE non-legitimate 'Site' OUs [-RegexBanned [regularexpression]]")]
        [ValidateNotNullOrEmpty()][string]$RegexBanned = '^OU=(BCC|EDC|NC1|NDS|TAC),DC=global,DC=ad,DC=toro((lab)*),DC=com$',
        #[Parameter(HelpMessage = "Domain Controller [-domaincontroller server.fqdn.com]")]
        #[string] $domaincontroller,
        [Parameter(HelpMessage = "Debugging Flag [-showDebug]")]
        [switch] $showDebug
    ) # PARAM BLOCK END
    $verbose = ($VerbosePreference -eq "Continue") ; 
    $error.clear() ;
    TRY {
        #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
        $SiteOUs = Get-OrganizationalUnit |?{($_.distinguishedname -match $Regex) -AND ($_.distinguishedname -notmatch $RegexBanned) }|sort distinguishedname ; 

    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #-=-record a STATUSWARN=-=-=-=-=-=-=
        $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
        if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
        if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
        #-=-=-=-=-=-=-=-=
        $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
    } ; 
    if ($SiteOUs) {
        $SiteOUs | write-output ;
    } else {
        $smsg= "Unable to retrieve OUs matching specified rgx:`n$($regex)";
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $false | write-output ;
    }
}

#*------^ get-ExRootSiteOUs.ps1 ^------


#*------v get-MailboxDatabaseQuotas.ps1 v------
function get-MailboxDatabaseQuotas {
<#
    .SYNOPSIS
    get-MailboxDatabaseQuotas - Queries all on-prem mailbox databases (get-mailboxdatabase) for default quota settings, and returns an indexed hashtable summarizing the values per database (indexed to each database 'name' value).
    .PARAMETER Mailboxes
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-02-25
    FileName    : get-MailboxDatabaseQuotas.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Powershell
    REVISIONS
    * 4:27 PM 2/25/2022 init vers
    .DESCRIPTION
    get-MailboxDatabaseQuotas - Queries all on-prem mailbox databases (get-mailboxdatabase) for default quota settings, and returns an indexed hashtable summarizing the name and quotas per database (indexed to each database 'name' value).
    .PARAMETER TenOrg
TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']
    .EXAMPLE
    PS> $hQuotas = get-MailboxDatabaseQuotas -verbose ; 
    PS> $hQuotas['database2']
    Name           ProhibitSendReceiveQuotaGB ProhibitSendQuotaGB IssueWarningQuotaGB
    ----           -------------------------- ------------------- -------------------
    database2      12.000                     10.000              9.000
    Retrieve local org on-prem MailboxDatabase quotas and assign to a variable, with verbose outputs. Then output the retrieved quotas from the indexed hash returned, for the mailboxdatabase named 'database2'.
    .EXAMPLE
    PS> $pltGMDQ=[ordered]@{
            TenOrg= $TenOrg;
            verbose=$($VerbosePreference -eq "Continue") ;
            credential= $pltRXO.credential ;
            #(Get-Variable -name cred$($tenorg) ).value ;
        } ;
    PS> $smsg = "$($tenorg):get-MailboxDatabaseQuotas w`n$(($pltGMDQ|out-string).trim())" ;
    PS> if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    PS> $objRet = $null ;
    PS> $objRet = get-MailboxDatabaseQuotas @pltGMDQ ;
    PS> switch -regex ($objRet.GetType().FullName){
            "(System.Collections.Hashtable|System.Collections.Specialized.OrderedDictionary)" {
                if( ($objRet|Measure-Object).count ){
                    $smsg = "get-MailboxDatabaseQuotas:$($tenorg):returned populated MailboxDatabaseQuotas" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $mdbquotas = $objRet ;
                } else {
                    $smsg = "get-MailboxDatabaseQuotas:$($tenorg):FAILED TO RETURN populated MailboxDatabaseQuotas" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    THROW $SMSG ; 
                    break ; 
                } ;
            }
            default {
                $smsg = "get-MailboxDatabaseQuotas:$($tenorg):RETURNED UNDEFINED OBJECT TYPE!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Exit ;
            } ;
        } ;  
    PS> $smsg = "$(($mdbquotas|measure).count) quota summaries returned)" ;
    PS> if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    # given populuated $mbx 'mailbox object', lookup demo:
    PS> if($mbx.UseDatabaseQuotaDefaults){
            $MbxProhibitSendQuota = $mdbquotas[$mbx.database].ProhibitSendQuota ;
            $MbxProhibitSendReceiveQuota = $mdbquotas[$mbx.database].ProhibitSendReceiveQuota ;
            $MbxIssueWarningQuota = $mdbquotas[$mbx.database].IssueWarningQuota ;
        } else {
            write-verbose "(Custom Mbx Quotas configured...)" ;
            $MbxProhibitSendQuota = $mbx.ProhibitSendQuota ;
            $MbxProhibitSendReceiveQuota = $mbx.ProhibitSendReceiveQuota ;
            $MbxIssueWarningQuota = $mbx.IssueWarningQuota ;
        } ;    
    Expanded example with testing of returned object, and demoes use of the returned hash against a mailbox spec, steering via .UseDatabaseQuotaDefaults
    .LINK
    https://github.com/tostka/verb-ex2010
    #>
    #Requires -Modules verb-IO, verb-logging, verb-Text
    [OutputType('System.Collections.Hashtable')]
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
        [ValidateNotNullOrEmpty()]
        [string]$TenOrg = 'TOR',
        [Parameter(HelpMessage="Credential to use for this connection [-credential [credential obj variable]")]
        [System.Management.Automation.PSCredential]$Credential = $global:credTORSID
    ) ;
    
    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
    $verbose = ($VerbosePreference -eq "Continue") ;
    
    # select db properties (converts dehydrated bytes string values to decimal gigabytes, via my verb-io module's convert-DehydratedBytesToGB())
    $propsMDB = 'Name',@{Name='ProhibitSendReceiveQuotaGB';Expression={$_.ProhibitSendReceiveQuota | convert-DehydratedBytesToGB }},
    @{Name='ProhibitSendQuotaGB';Expression={$_.ProhibitSendQuota | convert-DehydratedBytesToGB }},
    @{Name='IssueWarningQuotaGB';Expression={$_.IssueWarningQuota | convert-DehydratedBytesToGB }} ; 
    #'ProhibitSendReceiveQuota','ProhibitSendQuota','IssueWarningQuota' ; 
    
    #region SERVICE_CONNECTIONS #*======v SERVICE_CONNECTIONS v======
#region GENERIC_EXOP_CREDS_&_SRVR_CONN #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
    # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
    $UseExOP=$true ;
    <# no onprem dep
    if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
        $UseExOP = $true ;
        $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    } else {
        $UseExOP = $false ;
        $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
    } ;
    #>
    if($UseExOP){
        #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
        # do the OP creds too
        $OPCred=$null ;
        # default to the onprem svc acct
        $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
        if($Credential){
            $pltGHOpCred.add('Credential',$Credential) ;
            if(get-Variable -Name "cred$($tenorg)OP" -scope Script -ea 0){
                set-Variable -Name "cred$($tenorg)OP" -scope Script -Value $Credential ;
            } else { New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $Credential } ;
        } else { 
            if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name "cred$($tenorg)OP" -scope Script -ea 0 ){ remove-Variable -Name "cred$($tenorg)OP" -scope Script } ;
                New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ;
                if($verbose){
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
            } else {
                $statusdelta = ";ERROR";
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                Break ;
            } ;
        } ; 
        $smsg= "Using EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        <# CALLS ARE IN FORM: (cred$($tenorg))
            $pltRX10 = @{
            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
            #verbose = $($verbose) ;
            Verbose = $FALSE ; Silent = $true ; } ;
        Reconnect-Ex2010 @pltRX10 ; # local org conns
        #$pltRx10 creds & .username can also be used for local ADMS connections
        #>
        $pltRX10 = @{
            Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
            #verbose = $($verbose) ;
            Verbose = $FALSE ; Silent = $false ; } ;
        if($1stConn){
            $pltRX10.silent = $false ; 
        } else { 
            $pltRX10.silent = $true ; 
        } ; 
        # defer cx10/rx10, until just before get-recipients qry
        #endregion GENERIC_EXOP_CREDS_&_SRVR_CONN #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
        # connect to ExOP X10
        if($pltRX10){
            #ReConnect-Ex2010XO @pltRX10 ;
            ReConnect-Ex2010 @pltRX10 ;
        } else { Reconnect-Ex2010 ; } ;
    } ;  # if-E $useEXOP

    # check if using Pipeline input or explicit params:
    if ($PSCmdlet.MyInvocation.ExpectingInput) {
        write-verbose "Data received from pipeline input: '$($InputObject)'" ;
    } else {
        # doesn't actually return an obj in the echo
        #write-verbose "Data received from parameter input: '$($InputObject)'" ;
    } ;
    
    # building a CustObj (actually an indexed hash) with the default quota specs from all db's. The 'index' for each db, is the db's Name (which is also stored as Database on the $mbx)
    if($host.version.major -gt 2){$dbQuotas = [ordered]@{} } 
    else { $dbQuotas = @{} } ;
    
    $smsg = "(querying quotas from all local-org mailboxdatabases)" ; 
    if($verbose){
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
    } ; 
    
    $error.clear() ;
    TRY {
        $dbQuotaDefaults=(get-mailboxdatabase -erroraction 'STOP' | sort server,name | select $propsMDB ) ;
    } CATCH {
        $ErrTrapd=$Error[0] ;
        $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #-=-record a STATUSWARN=-=-=-=-=-=-=
        $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
        if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
        if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
        #-=-=-=-=-=-=-=-=
        $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
    } ; 
    
    $ttl = ($dbQuotaDefaults|measure).count ; $Procd = 0 ; 
    foreach ($db in $dbQuotaDefaults){
        $Procd ++ ; 
        $sBnrS="`n#*------v PROCESSING : ($($Procd)/$($ttl)) $($db.name) v------" ; 
        $smsg = $sBnrS ; 
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        
        $name =$($db | select -expand Name) ; 
        $dbQuotas[$name] = $db ; 

        $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
    } ;  # loop-E

    if($dbQuotas){
        $smsg = "(Returning summary objects to pipeline)" ; 
        if($verbose){
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        $dbQuotas | Write-Output ; 
    } else {
        $smsg = "NO RETURNABLE `$dbQuotas OBJECT!" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        THROW $smsg ;
    } ; 
}

#*------^ get-MailboxDatabaseQuotas.ps1 ^------


#*------v Get-MessageTrackingLogTDO.ps1 v------
function Get-MessageTrackingLogTDO {
    <#
    .SYNOPSIS
    Get-MessageTrackingLogTDO - Wrapper that stages everything needed to discover ADSite & Servers, and open REMS connection to mail servers, to run a Get-MessageTrackingLog pass: has all comments pulled: *should* unwrap, but can run stacked as well. Also runs natively in EMS. Center unwrapped block is stock 7psmsgboxall
    .NOTES
    Version     : 0.0.1
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 20240530-1042AM
    FileName    : Get-MessageTrackingLogTDO.ps1
    License     : MIT License
    Copyright   : (c) 2024 Todd Kadrie
    Github      : htt-ps://github.com/tostka/verb-XXX
    Tags        : Powershell,Exchange,MessageTracking,Get-MessageTrackingLog,ActiveDirectory
    REVISIONS
    * 10;23 am 4/30/2025 - get-ADExchangeServerTDO: * 10;05 am 4/30/2025 fixed code for Edge role in raw PS, missing evaris for Ex: added discovery from reg & stock file system dirs for version etc.
        - Connect-ExchangeServerTDO: * 10;07 am 4/30/2025 fixed borked edge conn, typo, and rev logic for Ex & role detection in raw PS - lacks evaris for exchange (EMS/REMS only), so leverage reg & stock install loc hunting to discover setup.exe for vers & role confirm).
        - start-log: made Tag cleanup conditional (on funcs avail; legacy of bringing full start-log into the mix).
    * 1:35 PM 4/29/2025: added resolve-NetworkLocalTDO() (for vnet); 
        - Initialize-xopEventIDTable(): * 2;58 pm 4/28/2025 Updated table again, and found Ex2016/19 eventid specifications online, added. Did find that 
            the online doc doesn't document the edge SendExternal event id (added below, manually).      
        - ENCODED_CONTANTS block: added eval'd varis: $isLocalExchangeServer, $ByPassLocalExchangeServerTest, $IsEdgeTransport
        - new NETWORK_INFO block: $netsettings = resolve-NetworkLocalTDO() ;
        - new $isNonDomainServer test, $isLocalExchangeServer (transport svc & regkey), $IsEdgeTransport (regkey test)
        - revised $TenOrg forced resolution, to leverage DNS A fqdn suffix steering (collected via new resolve-NetworkLocalTDO())
        - UseOPAD: skip AD load, $useForestWide, $objforest, $forestdom, $domaincontroller & get-GCFast(), if $isNonDomainServer
        - added block that tests if($IsEdgeTransport -AND $psise) and warns likely AccessDenied's from ex commands (works fine in EMS outside of ise)
        - revised $OrgTag resolution, to detect Edge 'First Org' orgname, and substitute in $($TenOrg)edge log name tagging
        - stripped back Sender array expansion (ported from EXO, which supports mults): gmtl *doesnt* support [string[]]$Sender, throws error.
        - validated on TTC Ex10 (did CMW hubs & edge below)
    * 3:12 pm 4/28/2025 Noted, get-OrgConfig returns 'First Org... on edge, so coded in TenOrgedge as OrgTag in that niched case (was coming back 'O_FO' ; 
        extensive debugging updates in the services_control BP block, and detection and handling of TenOrg around non-dom-joined edge role machine; 
            Still having issues in psie debugging: throws localizaiton error - appears due to the EMS connection; works fine in raw EMS console on edge. 
            work either way on non-edge systems. Fine, but you can't step-debug it in ise on edge boxes
             - you can, but you can't get the get-messagetrackinglog command to exec properrly, throws Access Denied trying to access the logs
             errors correspond to those reported by folks trying to centralize edge tracking, from remote hosts. So it's definitely an REMS v EMS issue.
    * 4:25 PM 4/24/2025 validated TOR & full func verif CMW, after: Svcs_conn: added pretest for version in connect-exchangeserverTDO, splat (suppress dupe add error), only necc if both an explicit vers is specd & its on CMW
        - also added OrgName abbreviated to the exports, to differentiate sources
    * 8:01 PM 4/23/2025 add: Version, to match connect-ExchangeServerTDO() param, -DetailLimit for config of detailed outptut sizes; 
        # service_conn block: added $ExopVers, which defers to local $Version, if populated
        # also completely skips all the verb-x10 functions, when $TenOrg -eq CMW (no mod installs on their servers, this runs freestanding, self-contained only, no central va support
        - fixed bug/misplacement of most recent echo; restricted detail outputs to select -last $DetailLimit msgs; 
        - reworked Failed reporting; added an explicit 'other', for anything not covred by the existing targeted filtering.
        - substantially expanded Defer coverage: with volume defered in SAP tracks into other site, needed way to confirm retry/deliver
            coded in indexed hash of all SEND events, on msgid, with fast lookup of the Send for each Defer, and reporting/confirm on the exact amount of delay ea experienced (up to $detaillimit output).
        - fixed fundemental breaks in trailing echo blocks - weren't even functional, as last revised.
    * 5:43 PM 4/22/2025 CMW non-verb-ex2010: .ps1 version:
        - biggest issue, had to move func decl's to the top of BEGIN{ or they wouldn't register 
        - had to splice in additional functions, load-ADMS, get-GCFast, replaced the simplified write-log with the full version (w cbh & rem'd blocks pulled)
        - patch version in calls to Connect-ExchangeServerTDO (to 2010)

    * 4:51 PM 4/22/2025 added resolve-EnvironmentTDO alias: resolve-Environment; ADD: resolve-environment() & support, and updated start-log support; TLS_LATEST_FORCE ; missing regions; SWRITELOG ; SSTARTLOG ; 
        updated -Version supporting Connect-ExchangeServerTDO  ; convertFrom-MarkdownTable() to support... ; Initialize-xopEventIDTable; 
        fixed bug in -resultsize code; code to leverage Initialize-xopEventIDTable and output uniqued eventid's returnedon gmtl passes (doc output inline)
        copied over latest service conn code & slog for renv()
    * 3:23 PM 12/2/2024 throwing param transform errs on start & end (wyhen typed): pull typing, and do it post assignh, can't assign empty '' or $null to t a datetime coerced vary ;pre-reduce splat hash to populated values, in exmpl & BP use;
         rem out the parameterset code, and just do manual conflicting -start/-end -days tests and errors
    * 2:34 PM 11/26/2024 updated to latest 'Connect-ExchangeServerTDO()','get-ADExchangeServerTDO()', set to defer to existing
    * 4:20 PM 11/25/2024 updated from get-exomessagetraceexportedtdo(), more silent suppression, integrated dep-less ExOP conn supportadd delimters to echos, to space more, readability ;  fixed typo in eventid histo output
    * 3:16 PM 11/21/2024 working: added back Connectorid (postfiltered from results); add: $DaysLimit = 30 ; added: MsgsFail, MsgsDefer, MsgsFailRcpStat; 
    * 2:00 PM 11/20/2024 rounded out to iflv level, no dbg yet
    * 5:00 PM 10/14/2024 at this point roughed in ported updates from get-exomsgtracedetailed, no debugging/testing yet; updated params & cbh to semi- match vso\get-exomsgtracedetailed(); convert to a function (from ps1)
    * 11:30 AM 7/16/2024 CBH example typo fix
    * 2:41 PM 7/10/2024 spliced in notices for plus-addressing, ren'd $Tix -> $Ticket (matches gbug fi in psb.)
    * 12:57 PM 6/11/2024 Validated, Ex2010 & Ex2019, hub, mail & edge roles: tested ☑️ on CMW mail role (Curly); and Jumpbox;  finished test/debug on CMW edge: appears full functioning, including get-ADExchangeServerTDO() & Connect-ExchangeServerTDO()
    * 3:46 PM 6/3/2024 WIP for edge, latest chgs: rounded out params to subst cover full range of underlying Get-MessageTrackingLog: MessageID ; InternalMessageID; NetworkMessageID; Reference; ResultSize; 
        incl CH Example splatted call; shift conflicting sub bnr into $_sBnr; Also added param valid accomodating ResultSize is int32, $null or ''
    * 6;09 PM 5/30/2024 WIP for edge, finally got edge EMS code spliced in (from https://github.com/Lucifer1993/PLtools/blob/main/HealthChecker.ps1); 
    now connects see Get-MessageTrackingLog  runs & returns content on Edge; has trailing bug on exit
    You cannot call a method on a null-valued expression.
    At C:\scripts\Get-MessageTrackingLogTDO.ps1:952 char:16
    +     $smsg = "$($sBnr.replace('=v','=^').replace('v=','^='))" ;
    * 11:56 AM 5/30/2024 init; add: out-clipboard() ; spliced in conditional ordered hash code; transplanted psMsgTrkCMW.cbp into a full blown function; bonus: it runs fine in either org/enviro, as it's a full self contained solution to discover the local Exchange org from AD, then connect to the systems. 
    .DESCRIPTION
    Get-MessageTrackingLogTDO - Wrapper that stages everything needed to discover ADSite & Exchange Servers in the site; open REMS connection to a local HubCAS mail server;and then run a Get-MessageTrackingLog pass: has all comments pulled: *should* unwrap, but can run stacked as well. Also runs natively in EMS. Center unwrapped block is stock 7psmsgboxall

    SET DAYS=0 IF USING START/END (they only get used when days is non-0); isplt.
    TAG is appended to ticketNO for output vari $vn, and $ofile

    Returns Summary object to pipeline:
    [obj].MTMessagesCSVFile: full path to exported MTMessages as csv file 
    [obj].MTMessages: MessageTracking messages matched
    [obj].EventIDHisto: Histogram of EventID entries for MTMessages array
    [obj].MsgLast: Last Message returned on track
    [obj].MsgsFail: EventID:Fail messages returned on track
    [obj].MsgsDefer: EventID:Defer messages returned on track
    [obj].MsgsFailRcpStatHisto: Histogram of RecipientStatus entries for MTMessages array

    NOTE: To port this into the no-verb-ex2010 module support in CMW, rem the function declare lines.

    .PARAMETER ticket
    Ticket Number [-Ticket 'TICKETNO']
    .PARAMETER Requestor
    Ticket Customer email identifier. [-Requestor 'fname.lname@domain.com']
    .PARAMETER Days
    Days to be searched, back from current time(Alt to use of StartDate & EndDate)[-Days 30]
    .PARAMETER Start
    Optional search Start timestamp[-Start '8:55 AM 5/30/2024']
    .PARAMETER End
    Optional search End timestamp[-Start '9:55 AM 5/30/2024']
    .PARAMETER Sender
    Sender Address[-Sender email@domain.com]
    .PARAMETER Recipients
    Recipient Addresses[-Recipients 'eml1@domain.com','eml2@domain.com']
    .PARAMETER MessageSubject
    MessageSubject string[-MessageSubject 'Subject string']
    .PARAMETER MessageId
    Corresponds to the value of the Message-Id: header field in the message. Be sure to include the full MessageId string (which may include angle brackets) and enclose the value in quotation marks 
    .PARAMETER InternalMessageId
    The InternalMessageId parameter filters the message tracking log entries by the value of the InternalMessageId field. The InternalMessageId value is a message identifier that's assigned by the Exchange server that's currently processing the message.  The value of the internal-message-id for a specific message is different in the message tracking log of every Exchange server that's involved in the delivery of the message.
    .PARAMETER NetworkMessageId
    This field contains a unique message ID value that persists across copies of the message that may be created due to bifurcation or distribution group expansion. 
    .PARAMETER EventID
    The EventId parameter filters the results by the delivery status of the message (RECEIVE|DELIVER|FAIL|SEND|RESOLVE|EXPAND|TRANSFER|DEFER). [-Status 'Failed']")]
    .PARAMETER Reference
    The Reference field contains additional information for specific types of events. For example, the Reference field value for a DSN message tracking entry contains the InternalMessageId value of the message that caused the DSN. For many types of events, the value of Reference is blank
    .PARAMETER Source
    Source (STOREDRIVER|SMTP|DNS|ROUTING)[-Source STOREDRIVER]
    .PARAMETER Server
    The Server parameter specifies the Exchange server where you want to run this command. You can use any value that uniquely identifies the server. For example: Name, FQDN, Distinguished name (DN), Exchange Legacy DN. If you don't use this parameter, the command is run on the local server[-Server Servername]
    .PARAMETER TransportTrafficType
    The TransportTrafficType parameter filters the message tracking log entries by the value of the TransportTrafficType field. However, this field isn't interesting for on-premises Exchange organizations[-TransportTrafficType xxx]
    .PARAMETER Version
    Specific Exchange Server Version to connect to('Ex2019|Ex2016|Ex2013|Ex2010|Ex2007|Ex2003|Ex2000')[-Version 'Ex2016']
    .PARAMETER Resultsize
    The ResultSize parameter specifies the maximum number of results to return. If you want to return all requests that match the query, use unlimited for the value of this parameter. The default value is 1000.
    .PARAMETER DetailLimit
    Integer number of maximum messages to be follow-up MessageTraceDetail'd (defaults to 20) [-DetailLimit 100]
    .PARAMETER Tag
    Tag string to be used in export filenames and output variablename[-Tag 'FromSenderX']
    .PARAMETER SimpleTrack
    switch to just return the net messages on the initial track (no Fail/Quarantine, MTDetail or other post-processing summaries) [-simpletrack]
    .PARAMETER DoExports
    switch to perform configured csv exports of results (defaults true) [-DoExports]
    .PARAMETER TenOrg
    Tenant Tag (3-letter abbrebiation)[-TenOrg 'XYZ']
    .PARAMETER Credential
    Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]
    .PARAMETER UserRole
    Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]
    .PARAMETER Silent
    Suppress echoes.
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    None. Returns no objects or output (.NET types)
    System.Boolean
    [| get-member the output to see what .NET obj TypeName is returned, to use here]
    .EXAMPLE
    PS> $pltI=[ordered]@{
    PS>     ticket="TICKETNO" ;
    PS>     Requestor="USERID";
    PS>     days=7 ;
    PS>     Start="" ;
    PS>     End="" ;
    PS>     Sender="" ;
    PS>     Recipients="" ;
    PS>     MessageSubject="" ;
    PS>     MessageId="" ;
    PS>     InternalMessageId="" ;
    PS>     Reference="" ;
    PS>     EventID='' ;
    PS>     ConnectorId="" ;
    PS>     Source="" ;
    PS>     Version = 'Ex2010' ; 
    PS>     ResultSize="" ;
    PS>     Tag='' ;
    PS> } ;
    PS> $pltGMTL = [ordered]@{} ;
    PS> $pltI.GetEnumerator() | ?{ $_.value}  | ForEach-Object { $pltGMTL.Add($_.Key, $_.Value) } ;
    PS> $vn = (@("xopMsgs$($pltI.ticket)",$pltI.Tag) | ?{$_}) -join '_' write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Get-MessageTrackingLogTDO w`n$(($pltGMTL|out-string).trim())`n(assign to `$$($vn))" ;
    PS> if(gv $vn -ea 0){rv $vn} ;
    PS> if($tmsgs = Get-MessageTrackingLogTDO @pltGMTL){sv -na $vn -va $tmsgs ;
    PS> write-host "(assigned to `$$vn)"} ;
    Demo run fed by splatted parameters with Days specified and Start/End blank (matches 7PSMsgTrkAll splat layout)
    .EXAMPLE
    PS> $platIn=[ordered]@{
    PS>     ticket="TICKETNO" ;
    PS>     Requestor="USERID";
    PS>     days=0 ;
    PS>     Start= (get-date '5/31/2024 1:01:10 PM').adddays(-1)  ;
    PS>     End= (get-date '5/31/2024 1:01:10 PM').adddays(1)  ; ;
    PS>     Sender="" ;
    PS>     Recipients="" ;
    PS>     MessageSubject="" ;
    PS>     MessageId="" ;
    PS>     InternalMessageId="" ;
    PS>     Reference="" ;
    PS>     EventID='' ;
    PS>     ConnectorId="" ;
    PS>     Source="" ;
    PS>     ResultSize="" ;
    PS>     Version = 'Ex2010' ; 
    PS>     Tag='' ;
    PS> } ;
    PS> $pltGMTL = [ordered]@{} ;
    PS> $pltI.GetEnumerator() | ?{ $_.value}  | ForEach-Object { $pltGMTL.Add($_.Key, $_.Value) } ;
    PS> $vn = (@("xopMsgs$($pltI.ticket)",$pltI.Tag) | ?{$_}) -join '_' write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Get-MessageTrackingLogTDO w`n$(($pltGMTL|out-string).trim())`n(assign to `$$($vn))" ;
    PS> if(gv $vn -ea 0){rv $vn} ;
    PS> if($tmsgs = Get-MessageTrackingLogTDO @pltGMTL){sv -na $vn -va $tmsgs ;
    PS> write-host "(assigned to `$$vn)"} ;
    Demo run fed by splatted parameters with Days set to 0 and Start/End using explicit timestamps, calculated to bracket a specific timestamp(matches 7PSMsgTrkAll splat layout)
    .EXAMPLE
    PS> $pltI=[ordered]@{
    PS>     ticket="TICKETNO" ;
    PS>     Requestor="USERID";
    PS>     days=7 ;
    PS>     Start="" ;
    PS>     End="" ;
    PS>     Sender="" ;
    PS>     Recipients="" ;
    PS>     MessageSubject="" ;
    PS>     MessageId="" ;
    PS>     InternalMessageId="" ;
    PS>     Reference="" ;
    PS>     EventID='' ;
    PS>     ConnectorId="" ;
    PS>     Source="" ;
    PS>     Version = 'Ex2016' ; 
    PS>     ResultSize="" ;
    PS>     Tag='' ;
    PS> } ;
    PS> $pltGMTL = [ordered]@{} ;
    PS> $pltI.GetEnumerator() | ?{ $_.value}  | ForEach-Object { $pltGMTL.Add($_.Key, $_.Value) } ;
    PS> $vn = (@("xopMsgs$($pltI.ticket)",$pltI.Tag) | ?{$_}) -join '_' write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):.\Get-MessageTrackingLogTDO w`n$(($pltGMTL|out-string).trim())`n(assign to `$$($vn))" ;
    PS> if(gv $vn -ea 0){rv $vn} ;
    PS> if($tmsgs = .\Get-MessageTrackingLogTDO @pltGMTL){sv -na $vn -va $tmsgs ;
    PS> write-host "(assigned to `$$vn)"} ;
    Demo with dot-exec'd script syntax, same as demo1, with .\'s and version ex16 (for renames from _func.ps1 -> .ps1, and rem'ing the function declar lines). 
    .EXAMPLE
    PS> gci \\tsclient\d\scripts\Get-MessageTrackingLogTDO* | copy-item -dest c:\scripts\ -Verbose
    Copy in via RDP (includes exported psbreakpoint file etc)
    .LINK
    https://bitbucket.org/tostka/powershell/
    #>
    #[CmdletBinding(DefaultParameterSetName='Days')]
    [CmdletBinding()]
    ## PSV3+ whatif support:[CmdletBinding(SupportsShouldProcess)]
    ###[Alias('Alias','Alias2')]
    PARAM(
        [Parameter(Mandatory=$True,HelpMessage="Ticket Number [-Ticket 'TICKETNO']")]
            [Alias('tix')]
            [string]$ticket,
        [Parameter(Mandatory=$False,HelpMessage="Ticket Customer email identifier. [-Requestor 'fname.lname@domain.com']")]
            [Alias('UID')]
            [string]$Requestor,
        #[Parameter(ParameterSetName='Dates',HelpMessage="Start of range to be searched[-StartDate '11/5/2021 2:16 PM']")]
        [Parameter(HelpMessage="Start of range to be searched[-StartDate '11/5/2021 2:16 PM']")]
            #[Alias('Start')]
            #[DateTime]$StartDate,
            [Alias('StartDate')]
            [DateTime]$Start,
        #[Parameter(ParameterSetName='Dates',HelpMessage="End of range to be searched (defaults to current time if unspecified)[-EndDate '11/5/2021 5:16 PM']")]
        [Parameter(HelpMessage="End of range to be searched (defaults to current time if unspecified)[-EndDate '11/5/2021 5:16 PM']")]
            [Alias('EndDate')]
            [DateTime]$End,
        #[Parameter(ParameterSetName='Days',HelpMessage="Days to be searched, back from current time(Alt to use of StartDate & EndDate; Note:MS won't search -gt 10 days)[-Days 7]")]
        [Parameter(HelpMessage="Days to be searched, back from current time(Alt to use of StartDate & EndDate; Note:MS won't search -gt 10 days)[-Days 7]")]
            #[ValidateRange(0,[int]::MaxValue)]
            [ValidateRange(0,30)] # EXOP log retn is 2g or 30d whichever comes first
            [int]$Days,
        [Parameter(HelpMessage="SenderAddress (an array runs search on each)[-SenderAddress addr@domain.com]")]
            [Alias('SenderAddress')]
            [string]$Sender,
        [Parameter(HelpMessage="RecipientAddress (an array runs search on each)[-RecipientAddress addr@domain.com]")]
                [Alias('RecipientAddress')]
                [string[]]$Recipients, # MultiValuedProperty
        [Parameter(HelpMessage="Subject of target message (emulated via post filtering, not supported param of Get-xoMessageTrace) [-Subject 'Some subject']")]
                [Alias('subject')]
                [string]$MessageSubject,
        [Parameter(Mandatory=$False,HelpMessage="Corresponds to the value of the Message-Id: header field in the message. Be sure to include the full MessageId string (which may include angle brackets) and enclose the value in quotation marks[-MessageId `"<nnnn-nnn...>`"]")]
            [string]$MessageId,
        [Parameter(Mandatory=$False,HelpMessage="The InternalMessageId parameter filters the message tracking log entries by the value of the InternalMessageId field. The InternalMessageId value is a message identifier that's assigned by the Exchange server that's currently processing the message.  The value of the internal-message-id for a specific message is different in the message tracking log of every Exchange server that's involved in the delivery of the message.")]
            [string]$InternalMessageId,
        [Parameter(Mandatory=$False,HelpMessage="This field contains a unique message ID value that persists across copies of the message that may be created due to bifurcation or distribution group expansion.(Ex16,19)")]
            [string]$NetworkMessageId,
        [Parameter(Mandatory=$False,HelpMessage="The Reference field contains additional information for specific types of events. For example, the Reference field value for a DSN message tracking entry contains the InternalMessageId value of the message that caused the DSN. For many types of events, the value of Reference is blank")]
            [string]$Reference,
        [Parameter(HelpMessage="The Status parameter filters the results by the delivery status of the message (None|GettingStatus|Failed|Pending|Delivered|Expanded|Quarantined|FilteredAsSpam),an array runs search on each). [-Status 'Failed']")]
            [Alias('DeliveryStatus','Status')]
            [ValidateSet("RECEIVE","DELIVER","FAIL","SEND","RESOLVE","EXPAND","TRANSFER","DEFER","")]
            [string[]]$EventId, # MultiValuedProperty
        [Parameter(Mandatory=$False,HelpMessage="Source (STOREDRIVER|SMTP|DNS|ROUTING)[-Source STOREDRIVER]")]
            [ValidateSet("STOREDRIVER","SMTP","DNS","ROUTING","")]
            [string]$Source,
        [Parameter(Mandatory=$False,HelpMessage="The TransportTrafficType parameter filters the message tracking log entries by the value of the TransportTrafficType field. However, this field isn't interesting for on-premises Exchange organizations[-TransportTrafficType xxx]")]
            [string]$TransportTrafficType, 
        [Parameter(Mandatory=$False,HelpMessage="Connector ID string to be post-filtered from results[-Connectorid xxx]")]
            [string]$Connectorid,
        [Parameter(Mandatory=$False,HelpMessage="The Server parameter specifies the Exchange server where you want to run this command. You can use any value that uniquely identifies the server. For example: Name, FQDN, Distinguished name (DN), Exchange Legacy DN. If you don't use this parameter, the command is run on the local server[-Server Servername]")]
            [string]$Server,
        [Parameter(HelpMessage="Specific Exchange Server Version to connect to('Ex2019|Ex2016|Ex2013|Ex2010|Ex2007|Ex2003|Ex2000')[-Version 'Ex2016']")]
            [ValidateSet('Ex2019','Ex2016','Ex2013','Ex2010','Ex2007','Ex2003','Ex2000')]
            [string[]]$Version = 'Ex2010',
        [Parameter(Mandatory=$False,HelpMessage="The ResultSize parameter specifies the maximum number of results to return. If you want to return all requests that match the query, use unlimited for the value of this parameter. The default value is 1000.")]
            [ValidateScript({
              if( ($_ -match 'unlimited') -OR ($_.gettype().fullname -eq 'System.Int32') -OR ($null -eq $_) -OR ('' -eq $_) ){
                  $true ; 
              } else { 
                  throw "Resultsize must be an integer or the string 'unlimited' (or blank)" ; 
              } ;
            })]
            $ResultSize,
        [Parameter(HelpMessage="Integer number of maximum messages to be follow-up MessageTraceDetail'd (defaults to 20) [-DetailLimit 100]")]
            [int]$DetailLimit = 20,
        [Parameter(HelpMessage="Tag string (Variable Name compatible: no spaces A-Za-z0-9_ only) that is used for Variables and export file name construction. [-Tag 'LastDDGSend']")] 
            [ValidatePattern('^[A-Za-z0-9_]*$')]
            [string]$Tag,
        [Parameter(HelpMessage="switch to just return the net messages on the initial track (no Fail/Quarantine, MTDetail or other post-processing summaries) [-simpletrack]")]
            [switch]$SimpleTrack,
        [Parameter(HelpMessage="switch to perform configured csv exports of results (defaults true) [-DoExports]")]
            [switch]$DoExports=$TRUE,
        # Service Connection Supporting Varis (AAD, EXO, EXOP)
        [Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
            [ValidateNotNullOrEmpty()]
            #[ValidatePattern("^\w{3}$")]
            [string]$TenOrg = $global:o365_TenOrgDefault,
        [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials (defaults to Tenant-defined SvcAccount)[-Credentials [credential object]]")]
            [System.Management.Automation.PSCredential]$Credential,
        [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            # sourced from get-admincred():#182: $targetRoles = 'SID', 'CSID', 'ESVC','CSVC','UID','ESvcCBA','CSvcCBA','SIDCBA' ;
            #[ValidateSet("SID","CSID","UID","B2BI","CSVC","ESVC","LSVC","ESvcCBA","CSvcCBA","SIDCBA")]
            # pulling the pattern from global vari w friendly err
            [ValidateScript({
                if(-not $rgxPermittedUserRoles){$rgxPermittedUserRoles = '(SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)'} ;
                if(-not ($_ -match $rgxPermittedUserRoles)){throw "'$($_)' doesn't match `$rgxPermittedUserRoles:`n$($rgxPermittedUserRoles.tostring())" ; } ;
                return $true ;
            })]
            [string[]]$UserRole = @('SIDCBA','SID','CSVC'),
            #@('SID','CSVC'),
            # svcAcct use: @('ESvcCBA','CSvcCBA','SIDCBA')
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
            [switch] $silent
    ) ;
    BEGIN{

        #region FUNCTIONS_INTERNAL ; #*======v FUNCTIONS_INTERNAL v======
        # Pull the CUser mod dir out of psmodpaths:
        #$CUModPath = $env:psmodulepath.split(';')|?{$_ -like '*\Users\*'} ;

        #region RESOLVE_ENVIRONMENTTDO ; #*------v resolve-EnvironmentTDO v------
        if(-not(gci function:resolve-EnvironmentTDO -ea 0)){
            #*----------v Function resolve-EnvironmentTDO() v----------
            function resolve-EnvironmentTDO {
                <#
                    .SYNOPSIS
                    resolve-EnvironmentTDO.ps1 - Resolves local environment into usable Script or Function-descriptive values (for reuse in logging and i/o access)
                    .NOTES
                    Version     : 0.0.2
                    Author      : Todd Kadrie
                    Website     : http://www.toddomation.com
                    Twitter     : @tostka / http://twitter.com/tostka
                    CreatedDate : 2025-04-04
                    FileName    : resolve-EnvironmentTDO.ps1
                    License     : (non asserted)
                    Copyright   : (non asserted)
                    Github      : https://github.com/tostka/verb-ex2010
                    Tags        : Powershell,ExchangeServer,Version
                    AddedCredit : theSysadminChannel
                    AddedWebsite: https://thesysadminchannel.com/get-exchange-cumulative-update-version-and-build-numbers-using-powershell/
                    AddedTwitter: URL
                    REVISION
                    * 4:13 PM 4/4/2025 init
                    .EXAMPLE
                    PS> write-verbose "Typically from the BEGIN{} block of an Advanced Function, or immediately after PARAM() block" ; 
                    PS> $Verbose = [boolean]($VerbosePreference -eq 'Continue') ;
                    PS> $rPSCmdlet = $PSCmdlet ;
                    PS> $rPSScriptRoot = $PSScriptRoot ;
                    PS> $rPSCommandPath = $PSCommandPath ;
                    PS> $rMyInvocation = $MyInvocation ;
                    PS> $rPSBoundParameters = $PSBoundParameters ;
                    PS> $pltRvEnv=[ordered]@{
                    PS>     PSCmdletproxy = $rPSCmdlet ;
                    PS>     PSScriptRootproxy = $rPSScriptRoot ;
                    PS>     PSCommandPathproxy = $rPSCommandPath ;
                    PS>     MyInvocationproxy = $rMyInvocation ;
                    PS>     PSBoundParametersproxy = $rPSBoundParameters
                    PS>     verbose = [boolean]($PSBoundParameters['Verbose'] -eq $true) ;
                    PS> } ;
                    PS> write-verbose "(Purge no value keys from splat)" ;
                    PS> $mts = $pltRVEnv.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltRVEnv.remove($_.Name)} ; rv mts -ea 0 ;
                    PS> $smsg = "resolve-EnvironmentTDO w`n$(($pltRVEnv|out-string).trim())" ;
                    PS> if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    PS> $rvEnv = resolve-EnvironmentTDO @pltRVEnv ;  
                    PS> write-host "Returned `$rvEnv:`n$(($rvEnv|out-string).trim())" ; 
                #>
                [Alias('resolve-Environment')]
                [CmdletBinding()]
                PARAM(
                    [Parameter(HelpMessage="Proxied Powershell Automatic Variable object that represents the cmdlet or advanced function that’s being run. (passed by external assignment to a variable, which is then passed to this function)")] 
                        $PSCmdletproxy,        
                    [Parameter(HelpMessage="Proxied Powershell Automatic Variable that contains the full path to the script that invoked the current command. The value of this property is populated only when the caller is a script. (passed by external assignment to a variable, which is then passed to this function).")] 
                        $PSScriptRootproxy,
                    [Parameter(HelpMessage="Proxied Powershell Automatic Variable that contains the full path and file name of the script that’s being run. This variable is valid in all scripts. (passed by external assignment to a variable, which is then passed to this function).")] 
                        $PSCommandPathproxy,
                    [Parameter(HelpMessage="Proxied Powershell Automatic Variable that contains information about the current command, such as the name, parameters, parameter values, and information about how the command was started, called, or invoked, such as the name of the script that called the current command. (passed by external assignment to a variable, which is then passed to this function).")]
                        $MyInvocationproxy,
                    [Parameter(HelpMessage="Proxied Powershell Automatic Variable that contains a dictionary of the parameters that are passed to a script or function and their current values. This variable has a value only in a scope where parameters are declared, such as a script or function. You can use it to display or change the current values of parameters or to pass parameter values to another script or function. (passed by external assignment to a variable, which is then passed to this function).")]
                        $PSBoundParametersproxy
                ) ; 
                BEGIN {
                    $Verbose = [boolean]($VerbosePreference -eq 'Continue') ; 
                    <#
                    $PSCmdletproxy = $PSCmdlet ; # an object that represents the cmdlet or advanced function that's being run. Available on functions w CmdletBinding (& $args will not be available). (Blank on non-CmdletBinding/Non-Adv funcs).
                    $PSScriptRootproxy = $PSScriptRoot ; # the full path of the executing script's parent directory., PS2: valid only in script modules (.psm1). PS3+:it's valid in all scripts. (Funcs: ParentDir of the file that hosts the func)
                    $PSCommandPathproxy = $PSCommandPath ; # the full path and filename of the script that's being run, or file hosting the funct. Valid in all scripts.
                    $MyInvocationproxy = $MyInvocation ; # populated only for scripts, function, and script blocks.
                    #>
                    # - $MyInvocation.MyCommand.Name returns name of a function, to identify the current command,  name of the current script (pop'd w func name, on Advfuncs)
                    # - Ps3+:$MyInvocation.PSScriptRoot : full path to the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
                    # - Ps3+:$MyInvocation.PSCommandPath : full path and filename of the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
                    #     ** note: above pair contain information about the _invoker or calling script_, not the current script
                    #$PSBoundParametersproxy = $PSBoundParameters ; 

                    if($host.version.major -ge 3){$hshOutput=[ordered]@{Dummy = $null ;} }
                    else {$hshOutput = New-Object Collections.Specialized.OrderedDictionary} ;
                    If($hshOutput.Contains("Dummy")){$hshOutput.remove("Dummy")} ;
                    $tv = 'PSCmdletproxy','PSScriptRootproxy','PSCommandPathproxy','MyInvocationproxy','PSBoundParametersproxy'
                    # stock the autovaris, if populated
                    $tv | % { 
                        $hshOutput.add($_, (get-variable -name $_ -ea 0).Value) 
                    } ;
                    write-verbose "`$hshOutputn$(($hshOutput|out-string).trim())" ; 
                    $fieldsnull = 'runSource','CmdletName','PSParameters','ParamsNonDefault' 
                    if([boolean]($hshOutput.MyInvocationproxy.MyCommand.commandtype -eq 'Function' -AND $hshOutput.MyInvocationproxy.MyCommand.Name)){
                        #$tv+= @('isFunc','funcname','isFuncAdv') ; 
                        $fieldsnull = $(@($fieldsnull);@(@('isFunc','funcname','isFuncAdv'))) ; 
                        #$tv+= @('FuncDir') ; 
                        $fieldsnull = $(@($fieldsnull);@(@('FuncDir'))) ; 
                    } ; 
                    if([boolean]($hshOutput.MyInvocationproxy.MyCommand.commandtype -eq 'ExternalScript' -OR $hshOutput.PSCmdletproxy.MyInvocation.InvocationName -match '\.ps1$')){
                        #$tv += @('isScript','ScriptName','ScriptBaseName','ScriptNameNoExt','ScriptDir','isScriptUnpathed') ; 
                        $fieldsnull = $(@($fieldsnull);@('isScript','ScriptName','ScriptBaseName','ScriptNameNoExt','ScriptDir','isScriptUnpathed')) ; 
                    } ; 
                    $tv = $(@($tv);@($fieldsnull)) ; 
                    # append resolved elements to the hash as $null 
                    $fieldsnull  | % { $hshOutput.add($_,$null) } ;
                    write-verbose "`$hshOutputn$(($hshOutput|out-string).trim())" ; 

                    if($hshOutput.isFunc = [boolean]($hshOutput.MyInvocationproxy.MyCommand.commandtype -eq 'Function' -AND $hshOutput.MyInvocationproxy.MyCommand.Name)){
                        $hshOutput.FuncName = $hshOutput.MyInvocationproxy.MyCommand.Name ; write-verbose "`$hshOutput.FuncName: $($hshOutput.FuncName)" ; 
                    } ;
                    if($hshOutput.isFunc -AND (gv PSCmdletproxy -ea 0).value -eq $null){
                        $hshOutput.isFuncAdv = $false 
                    }elseif($hshOutput.isFunc){
                        $hshOutput.isFuncAdv = [boolean]($hshOutput.isFunc -AND $hshOutput.PSCmdletproxy.MyInvocation.InvocationName -AND ($hshOutput.FuncName -eq $hshOutput.PSCmdletproxy.MyInvocation.InvocationName)) ; 
                    } ; 
                    if($hshOutput.isFunc -AND $hshOutput.PSScriptRootproxy){
                        $hshOutput.FuncDir = $hshOutput.PSScriptRootproxy ; 
                    } ; 
                    $hshOutput.isScript = [boolean]($hshOutput.MyInvocationproxy.MyCommand.commandtype -eq 'ExternalScript' -OR $hshOutput.PSCmdletproxy.MyInvocation.InvocationName -match '\.ps1$') ; 
                    $hshOutput.isScriptUnpathed = [boolean]($hshOutput.PSCmdletproxy.MyInvocation.InvocationName  -match '^\.') ; # dot-sourced invocation, no paths will be stored in `$MyInvocation objects 
                    [array]$score = @() ; 
                    if($hshOutput.PSCmdletproxy.MyInvocation.InvocationName){ 
                        # blank on basic funcs, popd on AdvFuncs
                        if($hshOutput.PSCmdletproxy.MyInvocation.InvocationName -match '\.ps1$'){$score+= 'ExternalScript' 
                        }elseif($hshOutput.PSCmdletproxy.MyInvocation.InvocationName  -match '^\.'){
                            write-warning "dot-sourced invocation detected!:$($hshOutput.PSCmdletproxy.MyInvocation.InvocationName)`n(will be unable to leverage script path etc from `$MyInvocation objects)" ; 
                            write-verbose "(dot sourcing is implicit script exec)" ; 
                            $score+= 'ExternalScript' ; 
                        } else {$score+= 'Function' }; # blank under function exec, has func name under AdvFuncs
                    } ; 
                    if($hshOutput.PSCmdletproxy.CommandRuntime){
                        # blank on nonAdvfuncs, 
                        if($hshOutput.PSCmdletproxy.CommandRuntime.tostring() -match '\.ps1$'){$score+= 'ExternalScript' } else {$score+= 'Function' } ; # blank under function exec, func name on AdvFuncs
                    } ; 
                    $score+= $hshOutput.MyInvocationproxy.MyCommand.commandtype.tostring() ; # returns 'Function' for basic & Adv funcs
                    $grpSrc = $score | group-object -NoElement | sort count ;
                    if( ($grpSrc |  measure | select -expand count) -gt 1){
                        write-warning  "$score mixed results:$(($grpSrc| ft -a count,name | out-string).trim())" ;
                        if($grpSrc[-1].count -eq $grpSrc[-2].count){
                            write-warning "Deadlocked non-majority results!" ;
                        } else {
                            $hshOutput.runSource = $grpSrc | select -last 1 | select -expand name ;
                        } ;
                    } else {
                        write-verbose "consistent results" ;
                        $hshOutput.runSource = $grpSrc | select -last 1 | select -expand name ;
                    };
                    if($hshOutput.runSource -eq 'Function'){
                        if($hshOutput.isFuncAdv){
                            $smsg = "Calculated `$hshOutput.runSource:Advanced $($hshOutput.runSource)"
                        } else { 
                            $smsg = "Calculated `$hshOutput.runSource: Basic $($hshOutput.runSource)"
                        } ; 
                    }elseif($hshOutput.runSource -eq 'ExternalScript'){
                        $smsg =  "Calculated `$hshOutput.runSource:$($hshOutput.runSource)" ;
                    } ; 
                    write-verbose $smsg ;
                    'score','grpSrc' | get-variable | remove-variable ; # cleanup temp varis
                    $hshOutput.CmdletName = $hshOutput.PSCmdletproxy.MyInvocation.MyCommand.Name ; # function self-name (equiv to script's: $MyInvocation.MyCommand.Path), pop'd on AdvFunc
                    #region PsParams ; #*------v PSPARAMS v------
                    $hshOutput.PSParameters = New-Object -TypeName PSObject -Property $hshOutput.PSBoundParametersproxy ;
                    # DIFFERENCES $hshOutput.PSParameters vs $PSBoundParameters:
                    # - $PSBoundParameters: System.Management.Automation.PSBoundParametersDictionary (native obj)
                    # test/access: ($PSBoundParameters['Verbose'] -eq $true) ; $PSBoundParameters.ContainsKey('Referrer') #hash syntax
                    # CAN use as a @PSBoundParameters splat to push through (make sure populated, can fail if wrong type of wrapping code)
                    # - $hshOutput.PSParameters: System.Management.Automation.PSCustomObject (created obj)
                    # test/access: ($hshOutput.PSParameters.verbose -eq $true) ; $hshOutput.PSParameters.psobject.Properties.name -contains 'SenderAddress' ; # cobj syntax
                    # CANNOT use as a @splat to push through (it's a cobj)
                    write-verbose "`$hshOutput.PSBoundParametersproxy:`n$(($hshOutput.PSBoundParametersproxy|out-string).trim())" ;
                    # pre psv2, no $hshOutput.PSBoundParametersproxy autovari to check, so back them out:
                    if($hshOutput.PSCmdletproxy.MyInvocation.InvocationName){
                        # has func name under AdvFuncs
                        if($hshOutput.PSCmdletproxy.MyInvocation.InvocationName  -match '^\.'){
                            $smsg = "detected dot-sourced invocation: Skipping `$PSCmdlet.MyInvocation.InvocationName-tied cmds..." ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        } else { 
                            write-verbose 'Collect all non-default Params (works back to psv2 w CmdletBinding)'
                            $hshOutput.ParamsNonDefault = (Get-Command $hshOutput.PSCmdletproxy.MyInvocation.InvocationName).parameters | 
                                Select-Object -expand keys | 
                                Where-Object{$_ -notmatch '(Verbose|Debug|ErrorAction|WarningAction|ErrorVariable|WarningVariable|OutVariable|OutBuffer)'} ;
                        } ; 
                    } else { 
                        $smsg = "(blank `$hshOutput.PSCmdletproxy.MyInvocation.InvocationName, skipping Parameters collection)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    } ; 
                    if($hshOutput.isScript){
                        $hshOutput.ScriptDir = $scriptName = '' ;     
                        if($hshOutput.isScript){
                            $hshOutput.ScriptDir = $hshOutput.PSScriptRootproxy; 
                            $hshOutput.ScriptName = $hshOutput.PSCommandPathproxy ; 
                            if($hshOutput.ScriptDir -eq '' -AND $hshOutput.runSource -eq 'ExternalScript'){$hshOutput.ScriptDir = (Split-Path -Path $hshOutput.MyInvocationproxy.MyCommand.Source -Parent)} # Running from File
                        };

                        if($hshOutput.ScriptDir -eq '' -AND (Test-Path variable:psEditor)) {
                            write-verbose "Running from VSCode|VS" ; 
                            $hshOutput.ScriptDir = (Split-Path -Path $psEditor.GetEditorContext().CurrentFile.Path -Parent) ; 
                                if($hshOutput.ScriptName -eq ''){$hshOutput.ScriptName = $psEditor.GetEditorContext().CurrentFile.Path }; 
                        } ;
                        if ($hshOutput.ScriptDir -eq '' -AND $host.version.major -lt 3 -AND $hshOutput.MyInvocationproxy.MyCommand.Path.length -gt 0){
                            $hshOutput.ScriptDir = $hshOutput.MyInvocationproxy.MyCommand.Path ; 
                            write-verbose "(backrev emulating `$hshOutput.PSScriptRootproxy, `$hshOutput.PSCommandPathproxy)"
                            $hshOutput.ScriptName = split-path $hshOutput.MyInvocationproxy.MyCommand.Path -leaf ;
                            $hshOutput.PSScriptRootproxy = Split-Path $hshOutput.ScriptName -Parent ;
                            $hshOutput.PSCommandPathproxy = $hshOutput.ScriptName ;
                        } ;
                        if ($hshOutput.ScriptDir -eq '' -AND $hshOutput.MyInvocationproxy.MyCommand.Path.length){
                            if($hshOutput.ScriptName -eq ''){$hshOutput.ScriptName = $hshOutput.MyInvocationproxy.MyCommand.Path} ;
                            $hshOutput.ScriptDir = $hshOutput.PSScriptRootproxy = Split-Path $hshOutput.MyInvocationproxy.MyCommand.Path -Parent ;
                        }
                        if ($hshOutput.ScriptDir -eq ''){throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$hshOutput.MyInvocationproxy IS BLANK!" } ;
                        if($hshOutput.ScriptName){
                            if(-not $hshOutput.ScriptDir ){$hshOutput.ScriptDir = Split-Path -Parent $hshOutput.ScriptName} ; 
                            $hshOutput.ScriptBaseName = split-path -leaf $hshOutput.ScriptName ;
                            $hshOutput.ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($hshOutput.ScriptName) ;
                        } ; 
                        # blank $cmdlet name comming through, patch it for Scripts:
                        if(-not $hshOutput.CmdletName -AND $hshOutput.ScriptBaseName){
                            $hshOutput.CmdletName = $hshOutput.ScriptBaseName
                        }
                        # last ditch patch the values in if you've got a $hshOutput.ScriptName
                        if($hshOutput.PSScriptRootproxy.Length -ne 0){}else{ 
                            if($hshOutput.ScriptName){$hshOutput.PSScriptRootproxy = Split-Path $hshOutput.ScriptName -Parent }
                            else{ throw "Unpopulated, `$hshOutput.PSScriptRootproxy, and no populated `$hshOutput.ScriptName from which to emulate the value!" } ; 
                        } ; 
                        if($hshOutput.PSCommandPathproxy.Length -ne 0){}else{ 
                            if($hshOutput.ScriptName){$hshOutput.PSCommandPathproxy = $hshOutput.ScriptName }
                            else{ throw "Unpopulated, `$hshOutput.PSCommandPathproxy, and no populated `$hshOutput.ScriptName from which to emulate the value!" } ; 
                        } ; 
                        if(-not ($hshOutput.ScriptDir -AND $hshOutput.ScriptBaseName -AND $hshOutput.ScriptNameNoExt  -AND $hshOutput.PSScriptRootproxy  -AND $hshOutput.PSCommandPathproxy )){ 
                            throw "Invalid Invocation. Blank `$hshOutput.ScriptDir/`$hshOutput.ScriptBaseName/`$hshOutput.ScriptBaseName" ; 
                            BREAK ; 
                        } ; 
                    } ; 
                    if($hshOutput.isFunc){
                        if($hshOutput.isFuncAdv){
                            # AdvFunc-specific cmds
                        }else {
                            # Basic Func-specific cmds
                        } ; 
                        if($hshOutput.PSCommandPathproxy -match '\.psm1$'){
                            write-host "MODULE-HOMED FUNCTION:Use `$hshOutput.CmdletName to reference the running function name for transcripts etc (under a .psm1 `$hshOutput.ScriptName will reflect the .psm1 file  fullname)"
                            if(-not $hshOutput.CmdletName){write-warning "MODULE-HOMED FUNCTION with BLANK `$CmdletNam:$($CmdletNam)" } ;
                        } # Running from .psm1 module
                        if(-not $hshOutput.CmdletName -AND $hshOutput.FuncName){
                            $hshOutput.CmdletName = $hshOutput.FuncName
                        } ; 
                    } ; 
                    $smsg = "`$hshOutput  w`n$(($hshOutput|out-string).trim())" ; 
                    #write-host $smsg ; 
                    write-verbose $smsg ; 
                } ;  # BEG-E
                PROCESS {};  # PROC-E
                END {
                    if($hshOutput){
                        write-verbose "(return `$hshOutput to pipeline)" ; 
                        New-Object PSObject -Property $hshOutput | write-output 
                    } ; 
                }
            } ; 
            #*------^ END Function resolve-EnvironmentTDO() ^------ 
        } ;
        #endregion RESOLVE_ENVIRONMENTTDO ; #*------^ END resolve-EnvironmentTDO ^------
    
        #region WRITE_LOG ; #*------v write-log v------
        if(-not(gci function:write-log -ea 0)){
            function write-log  {
                <#
                .SYNOPSIS
                Write-Log.ps1 - Write-Log writes a message to a specified log file with the current time stamp, and write-verbose|warn|error's the matching msg.
                .NOTES
                REVISIONS
                * 1:42 PM 11/8/2024 CBH expl fixes
                .PARAMETER Object <System.Object>
                    Objects to display in the host.
                    .PARAMETER Path
                    The path to the log file to which you would like to write. By default the function will create the path and file if it does not exist.
                    .PARAMETER Level
                    Specify the criticality of the log information being written to the log (defaults Info): (Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success)[-level Info]
                    .PARAMETER useHost
                    Switch to use write-host rather than write-[verbose|warn|error] (does not apply to H1|H2|H3|DEBUG which alt via uncolored write-host) [-useHost]
                    .PARAMETER NoEcho
                    Switch to suppress console echos (e.g log to file only [-NoEcho]
                    .PARAMETER NoClobber
                    Use NoClobber if you do not wish to overwrite an existing file.
                    .PARAMETER BackgroundColor
                    Specifies the background color. There is no default. The acceptable values for this parameter are:
                    (Black | DarkBlue | DarkGreen | DarkCyan | DarkRed | DarkMagenta | DarkYellow | Gray | DarkGray | Blue | Green | Cyan | Red | Magenta | Yellow | White)
                    .PARAMETER ForegroundColor <System.ConsoleColor>
                    Specifies the text color. There is no default. The acceptable values for this parameter are:
                    (Black | DarkBlue | DarkGreen | DarkCyan | DarkRed | DarkMagenta | DarkYellow | Gray | DarkGray | Blue | Green | Cyan | Red | Magenta | Yellow | White)
                    .PARAMETER NoNewline <System.Management.Automation.SwitchParameter>
                    The string representations of the input objects are concatenated to form the output. No spaces or newlines are inserted between
                    the output strings. No newline is added after the last output string.
                    .PARAMETER Separator <System.Object>
                    Specifies a separator string to insert between objects displayed by the host.
                    .PARAMETER PadChar
                    Character to use for padding (defaults to a space).[-PadChar '-']
                    .PARAMETER usePID
                    Switch to use the `$PID in the `$env:HostIndentSpaces name (Env:HostIndentSpaces`$PID)[-usePID]
                    .PARAMETER Indent
                    Switch to use write-HostIndent-type code for console echos(see get-help write-HostIndent)[-Indent]
                    .PARAMETER Flatten
                    Switch to strip empty lines when using -Indent (which auto-splits multiline Objects)[-Flatten]
                    .PARAMETER ShowDebug
                    Parameter to display Debugging messages [-ShowDebug switch]
                    .PARAMETER demo
	                Switch to output a demo display of each Level, and it's configured color scheme (requires specification of a 'dummy' message string to avoid an error).[-Demo]
                    .EXAMPLE
                    PS>  Write-Log -Message 'Log message'   ;
                    Writes the message to default log loc (c:\Logs\PowerShellLog.log, -level defaults to Info).
                    .EXAMPLE
                    PS> Write-Log -Message 'Restarting Server.' -Path c:\Logs\Scriptoutput.log ;
                    Writes the content to the specified log file and creates the path and file specified.
                    .EXAMPLE
                    PS> write-log -level warn "some information" -Path c:\tmp\tmp.txt
                    WARNING: 10:17:59: some information
                    Demo default use of the native write-warning cmdlet (default behavior when -useHost is not used)
                    .EXAMPLE
                    PS> write-log -level warn "some information" -Path c:\tmp\tmp.txt -usehost
                        10:19:14: WARNING: some information
                    Demo use of the "warning" color scheme write-host cmdlet (behavior when -useHost *IS* used)
                    .EXAMPLE
                    PS> Write-Log -level Prompt -Message "Enter Text:" -Path c:\tmp\tmp.txt -usehost  ;
                    PS> invoke-soundcue -type question ;
                    PS> $enteredText = read-host ;
                    Echo's a distinctive Prompt color scheme for the message (vs using read-host native non-color-differentiating -prompt parameter), and writes a 'Prompt'-level entry to the log, uses my verb-io:invoke-soundCue to play a the system question sound; then uses promptless read-host to take typed input.
                    PS> Write-Log -level Prompt -Message "Enter Password:" -Path c:\tmp\tmp.txt -usehost  ;
                    PS> invoke-soundcue -type question ;
                    PS> $SecurePW = read-host -AsSecureString ;
                    Variant that demos collection of a secure password using read-host's native -AsSecureString param.
                    .EXAMPLE
                    PS>  $smsg = "ENTER CERTIFICATE PFX Password: (use 'dummy' for UserName)" ;
                    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT }
                    PS>  else{ write-host -foregroundcolor Blue -backgroundcolor White "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    PS>  $pfxcred=(Get-Credential -credential dummy) ;
                    PS>  Export-PfxCertificate -Password $pfxcred.password -Cert= $certpath -FilePath c:\path-to\output.pfx;
                    Demo use of write-log -level prompt, leveraging the get-credential popup GUI to collect a secure password (without use of username)
                    .EXAMPLE
                    PS>  # init content in script context ($MyInvocation is blank in function scope)
                    PS>  $logfile = join-path -path $ofile -childpath "$([system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName))-BATCH-$(get-date -format 'yyyyMMdd-HHmmtt')-LOG.txt"  ;
                    PS>  $logging = $True ;
                    PS>  $sBnr="#*======v `$tmbx:($($Procd)/$($ttl)):$($tmbx) v======" ;
                    PS>  $smsg="$($sBnr)" ;
                    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug|H1|H2|H3
                    PS>  else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Demo with conditional write-log (with -useHost switch, to trigger native write-host use), else failthru to write-host output
                    PS>  .EXAMPLE
                    PS>  $transcript = join-path -path (Split-Path -parent $MyInvocation.MyCommand.Definition) -ChildPath "logs" ;
                    PS>  if(!(test-path -path $transcript)){ "Creating missing log dir $($transcript)..." ; mkdir $transcript  ; } ;
                    PS>  $transcript=join-path -path $transcript -childpath "$([system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName))"  ;
                    PS>  $transcript+= "-Transcript-BATCH-$(get-date -format 'yyyyMMdd-HHmmtt')-trans-log.txt"  ;
                    PS>  # add log file variant as target of Write-Log:
                    PS>  $logfile=$transcript.replace("-Transcript","-LOG").replace("-trans-log","-log")
                    PS>  if($whatif){
                    PS>      $logfile=$logfile.replace("-BATCH","-BATCH-WHATIF") ;
                    PS>      $transcript=$transcript.replace("-BATCH","-BATCH-WHATIF") ;
                    PS>  } else {
                    PS>      $logfile=$logfile.replace("-BATCH","-BATCH-EXEC") ;
                    PS>      $transcript=$transcript.replace("-BATCH","-BATCH-EXEC") ;
                    PS>  } ;
                    PS>  if($Ticket){
                    PS>      $logfile=$logfile.replace("-BATCH","-$($Ticket)") ;
                    PS>      $transcript=$transcript.replace("-BATCH","-$($Ticket)") ;
                    PS>  } else {
                    PS>      $logfile=$logfile.replace("-BATCH","-nnnnnn") ;
                    PS>      $transcript=$transcript.replace("-BATCH","-nnnnnn") ;
                    PS>  } ;
                    PS>  $logging = $True ;
                    PS>  $sBnr="#*======v START PASS:$($ScriptBaseName) v======" ;
                    PS>  $smsg= "$($sBnr)" ;
                    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                    More complete boilerplate including $whatif & $ticket
                    .EXAMPLE
                    PS>  $pltSL=@{ NoTimeStamp=$false ; Tag = $null ; showdebug=$($showdebug) ; whatif=$($whatif) ; Verbose=$($VerbosePreference -eq 'Continue') ; } ;
                    PS>  $pltSL.Tag = "$(split-path -path $CSVPath -leaf)"; # build tag from a variable
                    PS>  # construct log name on calling script/function fullname
                    PS>  if($PSCommandPath){ $logspec = start-Log -Path $PSCommandPath @pltSL }
                    PS>  else { $logspec = start-Log -Path ($MyInvocation.MyCommand.Definition) @pltSL } ;
                    PS>  if($logspec){
                    PS>      $logging=$logspec.logging ;
                    PS>      $logfile=$logspec.logfile ;
                    PS>      $transcript=$logspec.transcript ;
                    PS>      $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                    PS>      start-Transcript -path $transcript ;
                    PS>  } else {throw "Unable to configure logging!" } ;
                    PS>  $sBnr="#*======v $(${CmdletName}): v======" ;
                    PS>  $smsg = $sBnr ;
                    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    PS>  else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Demo leveraging splatted start-log(), and either $PSCommandPath or $MyInvocation (support varies by host/psversion) to build the log name.
                    .EXAMPLE
                    PS> write-log -demo -message 'Dummy' ;
                    Demo (using required dummy error-suppressing messasge) of sample outputs/color combos for each Level configured).
                    .EXAMPLE
                    PS>  $smsg = "`n`n===TESTIPAddress: was *validated* as covered by the recursed ipv4 specification:" ;
                    PS>  $smsg += "`n" ;
                    PS>  $smsg += "`n---> This host *should be able to* send email on behalf of the configured SPF domain (at least in terms of SPF checks)" ;
                    PS>  $env:hostindentspaces = 8 ;
                    PS>  $lvl = 'Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success'.split('|') ;
                    PS>  foreach ($l in $lvl){Write-Log -LogContent $smsg -Path $tmpfile -Level $l -useHost -Indent} ;
                    Demo indent function across range of Levels (alt to native -Demo which also supports -indent).
                    .EXAMPLE
                    PS>  write-verbose 'set to baseline' ;
                    PS>  reset-HostIndent ;
                    PS>  write-host "`$env:HostIndentSpaces:$($env:HostIndentSpaces)" ;
                    PS>  write-verbose 'write an H1 banner'
                    PS>  $sBnr="#*======v  H1 Banner: v======" ;
                    PS>  $smsg = $sBnr ;
                    PS>  Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1;
                    PS>  write-verbose 'push indent level+1' ;
                    PS>  push-HostIndent ;
                    PS>  write-host "`$env:HostIndentSpaces:$($env:HostIndentSpaces)" ;
                    PS>  write-verbose 'write an INFO entry with -Indent specified' ;
                    PS>  $smsg = "This is information (indented)" ;
                    PS>  Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info -Indent:$true ;
                    PS>  write-verbose 'push indent level+2' ;
                    PS>  push-HostIndent ;
                    PS>  write-host "`$env:HostIndentSpaces:$($env:HostIndentSpaces)" ;
                    PS>  write-verbose 'write a PROMPT entry with -Indent specified' ;
                    PS>  $smsg = "This is a subset of information (indented)" ;
                    PS>  Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt -Indent:$true ;
                    PS>  write-verbose 'pop indent level out one -1' ;
                    PS>  pop-HostIndent ;
                    PS>  write-verbose 'write a Success entry with -Indent specified' ;
                    PS>  $smsg = "This is a Successful information (indented)" ;
                    PS>  Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success -Indent:$true ;
                    PS>  write-verbose 'reset to baseline for trailing banner'
                    PS>  reset-HostIndent ;
                    PS>  write-host "`$env:HostIndentSpaces:$($env:HostIndentSpaces)" ;
                    PS>  write-verbose 'write the trailing H1 banner'
                    PS>  $smsg = "$($sBnr.replace('=v','=^').replace('v=','^='))" ;
                    PS>  Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1;
                    PS>  write-verbose 'clear indent `$env:HostIndentSpaces' ;
                    PS>  clear-HostIndent ;
                    PS>  write-host "`$env:HostIndentSpaces:$($env:HostIndentSpaces)" ;
                        $env:HostIndentSpaces:0
                        16:16:17: #  #*======v  H1 Banner: v======
                        $env:HostIndentSpaces:4
                            16:16:17: INFO:  This is information (indented)
                        $env:HostIndentSpaces:8
                                16:16:17: PROMPT:  This is a subset of information (indented)
                            16:16:17: SUCCESS:  This is a Successful information (indented)
                        $env:HostIndentSpaces:0
                        16:16:17: #  #*======^  H1 Banner: ^======
                        $env:HostIndentSpaces:
                    Demo broad process for use of verb-HostIndent funcs and write-log with -indent parameter.
                    .EXAMPLE
                    PS>  write-host "`n`n" ;
                    PS>  $smsg = "`n`n==ALL Grouped Status.errorCode :`n$(($EVTS.status.errorCode | group| sort count -des | format-table -auto count,name|out-string).trim())" ;
                    PS>  $colors = (get-colorcombo -random) ;
                    PS>  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info -Indent @colors -flatten }
                    PS>  else{ write-host @colors  "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    PS>  PS>  write-host "`n`n" ;
                    When using -Indent with group'd or other cmd-multiline output, you will want to:
                    1. use the...
                        $smsg = $(([results]|out-string).trim())"
                        ...structure to pre-clean & convert from [FormatEntryData] to [string]
                        (avoids errors, due to formatteddata *not* having split mehtod)
                    2. Use -flatten to avoid empty _colored_ lines between each entry in the output (and sprinkle write-host "`n`n"'s pre/post for separation).
                    These issues only occur under -Indent use, due to the need to `$Object.split to get each line of indented object properly collored and indented.
                    .EXAMPLE
                    PS> $pltH1=@{foregroundcolor='black';backgroundcolor='darkyellow'};
                    PS> write-host "Running demo of current settings..." @pltH1
                    PS> $combos = "H1; #*======v STATUSMSG: SBNR v======","H2;`n#*------v PROCESSING : sBnrS v------","H3;`n#*~~~~~~v SUB-PROCESSING : sBnr3 v~~~~~~","H4;`n#*``````v DETAIL : sBnr4 v``````","H5;`n#*______v FOCUS : sBnr5 v______","INFO;This is typical output","PROMPT;What is your quest?","SUCCESS;Successful execution!","WARN;THIS DIDN'T GO AS PLANNED","ERROR;UTTER FAILURE!","VERBOSE;internal comment executed"
                    PS> $tmpfile = [System.IO.Path]::GetTempFileName().replace('.tmp','.txt') ;
                    PS> foreach($cmbo in $combos){
                    PS>     $level,$text = $cmbo.split(';') ;
                    PS>     $pltWL=@{
                    PS>         message= $text ;
                    PS>         Level=$Level ;
                    PS>         Path=$tmpfile  ;
                    PS>         useHost=$true;
                    PS>     } ;
                    PS>     if($Indent){$PltWL.add('Indent',$true)} ;
                    PS>     $whsmsg = "write-log w`n$(($pltWL|out-string).trim())`n" ;
                    PS>     write-host $whsmsg ;
                    PS>     write-logNoDep @pltWL ;
                    PS> } ;
                    PS> remove-item -path $tmpfile ;
                    Demo code adapted from the -demo param, for manual passes.
                #>[CmdletBinding()]
                PARAM (
                        [Parameter(Mandatory = $true, ValueFromPipelineByPropertyName = $true,
                            HelpMessage = "Message is the content that you wish to add to the log file")]
                            [ValidateNotNullOrEmpty()]
                            [Alias("LogContent",'Message')]
                            [System.Object]$Object,
                        [Parameter(Mandatory = $false,
                            HelpMessage = "The path to the log file to which you would like to write. By default the function will create the path and file if it does not exist.")]
                            [Alias('LogPath')]
                            [string]$Path = 'C:\Logs\PowerShellLog.log',
                        [Parameter(Mandatory = $false,
                            HelpMessage = "Specify the criticality of the log information being written to the log (defaults Info): (Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success)[-level Info]")]
                            [ValidateSet('Error','Warn','Info','H1','H2','H3','H4','H5','Debug','Verbose','Prompt','Success')]
                            [string]$Level = "Info",
                        [Parameter(
                            HelpMessage = "Switch to use write-host rather than write-[verbose|warn|error] [-useHost]")]
                            [switch] $useHost,
                        [Parameter(
                            HelpMessage="Specifies the background color. There is no default. The acceptable values for this parameter are:
                    (Black | DarkBlue | DarkGreen | DarkCyan | DarkRed | DarkMagenta | DarkYellow | Gray | DarkGray | Blue | Green | Cyan | Red | Magenta | Yellow | White)")]
                            [System.ConsoleColor]$BackgroundColor,
                        [Parameter(
                            HelpMessage="Specifies the text color. There is no default. The acceptable values for this parameter are:
                (Black | DarkBlue | DarkGreen | DarkCyan | DarkRed | DarkMagenta | DarkYellow | Gray | DarkGray | Blue | Green | Cyan | Red | Magenta | Yellow | White)")]
                            [System.ConsoleColor]$ForegroundColor,
                        [Parameter(
                            HelpMessage="The string representations of the input objects are concatenated to form the output. No spaces or newlines are inserted between
                the output strings. No newline is added after the last output string.")]
                            [System.Management.Automation.SwitchParameter]$NoNewline,
                        [Parameter(
                            HelpMessage = "Switch to use write-HostIndent-type code for console echos(see get-help write-HostIndent)[-Indent]")]
                            [Alias('in')]
                            [switch] $Indent,
                        [Parameter(
                            HelpMessage="Switch to use the `$PID in the `$env:HostIndentSpaces name (Env:HostIndentSpaces`$PID)[-usePID]")]
                            [switch]$usePID,
                        [Parameter(
                            HelpMessage = "Switch to strip empty lines when using -Indent (which auto-splits multiline Objects)[-Flatten]")]
                            #[Alias('flat')]
                            [switch] $Flatten,
                        [Parameter(
                            HelpMessage="Specifies a separator string to insert between objects displayed by the host.")]
                        [System.Object]$Separator,
                        [Parameter(
                            HelpMessage="Character to use for padding (defaults to a space).[-PadChar '-']")]
                        [string]$PadChar = ' ',
                        [Parameter(
                            HelpMessage="Number of spaces to pad by default (defaults to 4).[-PadIncrment 8]")]
                        [int]$PadIncrment = 4,
                        [Parameter(
                            HelpMessage = "Switch to suppress console echos (e.g log to file only [-NoEcho]")]
                            [switch] $NoEcho,
                        [Parameter(Mandatory = $false,
                            HelpMessage = "Use NoClobber if you do not wish to overwrite an existing file.")]
                            [switch]$NoClobber,
                        [Parameter(
                            HelpMessage = "Debugging Flag [-showDebug]")]
                            [switch] $showDebug,
                        [Parameter(
                            HelpMessage = "Switch to output a demo display of each Level, and it's configured color scheme (requires specification of a 'dummy' message string to avoid an error).[-Demo]")]
                            [switch] $demo
                    )  ;
                BEGIN {
                    #region CONSTANTS-AND-ENVIRO #*======v CONSTANTS-AND-ENVIRO v======
                    # function self-name (equiv to script's: $MyInvocation.MyCommand.Path) ;
                    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
                    if(($PSBoundParameters.keys).count -ne 0){
                        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
                        write-verbose "$($CmdletName): `$PSBoundParameters:`n$(($PSBoundParameters|out-string).trim())" ;
                    } ; 
                    $Verbose = ($VerbosePreference -eq 'Continue') ;     
                    #$VerbosePreference = "SilentlyContinue" ;
                    #endregion CONSTANTS-AND-ENVIRO #*======^ END CONSTANTS-AND-ENVIRO ^======

                    $pltWH = @{
                            Object = $null ;
                    } ;
                    if ($PSBoundParameters.ContainsKey('BackgroundColor')) {
                        $pltWH.add('BackgroundColor',$BackgroundColor) ;
                    } ;
                    if ($PSBoundParameters.ContainsKey('ForegroundColor')) {
                        $pltWH.add('ForegroundColor',$ForegroundColor) ;
                    } ;
                    if ($PSBoundParameters.ContainsKey('NoNewline')) {
                        $pltWH.add('NoNewline',$NoNewline) ;
                    } ;
                    if($Indent){
                        if ($PSBoundParameters.ContainsKey('Separator')) {
                            $pltWH.add('Separator',$Separator) ;
                        } ;
                        write-verbose "$($CmdletName): Using `$PadChar:`'$($PadChar)`'" ;
            
                        #if we want to tune this to a $PID-specific variant, use:
                        if($usePID){
                            $smsg = "-usePID specified: `$Env:HostIndentSpaces will be suffixed with this process' `$PID value!" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            $HISName = "Env:HostIndentSpaces$($PID)" ;
                        } else {
                            $HISName = "Env:HostIndentSpaces" ;
                        } ;
                        if(($smsg = Get-Item -Path "Env:HostIndentSpaces$($PID)" -erroraction SilentlyContinue).value){
                            write-verbose $smsg ;
                        } ;
                        if (-not ([int]$CurrIndent = (Get-Item -Path $HISName -erroraction SilentlyContinue).Value ) ){
                            [int]$CurrIndent = 0 ;
                        } ;
                        write-verbose "$($CmdletName): Discovered `$$($HISName):$($CurrIndent)" ;
            
                    } ;
                    if(get-command get-colorcombo -ErrorAction SilentlyContinue){$buseCC=$true} else {$buseCC=$false} ;
                   
                    if ($host.Name -eq 'Windows PowerShell ISE Host' -AND $host.version.major -lt 3){
                            write-verbose "PSISE under psV2 has wacky inconsistent colors - only *some* even display, others default to white`nso we choose fundementally wrong colors, to approximate the target colors" ;
                            $pltError=@{foregroundcolor='DarkYellow';backgroundcolor='Red'};
                            $pltWarn=@{foregroundcolor='DarkMagenta';backgroundcolor='DarkCyan'};
                            $pltInfo=@{foregroundcolor='Blue';backgroundcolor='darkGreen'};
                            $pltH1=@{foregroundcolor='black';backgroundcolor='darkyellow'};
                            $pltH2=@{foregroundcolor='darkblue';backgroundcolor='cyan'};
                            $pltH3=@{foregroundcolor='black';backgroundcolor='cyan'};
                            $pltH4=@{foregroundcolor='black';backgroundcolor='DarkMagenta'};
                            $pltH5=@{foregroundcolor='cyan';backgroundcolor='Green'};
                            $pltDebug=@{foregroundcolor='red';backgroundcolor='black'};
                            $pltVerbose=@{foregroundcolor='darkgray';backgroundcolor='darkred'};
                            $pltPrompt=@{foregroundcolor='White';backgroundcolor='DarkBlue'};
                            $pltSuccess=@{foregroundcolor='DarkGray';backgroundcolor='green'};
                    } else {
                        
                        $pltError=@{foregroundcolor='yellow';backgroundcolor='darkred'};
                        $pltWarn=@{foregroundcolor='DarkMagenta';backgroundcolor='yellow'};
                        $pltInfo=@{foregroundcolor='gray';backgroundcolor='darkblue'};
                        $pltH1=@{foregroundcolor='black';backgroundcolor='darkyellow'};
                        $pltH2=@{foregroundcolor='darkblue';backgroundcolor='gray'};
                        $pltH3=@{foregroundcolor='black';backgroundcolor='darkgray'};
                        $pltH4=@{foregroundcolor='gray';backgroundcolor='DarkCyan'};
                        $pltH5=@{foregroundcolor='cyan';backgroundcolor='DarkGreen'};
                        $pltDebug=@{foregroundcolor='red';backgroundcolor='black'};
                        $pltVerbose=@{foregroundcolor='darkgray';backgroundcolor='black'};
                        $pltPrompt=@{foregroundcolor='DarkMagenta';backgroundcolor='darkyellow'};
                        $pltSuccess=@{foregroundcolor='Blue';backgroundcolor='green'};
                    } ; 

                    if ($PSCmdlet.MyInvocation.ExpectingInput) {
                        write-verbose "Data received from pipeline input: '$($InputObject)'" ; 
                    } else {
                        #write-verbose "Data received from parameter input: '$($InputObject)'" ; 
                        write-verbose "(non-pipeline - param - input)" ; 
                    } ; 
                }  ;
                PROCESS {

                    if($Demo){
                            write-host "Running demo of current settings..." @pltH1
                            $combos = "h1m;H1","h2m;H2","h3m;H3","h4m;H4","h5m;H5",
                                "whm;INFO","whp;PROMPT","whs;SUCCESS","whw;WARN","wem;ERROR","whv;VERBOSE" ;
                            $h1m =" #*======v STATUSMSG: SBNR v======" ;
                            $h2m = "`n#*------v PROCESSING : sBnrS v------" ;
                            $h3m ="`n#*~~~~~~v SUB-PROCESSING : sBnr3 v~~~~~~" ;
                            $h4m="`n#*``````v DETAIL : sBnr4 v``````" ;
                            $h5m="`n#*______v FOCUS : sBnr5 v______" ;
                            $whm = "This is typical output" ;
                            $whp = "What is your quest?" ;
                            $whs = "Successful execution!" ;
                            $whw = "THIS DIDN'T GO AS PLANNED" ;
                            $wem = "UTTER FAILURE!" ;
                            $whv = "internal comment executed" ;
                            $tmpfile = [System.IO.Path]::GetTempFileName().replace('.tmp','.txt') ;
                            foreach($cmbo in $combos){
                                $txt,$name = $cmbo.split(';') ;
                                $Level = $name ;
                                if($Level -eq 'H5'){
                                    write-host "Gotcha!";
                                } ;
                                $whplt = (gv "plt$($name)").value ;
                                $text = (gv $txt).value ;
                                #$smsg="`$plt$($name):($($whplt.foregroundcolor):$($whplt.backgroundcolor)):`n`n$($text)`n`n" ;
                                $whsmsg="`$plt$($name):($($whplt.foregroundcolor):$($whplt.backgroundcolor)):`n`n" ;
                                $pltWL=@{
                                    message= $text ;
                                    Level=$Level ;
                                    Path=$tmpfile  ;
                                    useHost=$true;
                                } ;
                                if($Indent){$PltWL.add('Indent',$true)} ;
                                $whsmsg += "write-log w`n$(($pltWL|out-string).trim())`n" ;
                                write-host $whsmsg ;
                                write-log @pltWL ;
                            } ;
                            remove-item -path $tmpfile ;
                    } else {
            
                        if($Indent){
                            # move split/flatten into per-object level (was up in BEGIN):
                            # if $object has multiple lines, split it:
                            # have to coerce the system.object to string array, to get access to a .split method (raw object doese't have it)
                            # and you have to recast the type to string array (can't assign a string[] to [system.object] type vari
                            if($Flatten){
                                    if($object.gettype().name -eq 'FormatEntryData'){
                                        # this converts tostring() as the string: Microsoft.PowerShell.Commands.Internal.Format.FormatEntryData
                                        # issue is (group |  ft -a count,name)'s  that aren't put through $((|out-string).trim())
                                        write-verbose "skip split/flatten on these (should be pre-out-string'd before write-logging)" ;
                                    } else {
                                        TRY{
                                            [string[]]$Object = [string[]]$Object.ToString().Split([Environment]::NewLine) ; 
                                        } CATCH{
                                            write-verbose "Workaround err: The variable cannot be validated because the value System.String[] is not a valid value for the Object variable." ; 
                                            [string[]]$Object = ($Object|out-string).trim().Split([Environment]::NewLine) ; 
                                        } ; 
                                    } ;
                            } else {
                                [string[]]$Object = [string[]]$Object.ToString().Split([Environment]::NewLine)
                            } ;
                        } ; 

                        # If the file already exists and NoClobber was specified, do not write to the log.
                        if ((Test-Path $Path) -AND $NoClobber) {
                            Write-Error "Log file $Path already exists, and you specified NoClobber. Either delete the file or specify a different name."  ;
                            Return  ;
                        } elseif (!(Test-Path $Path)) {
                            Write-Verbose "Creating $Path."  ;
                            $NewLogFile = New-Item $Path -Force -ItemType File  ;
                        } else {
                          # Nothing to see here yet.
                        }  ;

                        $FormattedDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss"  ;
                        $EchoTime = "$((get-date).ToString('HH:mm:ss')): " ;
            
                        $pltWH.Object = $EchoTime ; 
                        $pltColors = @{} ; 
                        # Write message to error, warning, or verbose pipeline and specify $LevelText
                        switch ($Level) {
                            'Error' {
                                $LevelText = 'ERROR: ' ;
                                $pltColors = $pltError ;
                                if ($useHost) {} else {if (!$NoEcho) { Write-Error ($smsg + $Object) } } ;
                            }
                            'Warn' {
                                $LevelText = 'WARNING: ' ;
                                $pltColors = $pltWarn ;
                                if ($useHost) {} else {if (!$NoEcho) { Write-Warning ($smsg + $Object) } } ;
                            }
                            'Info' {
                                $LevelText = 'INFO: ' ;
                                $pltColors = $pltInfo ;
                            }
                            'H1' {
                                $LevelText = '# ' ;
                                $pltColors = $pltH1 ;
                            }
                            'H2' {
                                $LevelText = '## ' ;
                                $pltColors = $pltH2 ;
                            }
                            'H3' {
                                $LevelText = '### ' ;
                                $pltColors = $pltH3 ;
                            }
                            'H4' {
                                $LevelText = '#### ' ;
                                $pltColors = $pltH4 ;
                            }
                            'H5' {
                                $LevelText = '##### ' ;
                                $pltColors = $pltH5 ;
                            }
                            'Debug' {
                                $LevelText = 'DEBUG: ' ;
                                $pltColors = $pltDebug ;
                                if ($useHost) {} else {if (!$NoEcho) { Write-Degug $smsg } }  ;
                            }
                            'Verbose' {
                                $LevelText = 'VERBOSE: ' ;
                                $pltColors = $pltVerbose ;
                                if ($useHost) {}else {if (!$NoEcho) { Write-Verbose ($smsg) } } ;
                            }
                            'Prompt' {
                                $LevelText = 'PROMPT: ' ;
                                $pltColors = $pltPrompt ;
                            }
                            'Success' {
                                $LevelText = 'SUCCESS: ' ;
                                $pltColors = $pltSuccess ;
                            }
                        } ;
                        # build msg string down here, once, v in ea above
                        # always defer to explicit cmdline colors
                        if($pltColors.foregroundcolor){
                            if(-not ($pltWH.keys -contains 'foregroundcolor')){
                                $pltWH.add('foregroundcolor',$pltColors.foregroundcolor) ;
                            } elseif($pltWH.foregroundcolor -eq $null){
                                $pltWH.foregroundcolor = $pltColors.foregroundcolor ;
                            } ;
                        } ;
                        if($pltColors.backgroundcolor){
                            if(-not ($pltWH.keys -contains 'backgroundcolor')){
                                $pltWH.add('backgroundcolor',$pltColors.backgroundcolor) ;
                            } elseif($pltWH.backgroundcolor -eq $null){
                                $pltWH.backgroundcolor = $pltColors.backgroundcolor ;
                            } ;
                        } ;
 
                        if ($useHost) {
                            if(-not $Indent){
                                if($Level -match '(Debug|Verbose)' ){
                                    if(($Object|  measure).count -gt 1){
                                        $pltWH.Object += "$($LevelText) ($(($Object|out-string).trim()))" ;
                                    } else {
                                        #$pltWH.Object += ($LevelText + '(' + $Object + ')') ;
                                        $pltWH.Object += "$($LevelText) ($($Object))" ;
                                    } ;
                                } else {
                                    if(($Object|  measure).count -gt 1){
                                        $pltWH.Object += "$($LevelText) $(($Object|out-string).trim())" ;
                                    } else {
                                        #$pltWH.Object += $LevelText + $Object ;
                                        $pltWH.Object += "$($LevelText) $($Object)" ;
                                    } ;
                                } ;
                                $smsg = "write-host w`n$(($pltWH|out-string).trim())" ;
                                write-verbose $smsg ;
                                #write-host @pltErr $smsg ;
                                write-host @pltwh ;
                            } else {
                                foreach ($obj in $object){
                                    $pltWH.Object = $EchoTime ;
                                    if($Level -match '(Debug|Verbose)' ){
                                        if($obj.length -gt 0){
                                            $pltWH.Object += "$($LevelText) ($($obj))" ;
                                        } else {
                                            $pltWH.Object += "$($LevelText)" ;
                                        } ;
                                    } else {
                                        $pltWH.Object += "$($LevelText) $($obj)" ;
                                    } ;
                                    $smsg = "write-host w`n$(($pltWH|out-string).trim())" ;
                                    write-verbose $smsg ;
                                    Write-Host -NoNewline $($PadChar * $CurrIndent)  ;
                                    write-host @pltwh ;
                                } ;
                            } ;
                        }
                        # Write log entry to $Path
                        "$FormattedDate $LevelText : $Object" | Out-File -FilePath $Path -Append -encoding UTF8 ;
                    } ;  # if-E -Demo ; 
                }  ; # PROC-E
                End {}  ;
                  
            }
        } ; 
        #endregion WRITE_LOG ; #*------^ END write-log  ^------

        #region START_LOG ; #*------v Start-Log v------
        if(-not(get-command start-log -ea 0)){
            function Start-Log {
                <#
                .SYNOPSIS
                Start-Log.ps1 - Configure base settings for use of write-Log() logging
                .NOTES
                REVISIONS
               * 9:07 AM 4/30/2025 make Tag cleanup conditional on avail of the target vtxt\funcs
               #>
                [CmdletBinding()]
                PARAM(
                    [Parameter(Position=0,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Path to target script (defaults to `$PSCommandPath) [-Path .\path-to\script.ps1]")]
                    # rem out validation, for module installed in AllUsers etc, we don't want to have to spec a real existing file. No bene to testing
                    #[ValidateScript({Test-Path (split-path $_)})] 
                    $Path,
                    [Parameter(HelpMessage="Tag string to be used with -Path filename spec, to construct log file name [-tag 'ticket-123456]")]
                    [string]$Tag,
                    [Parameter(HelpMessage="Flag that suppresses the trailing timestamp value from the generated filenames[-NoTimestamp]")]
                    [switch] $NoTimeStamp,
                    [Parameter(HelpMessage="Flag that leads the returned filename with the Tag parameter value[-TagFirst]")]
                    [switch] $TagFirst,
                    [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
                    [switch] $showDebug,
                    [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
                    [switch] $whatIf=$true
                ) ;
                #${CmdletName} = $rPSCmdlet.MyInvocation.MyCommand.Name ;
                #$PSParameters = New-Object -TypeName PSObject -Property $rPSBoundParameters ;
                $Verbose = ($VerbosePreference -eq 'Continue') ; 
                $transcript = join-path -path (Split-Path -parent $Path) -ChildPath "logs" ;
                if (-not (test-path -path $transcript)) { write-host "Creating missing log dir $($transcript)..." ; mkdir $transcript  ; } ;
                #$transcript = join-path -path $transcript -childpath "$([system.io.path]::GetFilenameWithoutExtension($Path))" ; 
                if($Tag){
                    # clean for fso use, if funcs avail
                    if((gci function:Remove-StringDiacritic -ea 0)){$Tag = Remove-StringDiacritic -String $Tag } else {write-host "(missing:verb-text\Remove-StringDiacritic, skipping)";}  # verb-text ; 
                    if((gci function:Remove-StringLatinCharacters -ea 0)){$Tag = Remove-StringLatinCharacters -String $Tag } else {write-host "(missing:verb-textRemove-StringLatinCharacters, skipping)";} # verb-text
                    if((gci function:Remove-InvalidFileNameChars -ea 0)){$Tag = Remove-InvalidFileNameChars -Name $Tag } else {write-host "(missing:verb-textRemove-InvalidFileNameChars, skipping)";}; # verb-io, (inbound Path is assumed to be filesystem safe)
                    if($TagFirst){
                        $smsg = "(-TagFirst:Building filenames with leading -Tag value)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        $transcript = join-path -path $transcript -childpath "$($Tag)-$([system.io.path]::GetFilenameWithoutExtension($Path))" ; 
                        #$transcript = "$($Tag)-$($transcript)" ; 
                    } else { 
                        $transcript = join-path -path $transcript -childpath "$([system.io.path]::GetFilenameWithoutExtension($Path))" ; 
                        $transcript += "-$($Tag)" ; 
                    } ;
                } else {
                    $transcript = join-path -path $transcript -childpath "$([system.io.path]::GetFilenameWithoutExtension($Path))" ; 
                }; 
                $transcript += "-Transcript-BATCH"
                if(-not $NoTimeStamp){ $transcript += "-$(get-date -format 'yyyyMMdd-HHmmtt')" } ; 
                $transcript += "-trans-log.txt"  ;
                # add log file variant as target of Write-Log:
                $logfile = $transcript.replace("-Transcript", "-LOG").replace("-trans-log", "-log") ;
                if(get-variable whatif -ea 0){
                    if ($whatif) {
                        $logfile = $logfile.replace("-BATCH", "-BATCH-WHATIF") ;
                        $transcript = $transcript.replace("-BATCH", "-BATCH-WHATIF") ;
                    } else {
                        $logfile = $logfile.replace("-BATCH", "-BATCH-EXEC") ;
                        $transcript = $transcript.replace("-BATCH", "-BATCH-EXEC") ;
                    } ;
                } ; 
                $logging = $True ;

                $hshRet= [ordered]@{
                    logging=$logging ;
                    logfile=$logfile ;
                    transcript=$transcript ;
                } ;
                if($showdebug -OR $verbose){
                    write-verbose -verbose:$true "$(($hshRet|out-string).trim())" ;  ;
                } ;
                Write-Output $hshRet ;
            }
        } ; 
        #endregion START_LOG ;  ; #*------^ END start-log ^------

        #region CONNECT_EXCHANGESERVERTDO ; #*------v Connect-ExchangeServerTDO v------
        if(-not(gci function:Connect-ExchangeServerTDO -ea 0)){
            Function Connect-ExchangeServerTDO {
                <#
                .SYNOPSIS
                Connect-ExchangeServerTDO.ps1 - Dependancy-less Function that, fed an Exchange server name, or AD SiteName, and optional RoleNames array, 
                will obtain a list of Exchange servers from AD (in the specified scope), and then run the list attempting to PowershellREmote (REMS) connect to each server, 
                stopping at the first successful connection.
                .NOTES
                REVISIONS
                * 10;07 am 4/30/2025 fixed borked edge conn, typo, and rev logic for Ex & role detection in raw PS - lacks evaris for exchange (EMS/REMS only), so leverage reg & stock install loc hunting to discover setup.exe for vers & role confirm).
                * 2:46 PM 4/22/2025 add: -Version (default to Ex2010), and postfiltered returned ExchangeServers on version. If no -Version, sort on newest Version, then name, -descending.
                .PARAMETER name
                FQDN of a specific Exchange server[-Name EXSERVER.DOMAIN.COM]
                .PARAMETER discover
                Boolean paraameter that drives auto-discovery of target Exchange servers for connection (defaults `$true)[-discover:`$false]
                .PARAMETER credential
                Use specific Credentials[-Credentials [credential object]
                    .PARAMETER Site
                Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-Site 'SITENAME']
                .PARAMETER RoleNames
                Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']
                .PARAMETER Version
                Specific Exchange Server Version to connect to('Ex2019|Ex2016|Ex2013|Ex2010|Ex2007|Ex2003|Ex2000')[-Version 'Ex2016']
                .PARAMETER TenOrg
                Tenant Tag (3-letter abbrebiation - defaults to variable `$global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']
                .INPUTS
                None. Does not accepted piped input.(.NET types, can add description)
                .OUTPUTS
                [system.object] Returns a system object containing a successful PSSession
                System.Boolean
                .EXAMPLE
                PS> $PSSession = Connect-ExchangeServerTDO -siteName SITENAME -RoleNames @('HUB','CAS') -verbose 
                Demo's connecting to a functional Hub or CAS server in the SITENAME site with verbose outputs, the `PSSession variable will contain information about the successful connection. Makes automatic Exchangeserver discovery calls into AD (using ADSI) leveraging the separate get-ADExchangeServerTDO()
                .EXAMPLE
                PS> TRY{$Site=[System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name}CATCH{$Site=$env:COMPUTERNAME} ;
                PS> $PSSession = Connect-ExchangeServerTDO -siteName $Site -RoleNames @('HUB','CAS') -verbose ; 
                Demo including support for EdgeRole, which is detected on it's lack of AD Site specification (which gets fed through to call, by setting the Site to the machine itself).
                .EXAMPLE
                PS> $PSSession = Connect-ExchangeServerTDO -siteName SITENAME -RoleNames @('HUB','CAS') -Version Ex2016 -verbose 
                Demo's connecting to a functional Hub or CAS server Version Ex2016 in the SITENAME site with verbose outputs, the `PSSession variable will contain information about the successful connection. Makes automatic Exchangeserver discovery calls into AD (using ADSI) leveraging the separate get-ADExchangeServerTDO()
                #>        
                [CmdletBinding(DefaultParameterSetName='discover')]
                PARAM(
                    [Parameter(Position=0,Mandatory=$true,ParameterSetName='name',HelpMessage="FQDN of a specific Exchange server[-Name EXSERVER.DOMAIN.COM]")]
                        [String]$name,
                    [Parameter(Position=0,ParameterSetName='discover',HelpMessage="Boolean paraameter that drives auto-discovery of target Exchange servers for connection (defaults `$true)[-discover:`$false]")]
                        [bool]$discover=$true,
                    [Parameter(Position=1,HelpMessage = "Use specific Credentials[-Credentials [credential object]")]
                        [Management.Automation.PSCredential]$credential,
                    [Parameter(Position=1,HelpMessage="Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-Site 'SITENAME']")]
                        [Alias('Site')]
                        [string]$SiteName = (gv -name "$($TenOrg)_ADSiteDefaultName" -ea 0).Value,
                    [Parameter(Position=2,HelpMessage="Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']")]
                        [ValidateSet('MBX','CAS','HUB','UM','MBX','EDGE')]
                        [string[]]$RoleNames = @('HUB','CAS'),
                    [Parameter(Position=2,HelpMessage="Specific Exchange Server Version to connect to('Ex2019|Ex2016|Ex2013|Ex2010|Ex2007|Ex2003|Ex2000')[-Version 'Ex2016']")]
                        [ValidateSet('Ex2019','Ex2016','Ex2013','Ex2010','Ex2007','Ex2003','Ex2000')]
                        [string[]]$Version = 'Ex2010',
                    [Parameter(Mandatory=$FALSE,HelpMessage="Tenant Tag (3-letter abbrebiation - defaults to global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']")]
                        [ValidateNotNullOrEmpty()]
                        [string]$TenOrg = $global:o365_TenOrgDefault
                ) ;
                BEGIN{
                    $Verbose = ($VerbosePreference -eq 'Continue') ;
                    $CurrentVersionTlsLabel = [Net.ServicePointManager]::SecurityProtocol ; # Tls, Tls11, Tls12 ('Tls' == TLS1.0)  ;
			        write-verbose "PRE: `$CurrentVersionTlsLabel : $($CurrentVersionTlsLabel )" ;
			        # psv6+ already covers, test via the SslProtocol parameter presense
			        if ('SslProtocol' -notin (Get-Command Invoke-RestMethod).Parameters.Keys) {
				        $currentMaxTlsValue = [Math]::Max([Net.ServicePointManager]::SecurityProtocol.value__,[Net.SecurityProtocolType]::Tls.value__) ;
				        write-verbose "`$currentMaxTlsValue : $($currentMaxTlsValue )" ;
				        $newerTlsTypeEnums = [enum]::GetValues('Net.SecurityProtocolType') | Where-Object { $_ -gt $currentMaxTlsValue }
				        if($newerTlsTypeEnums){
					        write-verbose "Appending upgraded/missing TLS `$enums:`n$(($newerTlsTypeEnums -join ','|out-string).trim())" ;
				        } else {
					        write-verbose "Current TLS `$enums are up to date with max rev available on this machine" ;
				        };
				        $newerTlsTypeEnums | ForEach-Object {
					        [Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor $_
				        } ;
			        } ;
                    
                    # 5:15 PM 4/22/2025 on CMW, have to patch version to Ex2016

                    #*------v Function _connect-ExOP v------
                    function _connect-ExOP{
                            [CmdletBinding()]
                            PARAM(
                                [Parameter(Position=0,Mandatory=$true,HelpMessage="Exchange server AD Summary system object[-Server EXSERVER.DOMAIN.COM]")]
                                    [system.object]$Server,
                                [Parameter(Position=1,HelpMessage = "Use specific Credentials[-Credentials [credential object]")]
                                    [Management.Automation.PSCredential]$credential
                            );
                            $verbose = $($VerbosePreference -eq "Continue") ;
                            if([double]$ExVersNum = [regex]::match($Server.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value){
                                switch -regex ([string]$ExVersNum) {
                                    '15.2' { $isEx2019 = $true ; $ExVers = 'Ex2019' }
                                    '15.1' { $isEx2016 = $true ; $ExVers = 'Ex2016'}
                                    '15.0' { $isEx2013 = $true ; $ExVers = 'Ex2013'}
                                    '14.*' { $isEx2010 = $true ; $ExVers = 'Ex2010'}
                                    '8.*' { $isEx2007 = $true ; $ExVers = 'Ex2007'}
                                    '6.5' { $isEx2003 = $true ; $ExVers = 'Ex2003'}
                                    '6' {$isEx2000 = $true ; $ExVers = 'Ex2000'} ;
                                    default {
                                        $smsg = "UNRECOGNIZED ExVersNum.Major.Minor string:$($ExVersNum)! ABORTING!" ;
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        THROW $SMSG ;
                                        BREAK ;
                                    }
                                } ;
                            }else {
                                $smsg = "UNABLE TO RESOLVE `$ExVersNum from `$Server.version:$($Server.version)!" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                throw $smsg ;
                                break ;
                            } ;
                            if($Server.RoleNames -eq 'EDGE'){
                                if(($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup')) -or
                                    ($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup')) -or
                                    $ByPassLocalExchangeServerTest)
                                {
                                    if((Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\EdgeTransportRole') -or
                                            (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\EdgeTransportRole'))
                                    {
                                        $smsg = "We are on Exchange Edge Transport Server"
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                        $IsEdgeTransport = $true
                                    }
                                    TRY {
                                        Get-ExchangeServer -ErrorAction Stop | Out-Null
                                        $smsg = "Exchange PowerShell Module already loaded."
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                        $passed = $true 
                                    }CATCH {
                                        $smsg = "Failed to run Get-ExchangeServer"
                                        if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                        if($isLocalExchangeServer){
                                            write-host  "Loading Exchange PowerShell Module..."
                                            TRY{
                                                if($IsEdgeTransport){
                                                    # implement local snapins access on edge role: Only way to get access to EMS commands.
                                                    [xml]$PSSnapIns = Get-Content -Path "$env:ExchangeInstallPath\Bin\exshell.psc1" -ErrorAction Stop
                                                    ForEach($PSSnapIn in $PSSnapIns.PSConsoleFile.PSSnapIns.PSSnapIn){
                                                        write-verbose ("Trying to add PSSnapIn: {0}" -f $PSSnapIn.Name)
                                                        Add-PSSnapin -Name $PSSnapIn.Name -ErrorAction Stop
                                                    } ; 
                                                    Import-Module $env:ExchangeInstallPath\bin\Exchange.ps1 -ErrorAction Stop ; 
                                                    $passed = $true #We are just going to assume this passed.
                                                }else{
                                                    Import-Module $env:ExchangeInstallPath\bin\RemoteExchange.ps1 -ErrorAction Stop
                                                    Connect-ExchangeServer -Auto -ClientApplication:ManagementShell
                                                    $passed = $true #We are just going to assume this passed.
                                                } 
                                            }CATCH {
                                                $smsg = "Failed to Load Exchange PowerShell Module..." ; 
                                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                                            }                               
                                        } ;
                                    } FINALLY {
                                        if($LoadExchangeVariables -and $passed -and $isLocalExchangeServer){
                                            if($ExInstall -eq $null -or $ExBin -eq $null){
                                                if(Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup'){
                                                    $Global:ExInstall = (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup).MsiInstallPath
                                                }else{
                                                    $Global:ExInstall = (Get-ItemProperty HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup).MsiInstallPath
                                                }
        
                                                $Global:ExBin = $Global:ExInstall + "\Bin"
        
                                                $smsg = ("Set ExInstall: {0}" -f $Global:ExInstall)
                                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                                $smsg = ("Set ExBin: {0}" -f $Global:ExBin)
                                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                            } ; 
                                        } ; 
                                    } ; 
                                } else  {
                                    $smsg = "Does not appear to be an Exchange 2010 or newer server." ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                                }
                                if(get-command -Name Get-OrganizationConfig -ea 0){
                                    $smsg = "Running in connected/Native EMS" ; 
                                    if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                    Return $true ; 
                                } else { 
                                    TRY{
                                        $smsg = "Initiating Edge EMS local session (exshell.psc1 & exchange.ps1)" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                        # 5;36 PM 5/30/2024 didn't work, went off to nowhere for a long time, and exited the script
                                        #& (gcm powershell.exe).path -PSConsoleFile "$($env:ExchangeInstallPath)bin\exshell.psc1" -noexit -command ". '$($env:ExchangeInstallPath)bin\Exchange.ps1'"
                                        <# [Adding the Transport Server to Exchange - Mark Lewis Blog](https://marklewis.blog/2020/11/19/adding-the-transport-server-to-exchange/)
                                        To access the management console on the transport server, I opened PowerShell then ran
                                        exshell.psc1
                                        Followed by
                                        exchange.ps1
                                        At this point, I was able to create a new subscription using he following PowerShel
                                        #>
                                        invoke-command exshell.psc1 ; 
                                        invoke-command exchange.ps1
                                        if(get-command -Name Get-OrganizationConfig -ea 0){
                                            $smsg = "Running in connected/Native EMS" ; 
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                                            Return $true ;
                                        } else { return $false };  
                                    }CATCH{
                                        Write-Error $_ ;
                                    } ;
                                } ; 
                            } else {
                                $pltNPSS=@{ConnectionURI="http://$($Server.FQDN)/powershell"; ConfigurationName='Microsoft.Exchange' ; name="Exchange$($ExVersNum.tostring())"} ;
                                $pltIMod=@{Global=$true;PassThru=$true;DisableNameChecking=$true ;} ;
                                # use ExVersUnm dd instead of hardcoded (Exchange2010)
                                if($ExVersNum -ge 15){
                                    $smsg = "EXOP.15+:Adding -Authentication Kerberos" ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                    $pltNPSS.add('Authentication',"Kerberos") ;
                                    $pltNPSS.name = $ExVers ;
                                } ;
                                $smsg = "Adding EMS (connecting to $($Server.FQDN))..." ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                $smsg = "New-PSSession w`n$(($pltNPSS|out-string).trim())" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                $ExPSS = New-PSSession @pltNPSS  ;
                                $ExIPSS = Import-PSSession $ExPSS -allowclobber ;
                                # 3:59 PM 1/9/2025 appears credprompting is due to it's missing the import-module $ExIPSS ! 
                                $smsg = "Import-Module w`n$(($pltIMod|out-string).trim())" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                $Global:E10Mod = Import-Module $ExIPSS @pltIMod ;
                                $ExPSS | write-output ;
                                $ExPSS= $ExIPSS = $null ;
                            } ; 
                        } ;
                    #*------^ END Function _connect-ExOP ^------
                    $pltGADX=@{
                        ErrorAction='Stop';
                    } ;
                } ;
                PROCESS{
                    if($PSBoundParameters.ContainsKey('credential')){
                        $pltGADX.Add('credential',$credential) ;
                    }
                    if($SiteName){
                        $pltGADX.Add('siteName',$siteName) ;
                    } ;
                    if($RoleNames){
                        $pltGADX.Add('RoleNames',$RoleNames) ;
                    } ;
                    TRY{
                        if($discover){
                            $smsg = "Getting list of Exchange Servers" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            $exchServers=get-ADExchangeServerTDO @pltGADX | sort responsetime ;
                        }else{
                            $exchServers=get-ADExchangeServerTDO @pltGADX | sort responsetime ;
                        } ;
                        $pltTW=@{
                            'ErrorAction'='Stop';
                        } ;
                        $pltCXOP = @{
                            verbose = $($VerbosePreference -eq "Continue") ;
                        } ;
                        if($pltGADX.credential){
                            $pltCXOP.Add('Credential',$pltGADX.credential) ;
                        } ;
                        if($Version){
                            switch ($Version){
                              'Ex2000'{$rgxExVersNum = '6' } 
                              'Ex2003'{$rgxExVersNum = '6.5' } 
                              'Ex2007'{$rgxExVersNum = '8.*' } 
                              'Ex2010'{$rgxExVersNum = '14.*'} 
                              'Ex2013'{$rgxExVersNum = '15.0' } 
                              'Ex2016'{$rgxExVersNum = '15.1'} 
                              'Ex2019'{$rgxExVersNum = '15.2' } 
                            } ; 
                            $exchServers  = $exchServers | ?{ [double]([regex]::match( $_.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value) -match $rgxExVersNum } ; 

                        } else {
                            write-verbose "no -Version: Sorting Newest first, then names, descending" ; 
                            $exchServers  = $exchServers | sort version,name -desc
                        } ; 
                        $prpPSS = 'Id','Name','ComputerName','ComputerType','State','ConfigurationName','Availability' ; 
                        foreach($exServer in $exchServers){
                            $smsg = "testing conn to:$($exServer.name.tostring())..." ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            if(get-command -module (get-module |?{$_.name -like 'tmp_*'}).name -name 'get-OrganizationConfig' -ea SilentlyContinue){
                                if($pssEXOP = Get-PSSession |  where-object { ($_.ConfigurationName -eq 'Microsoft.Exchange') -AND ( $_.runspace.ConnectionInfo.AppName -match '^/(exadmin|powershell)$') -AND ( $_.runspace.ConnectionInfo.Port -eq '80') }){
                                    if($pssEXOP.State -ne "Opened" -OR $pssEXOP.Availability -ne "Available"){
                                        $pssEXOP | remove-pssession ; $pssEXOP = $null ;
                                    } ;
                                } ; 
                            } else {
                                $smsg = "(mangled ExOP conn: disconnect/reconnect...)" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                if($pssEXOP = Get-PSSession |  where-object { ($_.ConfigurationName -eq 'Microsoft.Exchange') -AND ( $_.runspace.ConnectionInfo.AppName -match '^/(exadmin|powershell)$') -AND ( $_.runspace.ConnectionInfo.Port -eq '80') }){
                                    if($pssEXOP.State -ne "Opened" -OR $pssEXOP.Availability -ne "Available"){
                                        $pssEXOP | remove-pssession ; $pssEXOP = $null ;
                                    } ;
                                } ; 
                            } ;
                            if(-not $pssEXOP){
                                $smsg = "Connecting to: $($exServer.FQDN)" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                $smsg = "_connect-ExOP w`n$(($pltCXOP|out-string).trim())" ;
                                $smsg += "`nServer $($exServer.FQDN)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                if($NoTest){
                                    $ExPSS =$ExPSS = _connect-ExOP @pltCXOP -Server $exServer
                                } else {
                                    TRY{
                                        $smsg = "Testing Connection: $($exServer.FQDN)" ;
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                        If(test-connection $exServer.FQDN -count 1 -ea 0) {
                                            $smsg = "confirmed pingable..." ;
                                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                        } else {
                                            $smsg = "Unable to Ping $($exServer.FQDN)" ; ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        } ;
                                        $smsg = "Testing WinRm: $($exServer.FQDN)" ;
                                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                        $winrm=Test-WSMan @pltTW -ComputerName $exServer.FQDN ;
                                        if($winrm){
                                            $ExPSS = _connect-ExOP @pltCXOP -Server $exServer;
                                        } else {
                                            $smsg = "Unable to Test-WSMan $($exServer.FQDN) (skipping)" ; ;
                                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        } ;
                                    }CATCH{
                                        $errMsg="Server: $($exServer.FQDN)] $($_.Exception.Message)" ;
                                        Write-Error -Message $errMsg ;
                                        continue ;
                                    } ;
                                };
                            } else {
                                $smsg = "$((get-date).ToString('HH:mm:ss')):Accepting first valid connection w`n$(($pssEXOP | ft -a $prpPSS|out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success }
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                $ExPSS = $pssEXOP ; 
                                break ; 
                            }  ;
                        } ;
                    }CATCH{
                        Write-Error $_ ;
                    } ;
                } ;
                END{
                    if(-not $ExPSS){
                        $smsg = "NO SUCCESSFUL CONNECTION WAS MADE, WITH THE SPECIFIED INPUTS!" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $smsg = "(returning `$false to the pipeline...)" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        return $false
                    } else{
                        if($ExPSS.State -eq "Opened" -AND $ExPSS.Availability -eq "Available"){
                            if(-not ($OrgName = ((get-OrganizationConfig).DistinguishedName.split(',') |?{$_ -like 'DC=*'}) -join '.' -replace 'DC=','')){
                                $smsg = "Missing Exchange Connection! (no (Get-OrganizationConfig).name returned)" ;
                                throw $smsg ;
                                $smsg | write-warning  ;
                            } else {
                                $smsg = "(connected to EXOP.Org:$($orgName))" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Success }
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                            return $ExPSS
                        } ;
                    } ; 
                } ;
            } ;
        } ; 
        #endregion CONNECT_EXCHANGESERVERTDO ; #*------^ END Connect-ExchangeServerTDO ^------

        #region GET_ADEXCHANGESERVERTDO ; #*------v get-ADExchangeServerTDO v------
        if(-not(gci function:get-ADExchangeServerTDO -ea 0)){
            Function get-ADExchangeServerTDO {
                <#
                .SYNOPSIS
                get-ADExchangeServerTDO.ps1 - Returns Exchangeserver summary(s) from AD records
                .NOTES
                Version     : 3.0.1
                Author      : Todd Kadrie
                Website     : http://www.toddomation.com
                Twitter     : @tostka / http://twitter.com/tostka
                CreatedDate : 2015-09-03
                FileName    : get-ADExchangeServerTDO.ps1
                License     : (none-asserted)
                Copyright   : (none-asserted)
                Github      : https://github.com/tostka/verb-Ex2010
                Tags        : Powershell, ActiveDirectory, Exchange, Discovery
                AddedCredit : Mike Pfeiffer
                AddedWebsite: mikepfeiffer.net
                AddedTwitter: URL
                AddedCredit : Sammy Krosoft 
                AddedWebsite: http://aka.ms/sammy
                AddedTwitter: URL
                AddedCredit : Brian Farnsworth
                AddedWebsite: https://codeandkeep.com/
                AddedTwitter: URL
                REVISIONS
                * 10;05 am 4/30/2025 fixed code for Edge role in raw PS, missing evaris for Ex: added discovery from reg & stock file system dirs for version etc.
                * 3:57 PM 11/26/2024 updated simple write-host,write-verbose with full pswlt support;  syncd dbg & vx10 copies.
                * 12:57 PM 6/11/2024 Validated, Ex2010 & Ex2019, hub, mail & edge roles: tested ☑️ on CMW mail role (Curly); and Jumpbox; copied in CBH from repo copy, which has been updated/debugged compat on CMW Edge 
                * 2:05 PM 8/28/2023 REN -> Get-ExchangeServerInSite -> get-ADExchangeServerTDO (aliased orig); to better steer profile-level options - including in cmw org, added -TenOrg, and default Site to constructed vari, targeting new profile $XXX_ADSiteDefault vari; Defaulted -Roles to HUB,CAS as well.
                * 3:42 PM 8/24/2023 spliced together combo of my long-standing, and some of the interesting ideas BF's version had. Functional prod:
                    - completely removed ActiveDirectory module dependancies from BF's code, and reimplemented in raw ADSI calls. Makes it fully portable, even into areas like Edge DMZ roles, where ADMS would never be installed.

                * 3:17 PM 8/23/2023 post Edge testing: some logic fixes; add: -Names param to filter on server names; -Site & supporting code, to permit lookup against sites *not* local to the local machine (and bypass lookup on the local machine) ; 
                    ren $Ex10siteDN -> $ExOPsiteDN; ren $Ex10configNC -> $ExopconfigNC
                * 1:03 PM 8/22/2023 minor cleanup
                * 10:31 AM 4/7/2023 added CBH expl of postfilter/sorting to draw predictable pattern 
                * 4:36 PM 4/6/2023 validated Psv51 & Psv20 and Ex10 & 16; added -Roles & -RoleNames params, to perform role filtering within the function (rather than as an external post-filter step). 
                For backward-compat retain historical output field 'Roles' as the msexchcurrentserverroles summary integer; 
                use RoleNames as the text role array; 
                    updated for psv2 compat: flipped hash key lookups into properties, found capizliation differences, (psv2 2was all lower case, wouldn't match); 
                flipped the [pscustomobject] with new... psobj, still psv2 doesn't index the hash keys ; updated for Ex13+: Added  16  "UM"; 20  "CAS, UM"; 54  "MBX" Ex13+ ; 16385 "CAS" Ex13+ ; 16439 "CAS, HUB, MBX" Ex13+
                Also hybrided in some good ideas from SammyKrosoft's Get-SKExchangeServers.psm1 
                (emits Version, Site, low lvl Roles # array, and an array of Roles, for post-filtering); 
                # 11:20 AM 4/21/2021 fixed/suppressed noisy verbose calls
                * 12:08 PM 5/15/2020 fixed vpn issue: Try/Catch'd around recently failing $ADSite::GetComputerSite().GetDirectoryEntry().distinguishedName qry
                * 11:22 AM 3/13/2020 Get-ExchangeServerInSite added a ping-test, to only return matches that are pingable, added -NoPing param, to permit (faster) untested bypass
                * 6:59 PM 1/15/2020 cleanup
                # 10:03 AM 11/16/2018 Get-ExchangeServerInSite:can't do AD-related functions when not AD authentictaed (home, pre-vpn connect). Added if/then test on status and abort balance when false.
                * 11/18/18 BF's posted rev
                # 12:10 PM 8/1/2017 updated example code at bottom, to accommodate variant sites
                # 11:28 AM 3/31/2016 validated that latest round of updates are still functional
                #1:58 PM 9/3/2015 - added pshelp and some docs
                #April 12, 2010 - web version
                .DESCRIPTION
                get-ADExchangeServerTDO.ps1 - Returns Exchangeserver summary(s) from AD records

                Hybrided together ideas from Brian Farnsworth's blog post
                [PowerShell - ActiveDirectory and Exchange Servers – CodeAndKeep.Com – Code and keep calm...](https://codeandkeep.com/PowerShell-ActiveDirectory-Exchange-Part1/)
                ... with much older concepts from  Sammy Krosoft, and much earlier Mike Pfeiffer. 

                - Subbed in MP's use of ADSI for ActiveDirectory Ps mod cmds - it's much more dependancy-free; doesn't require explicit install of the AD ps module
                ADSI support is built into windows.
                - spliced over my addition of Roles, RoleNames, Name & NoTest params, for prefiltering and suppressing testing.


                [briansworth · GitHub](https://github.com/briansworth)

                Uses an ADSI DirectorySearcher to search the current Active Directory site for Exchange on-prem servers.
                        Intent is to discover connection points for Powershell, wo the need to preload/pre-connect to Exchange.

                        But, as a non-Exchange-Management-Shell-dependant info source on Exchange Server configs, it can be used before connection, with solely AD-available data, to check configuration spes on the subject server(s). 

                        For example, this query will return sufficient data under Version to indicate which revision of Exchange is in use:


                        Returned object (in array):
                        Site      : {ADSITENAME}
                        Roles     : {64}
                        Version   : {Version 15.1 (Build 32375.7)}
                        Name      : SERVERNAME
                        RoleNames : EDGE
                        FQDN      : SERVERNAME.DOMAIN.TLD

                        ... includes the post-filterable Role property ($_.Role -contains 'CAS') which reflects the following
                        installed-roles ('msExchCurrentServerRoles') on the discovered servers
                            2   {"MBX"} # Ex10
                            4   {"CAS"}
                            16  {"UM"}
                            20  {"CAS, UM" -split ","} # 
                            32  {"HUB"}
                            36  {"CAS, HUB" -split ","}
                            38  {"CAS, HUB, MBX" -split ","}
                            54  {"MBX"} # Ex13+
                            64  {"EDGE"}
                            16385   {"CAS"} # Ex13+
                            16439   {"CAS, HUB, MBX"  -split ","} # Ex13+
                .PARAMETER Roles
                Array of msExchCurrentServerRoles 'role' integers to be filtered against (2|4|16|20|32|36|38|54|64|16385|16439)[-Roles @(38,16385)]
                .PARAMETER RoleNames
                Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']
                .PARAMETER Server
                Array of Server name strings to be filtered against[-Server 'SERVER1','SERVER2']
                .PARAMETER SiteName
                Name of specific AD SiteName to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-SiteName 'SITENAME']
                .PARAMETER TenOrg
                Tenant Tag (3-letter abbrebiation - defaults to variable `$global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']
                .PARAMETER NoPing
                Switch to suppress default 'pingable' test (e.g. returns all matches, no testing)[-NoPing]
                .INPUTS
                None. Does not accepted piped input.(.NET types, can add description)
                .OUTPUTS
                None. Returns no objects or output (.NET types)
                System.Boolean
                [| get-member the output to see what .NET obj TypeName is returned, to use here]
                System.Array of System.Object's
                .EXAMPLE
                PS> If(!($ExchangeServer)){$ExchangeServer = (get-ADExchangeServerTDO| ?{$_.RoleNames -contains 'CAS' -OR $_.RoleNames -contains 'HUB' -AND ($_.FQDN -match "^SITECODE") } | Get-Random ).FQDN
                Return a random Hub Cas Role server in the local Site with a fqdn beginning SITECODE
                .EXAMPLE
                PS> $localADExchserver = get-ADExchangeServerTDO -Names $env:computername -SiteName ([System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().name)
                Demo, if run from an Exchange server, return summary details about the local server (-SiteName isn't required, is default imputed from local server's Site, but demos explicit spec for remote sites)
                .EXAMPLE
                PS> $regex = '(' + [regex]($ADSiteCodeUK,$ADSiteCodeAU -join "|") + ')'
                PS> switch -regex ($($env:computername).substring(0,3)){
                PS>    "$($ADSiteCodeUS)" {$tExRole=36 } ;
                PS>    "$($regex)" {$tExRole= 38 }  default { write-error "$((get-date).ToString('HH:mm:ss')):UNRECOGNIZED SERVER PREFIX!."; } ;
                PS> } ;
                PS> $exhubcas = (get-ADExchangeServerTDO |?{($_.roles -eq $tExRole) -AND ($_.FQDN -match "$($env:computername.substring(0,3)).*")} | Get-Random ).FQDN ;
                Use a switch block to select different role combo targets for a given server fqdn prefix string.
                .EXAMPLE
                PS> $ExchangeServer = get-ADExchangeServerTDO | ?{$_.Roles -match '(4|20|32|36|38|16385|16439)'} | select -expand fqdn | get-random ; 
                Another/Older approach filtering on the Roles integer (targeting combos with Hub or CAS in the mix)
                .EXAMPLE
                PS> $ret = get-ADExchangeServerTDO -Roles @(4,20,32,36,38,16385,16439) -verbose 
                Demo use of the -Roles param, feeding it an array of Role integer values to be filtered against. In this case, the Role integers that include a CAS or HUB role.
                .EXAMPLE
                PS> $ret = get-ADExchangeServerTDO -RoleNames 'HUB','CAS' -verbose ;
                Demo use of the -RoleNames param, feeding it the array 'HUB','CAS' Role name strings to be filtered against
                PS> $ret = get-ADExchangeServerTDO -Names 'SERVERName' -verbose ;
                Demo use of the -RoleNames param, feeding it the array 'HUB','CAS' Role name strings to be filtered against
                .EXAMPLE
                PS> $ExchangeServer = get-ADExchangeServerTDO | sort version,roles,name | ?{$_.rolenames -contains 'CAS'}  | select -last 1 | select -expand fqdn ;
                Demo post sorting & filtering, to deliver a rule-based predictable pattern for server selection: 
                Above will always pick the highest Version, 'CAS' RoleName containing, alphabetically last server name (that is pingable). 
                And should stick to that pattern, until the servers installed change, when it will shift to the next predictable box.
                .EXAMPLE
                PS> $ExOPServer = get-ADExchangeServerTDO -Name LYNMS650 -SiteName Lyndale
                PS> if([double]$ExVersNum = [regex]::match($ExOPServer.version,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value){
                PS>     switch -regex ([string]$ExVersNum) {
                PS>         '15\.2' { $isEx2019 = $true ; $ExVers = 'Ex2019' }
                PS>         '15\.1' { $isEx2016 = $true ; $ExVers = 'Ex2016'}
                PS>         '15\.0' { $isEx2013 = $true ; $ExVers = 'Ex2013'}
                PS>         '14\..*' { $isEx2010 = $true ; $ExVers = 'Ex2010'}
                PS>         '8\..*' { $isEx2007 = $true ; $ExVers = 'Ex2007'}
                PS>         '6\.5' { $isEx2003 = $true ; $ExVers = 'Ex2003'}
                PS>         '6|6\.0' {$isEx2000 = $true ; $ExVers = 'Ex2000'} ;
                PS>         default {
                PS>             $smsg = "UNRECOGNIZED ExchangeServer.AdminDisplayVersion.Major.Minor string:$($ExOPServer.version)! ABORTING!" ;
                PS>             write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
                PS>         }
                PS>     } ; 
                PS> }else {
                PS>     $smsg = "UNABLE TO RESOLVE `$ExVersNum from `$ExOPServer.version:$($ExOPServer.version)!" ; 
                PS>     write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)"  ; 
                PS>     throw $smsg ; 
                PS>     break ; 
                PS> } ; 
                Demo of parsing the returned Version property, into the proper Exchange Server revision.      
                .LINK
                https://github.com/tostka/verb-XXX
                .LINK
                https://bitbucket.org/tostka/powershell/
                .LINK
                http://mikepfeiffer.net/2010/04/find-exchange-servers-in-the-local-active-directory-site-using-powershell/
                .LINK
                https://github.com/SammyKrosoft/Search-AD-Using-Plain-PowerShell/blob/master/Get-SKExchangeServers.psm1
                .LINK
                https://github.com/tostka/verb-Ex2010
                .LINK
                https://codeandkeep.com/PowerShell-ActiveDirectory-Exchange-Part1/
                #>
                [CmdletBinding()]
                [Alias('Get-ExchangeServerInSite')]
                PARAM(
                    [Parameter(Position=0,HelpMessage="Array of Server name strings to be filtered against[-Server 'SERVER1','SERVER2']")]
                        [string[]]$Server,
                    [Parameter(Position=1,HelpMessage="Name of specific AD site to be searched for ExchangeServers (defaults to global variable `$TenOrg_ADSiteDefaultName if present)[-SiteName 'SITENAME']")]
                        [Alias('Site')]
                        [string]$SiteName = (gv -name "$($TenOrg)_ADSiteDefaultName" -ea 0).Value,
                    [Parameter(Position=2,HelpMessage="Array of Server 'Role' name strings to be filtered against (MBX|CAS|HUB|UM|MBX|EDGE)[-RoleNames 'HUB','CAS']")]
                        [ValidateSet('MBX','CAS','HUB','UM','MBX','EDGE')]
                        [string[]]$RoleNames = @('HUB','CAS'),
                    [Parameter(HelpMessage="Array of msExchCurrentServerRoles 'role' integers to be filtered against (2|4|16|20|32|36|38|54|64|16385|16439)[-Roles @(38,16385)]")]
                        [ValidateSet(2,4,16,20,32,36,38,54,64,16385,16439)]
                        [int[]]$Roles,
                    [Parameter(HelpMessage="Switch to suppress default 'pingable' test (e.g. returns all matches, no testing)[-NoTest]")]
                        [Alias('NoPing')]
                        [switch]$NoTest,
                    [Parameter(HelpMessage="Milliseconds of max timeout to wait during port 80 test (defaults 100)[-SpeedThreshold 500]")]
                        [int]$SpeedThreshold=100,
                    [Parameter(Mandatory=$FALSE,HelpMessage="Tenant Tag (3-letter abbrebiation - defaults to global:o365_TenOrgDefault if present)[-TenOrg 'XYZ']")]
                        [ValidateNotNullOrEmpty()]
                        [string]$TenOrg = $global:o365_TenOrgDefault,
                    [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials[-Credentials [credential object]]")]
                        [System.Management.Automation.PSCredential]$Credential
                ) ;
                BEGIN{
                    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
                    $Verbose = ($VerbosePreference -eq 'Continue') ;
                    $_sBnr="#*======v $(${CmdletName}): v======" ;
                    $smsg = $_sBnr ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
                PROCESS{
                    TRY{
                        $configNC = ([ADSI]"LDAP://RootDse").configurationNamingContext ;
                        $search = new-object DirectoryServices.DirectorySearcher([ADSI]"LDAP://$configNC") ;
                        $bLocalEdge = $false ; 
                        if($Sitename -eq $env:COMPUTERNAME){
                            $smsg = "`$SiteName -eq `$env:COMPUTERNAME:$($SiteName):$($env:COMPUTERNAME)" ; 
                            $smsg += "`nThis computer appears to be an EdgeRole system (non-ADConnected)" ; 
                            $smsg += "`n(Blanking `$sitename and continuing discovery)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            #$bLocalEdge = $true ; 
                            $SiteName = $null ; 
                    
                        } ; 
                        If($siteName){
                            $smsg = "Getting Site: $siteName" ;
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            $objectClass = "objectClass=site" ;
                            $objectName = "name=$siteName" ;
                            $search.Filter = "(&($objectClass)($objectName))" ;
                            $site = ($search.Findall()) ;
                            $siteDN = ($site | select -expand properties).distinguishedname  ;
                        } else {
                            $smsg = "(No -Site specified, resolving site from local machine domain-connection...)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                            else{ write-host -foregroundcolor green "$($smsg)" } ;
                            TRY{$siteDN = [System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().GetDirectoryEntry().distinguishedName}
                            CATCH [System.Management.Automation.MethodInvocationException]{
                                $ErrTrapd=$Error[0] ;
                                if(($ErrTrapd.Exception -match 'The computer is not in a site.') -AND $env:ExchangeInstallPath){
                                    $smsg = "$($env:computername) is non-ADdomain-connected" ;
                                    if($env:ExchangeInstalled){
                                        $smsg += "`nand has `$env:ExchangeInstalled populated: Likely Edge Server" ;
                                        # unpop'd in native PS, only in EMS/REMS
                                    } elseif(($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup')) -or
                                        ($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup')) -or
                                        $ByPassLocalExchangeServerTest){
                                        $smsg +="`nand Reg confirms ExchangeServer\v1x\Setup (`$isLocalExchangeServer)" ; 
                                        if((Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\EdgeTransportRole') -or
                                                (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\EdgeTransportRole'))
                                        {
                                            $smsg +="`nand Reg confirms \v1x\EdgeTransportRole (`$IsEdgeTransport)" ; 
                                            $IsEdgeTransport = $true
                                        } ; 
                                    }  ; 
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                                    else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    # only exists in EMS/REMS, NOT PS raw
                                    if($vers = (get-item "$($env:ExchangeInstallPath)\Bin\Setup.exe").VersionInfo.FileVersionRaw ){
                                        <# [PS] C:\scripts>((get-item "$($env:ExchangeInstallPath)\Bin\Setup.exe").VersionInfo.FileVersionRaw )
                                        Major  Minor  Build  Revision
                                        -----  -----  -----  --------
                                        15     1      2507   39
                                        #>
                                    }else{
                                        if($binPath = (resolve-path  "$($env:ProgramFiles)\Microsoft\Exchange Server\V1*\Bin\Setup.exe" -ea 0).path){
                                            # find setup in stock path discovery (won't work if manual install non-std loc)                                            
                                        } else { 
                                            # loop the letter drives checking for progfiles copies
                                            (get-psdrive -PSProvider FileSystem |?{$_ -match '[D-Z]'}  | select -expand name)|foreach-object{
                                                $drv = $_ ; 
                                                if($binPath = (resolve-path  "$($drv)$($env:ProgramFiles.substring(1,($env:ProgramFiles.length-1)))\Microsoft\Exchange Server\V1*\Bin\Setup.exe" -ea 0).path){
                                                    break ; 
                                                } ; 
                                            };
                                            if($binPath){
                                                $vers = (get-item $binPath).VersionInfo.FileVersionRaw
                                            }else {

                                            } ;
                                        } ; 
                                    } ; 
                                    $props = @{
                                        Name=$env:computername;
                                        FQDN = ([System.Net.Dns]::gethostentry($env:computername)).hostname;
                                        Version = "Version $($vers.major).$($vers.minor) (Build $($vers.Build).$($vers.Revision))" ; 
                                        #"$($vers.major).$($vers.minor)" ; 
                                        #$exServer.serialNumber[0];
                                        Roles = [System.Object[]]64 ;
                                        RoleNames = @('EDGE');
                                        DistinguishedName =  "CN=$($env:computername),CN=Servers,CN=Exchange Administrative Group (FYDIBOHF23SPDLT),CN=Administrative Groups,CN=First Organization,CN=Microsoft Exchange,CN=Services,CN=Configuration,CN={nnnnnnnn-FAKE-GUID-nnnn-nnnnnnnnnnnn}" ;
                                        Site = [System.Object[]]'NOSITE'
                                        ResponseTime = if($rsp){$rsp.ResponseTime} else { 0} ;
                                        NOTE = "This summary object, returned for a non-AD-connected EDGE server, *approximates* what would be returned on an AD-connected server" ;
                                    } ;
                            
                                    $smsg = "(-NoTest:Defaulting Fast:`$true)" ;
                                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                    $props.add('Fast',$true) ;
                            
                                    return (New-Object -TypeName PsObject -Property $props) ;
                                }elseif(-not $env:ExchangeInstallPath){
                                    $smsg = "Non-Domain Joined machine, with NO ExchangeInstallPath e-vari: `nExchange is not installed locally: local computer resolution fails:`nPlease specify an explicit -Server, or -SiteName" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    $false | write-output ;
                                } else {
                                    $smsg = "$($env:computername) is both NON-Domain-joined -AND lacks an Exchange install (NO ExchangeInstallPath e-vari)`nPlease specify an explicit -Server, or -SiteName" ;
                                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    $false | write-output ;
                                };
                            } CATCH {
                                $siteDN =$ExOPsiteDN ;
                                write-warning "`$siteDN lookup FAILED, deferring to hardcoded `$ExOPsiteDN string in infra file!" ;
                            } ;
                        } ;
                        $smsg = "Getting Exservers in Site:$($siteDN)" ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        $search = new-object DirectoryServices.DirectorySearcher([ADSI]"LDAP://$configNC") ;
                        $objectClass = "objectClass=msExchExchangeServer" ;
                        $version = "versionNumber>=1937801568" ;
                        $site = "msExchServerSite=$siteDN" ;
                        $search.Filter = "(&($objectClass)($version)($site))" ;
                        $search.PageSize = 1000 ;
                        [void] $search.PropertiesToLoad.Add("name") ;
                        [void] $search.PropertiesToLoad.Add("msexchcurrentserverroles") ;
                        [void] $search.PropertiesToLoad.Add("networkaddress") ;
                        [void] $search.PropertiesToLoad.Add("msExchServerSite") ;
                        [void] $search.PropertiesToLoad.Add("serialNumber") ;
                        [void] $search.PropertiesToLoad.Add("DistinguishedName") ;
                        $exchServers = $search.FindAll() ;
                        $Aggr = @() ;
                        foreach($exServer in $exchServers){
                            $fqdn = ($exServer.Properties.networkaddress |
                                Where-Object{$_ -match '^ncacn_ip_tcp:'}).split(':')[1] ;
                            if($NoTest){} else {
                                $rsp = test-connection $fqdn -count 1 -ea 0 ;
                            } ;
                            $props = @{
                                Name = $exServer.Properties.name[0]
                                FQDN=$fqdn;
                                Version = $exServer.Properties.serialnumber
                                Roles = $exserver.Properties.msexchcurrentserverroles
                                RoleNames = $null ;
                                DistinguishedName = $exserver.Properties.distinguishedname;
                                Site = @("$($exserver.Properties.msexchserversite -Replace '^CN=|,.*$')") ;
                                ResponseTime = if($rsp){$rsp.ResponseTime} else { 0} ;
                            } ;
                            $props.RoleNames = switch ($exserver.Properties.msexchcurrentserverroles){
                                2       {"MBX"}
                                4       {"CAS"}
                                16      {"UM"}
                                20      {"CAS;UM".split(';')}
                                32      {"HUB"}
                                36      {"CAS;HUB".split(';')}
                                38      {"CAS;HUB;MBX".split(';')}
                                54      {"MBX"}
                                64      {"EDGE"}
                                16385   {"CAS"}
                                16439   {"CAS;HUB;MBX".split(';')}
                            }
                            if($NoTest){
                                $smsg = "(-NoTest:Defaulting Fast:`$true)" ;
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                                $props.add('Fast',$true) ;
                            }else {
                                $props.add('Fast',[boolean]($rsp.ResponseTime -le $SpeedThreshold)) ;
                            };
                            $Aggr += New-Object -TypeName PsObject -Property $props ;
                        } ;
                        $httmp = @{} ;
                        if($Roles){
                            [regex]$rgxRoles = ('(' + (($roles |%{[regex]::escape($_)}) -join '|') + ')') ;
                            $matched =  @( $aggr | ?{$_.Roles -match $rgxRoles}) ;
                            foreach($m in $matched){
                                if($httmp[$m.name]){} else {
                                    $httmp[$m.name] = $m ;
                                } ;
                            } ;
                        } ;
                        if($RoleNames){
                            foreach ($RoleName in $RoleNames){
                                $matched = @($Aggr | ?{$_.RoleNames -contains $RoleName} ) ;
                                foreach($m in $matched){
                                    if($httmp[$m.name]){} else {
                                        $httmp[$m.name] = $m ;
                                    } ;
                                } ;
                            } ;
                        } ;
                        if($Server){
                            foreach ($Name in $Server){
                                $matched = @($Aggr | ?{$_.Name -eq $Name} ) ;
                                foreach($m in $matched){
                                    if($httmp[$m.name]){} else {
                                        $httmp[$m.name] = $m ;
                                    } ;
                                } ;
                            } ;
                        } ;
                        if(($httmp.Values| measure).count -gt 0){
                            $Aggr  = $httmp.Values ;
                        } ;
                        $smsg = "Returning $((($Aggr|measure).count|out-string).trim()) match summaries to pipeline..." ;
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        $Aggr | write-output ;
                    }CATCH{
                        Write-Error $_ ;
                    } ;
                } ;
                END{
                    $smsg = "$($_sBnr.replace('=v','=^').replace('v=','^='))" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
            } ;
        }
        #endregion GET_ADEXCHANGESERVERTDO ;#*------^ END Function get-ADExchangeServerTDO ^------ ;

        #region load_ADMS  ; #*------v load-ADMS v------
        if(-not(gci function:load-ADMS -ea 0)){
            
            function load-ADMS {
                <#
                .NOTES
                REVISIONS   :
                * 12:57 PM 8/22/2023 test before calling Add-PSTitleBar (for PRY/dep-less support)
                .INPUTS
                None.
                .OUTPUTS
                Outputs $True/False load-status
                .EXAMPLE
                PS> $ADMTLoaded = load-ADMS ; Write-Debug "`$ADMTLoaded: $ADMTLoaded" ;
                .EXAMPLE
                PS> $ADMTLoaded = load-ADMS -Cmdlet get-aduser,get-adcomputer ; Write-Debug "`$ADMTLoaded: $ADMTLoaded" ;
                Load solely the specified cmdlets from ADMS
                .EXAMPLE
                # load ADMS
                PS> $reqMods+="load-ADMS".split(";") ;
                PS> if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
                PS> write-verbose -verbose:$true  "$((get-date).ToString('HH:mm:ss')):(loading ADMS...)" ;
                PS> load-ADMS | out-null ;
                #load-ADMS -cmdlet get-aduser,Set-ADUser,Get-ADGroupMember,Get-ADDomainController,Get-ADObject,get-adforest | out-null ;
                Demo a load from the verb-ADMS.ps1 module, with opt specific -Cmdlet set
                .EXAMPLE
                PS> if(connect-ad){write-host 'connected'}else {write-warning 'unable to connect'}  ;
                Variant capturing & testing returned (returns true|false), using the alias name (if don't cap|eat return, you'll get a 'True' in console
                #>
                [CmdletBinding()]
                [Alias('connect-AD')]
                PARAM(
                    [Parameter(HelpMessage="Specifies an array of cmdlets that this cmdlet imports from the module into the current session. Wildcard characters are permitted[-Cmdlet get-aduser]")]
                    [ValidateNotNullOrEmpty()]$Cmdlet
                ) ;
                $Verbose = ($VerbosePreference -eq 'Continue') ;
                # focus specific cmdlet loads to SPEED them UP!
                $tMod = "ActiveDirectory" ;
                $ModsReg=Get-Module -Name $tMod -ListAvailable ;
                $ModsLoad=Get-Module -name $tMod ;
                $pltAD=@{Name=$tMod ; ErrorAction="Stop"; Verbose = ($VerbosePreference -eq 'Continue') } ;
                if($Cmdlet){$pltAD.add('Cmdlet',$Cmdlet) } ;
                if ($ModsReg) {
                    if (!($ModsLoad)) {
                        $env:ADPS_LoadDefaultDrive = 0 ;
                        import-module @pltAD;
                        if(get-command Add-PSTitleBar -ea 0){
                            Add-PSTitleBar 'ADMS' -verbose:$($VerbosePreference -eq "Continue") ;
                        } ; 
                        return $TRUE;
                    } else {
                        return $TRUE;
                    } # if-E ;
                } else {
                    Write-Error {"$((get-date).ToString('HH:mm:ss')):($env:computername) does not have AD Mgmt Tools installed!";};
                    return $FALSE
                } # if-E ;
            } ;
                       
        } ; 
        #endregion load_ADMS ; #*----------^END Function load-ADMS ^---------- 

        #region GET_GCFAST ; #*------v get-GCFast v------
        if(-not(gci function:get-GCFast -ea 0)){
            function get-GCFast {
                <#
                .NOTES
                REVISIONS   :
                * 2:39 PM 1/23/2025 added -exclude (exclude array of dcs by name), -ServerPrefix (exclude on leading prefix of name) params, added expanded try/catch, swapped out w-h etc for wlt calls
                .PARAMETER  Domain
                Which AD Domain [Domain fqdn]
                .PARAMETER  Site
                DCs from which Site name (defaults to AD lookup against local computer's Site)
                .PARAMETER Exclude
                Array of Domain controller names in target site/domain to exclude from returns (work around temp access issues)
                .PARAMETER ServerPrefix
                Prefix string to filter for, in returns (e.g. 'ABC' would only return DCs with name starting 'ABC')
                .PARAMETER SpeedThreshold
                Threshold in ms, for AD Server response time(defaults to 100ms)
                .INPUTS
                None. Does not accepted piped input.
                .OUTPUTS
                Returns one DC object, .Name is name pointer
                .EXAMPLE
                PS> get-gcfast -domain dom.for.domain.com -site Site
                Lookup a Global domain gc, with Site specified (whether in Site or not, will return remote site dc's)
                .EXAMPLE
                PS> get-gcfast -domain dom.for.domain.com
                Lookup a Global domain gc, default to Site lookup from local server's perspective
                .EXAMPLE    
                PS> if($domaincontroller = get-gcfast -Exclude ServerBad -Verbose){
                PS>     write-warning "Changing DomainControler: Waiting 20seconds, for RelSync..." ;
                PS>     start-sleep -Seconds 20 ;
                PS> } ; 
                Demo acquireing a new DC, excluding a caught bad DC, and waiting before moving on, to permit ADRerplication from prior dc to attempt to ensure full sync of changes. 
                PS> get-gcfast -ServerPrefix ABC -verbose
                Demo use of -ServerPrefix to only return DCs with servernames that begin with the string 'ABC'
                .EXAMPLE
                PS> $adu=$null ;
                PS> $Exit = 0 ;
                PS> Do {
                PS>     TRY {
                PS>         $adu = get-aduser -id $rmbx.DistinguishedName -server $domainController -Properties $adprops -ea 0| select $adprops ;
                PS>         $Exit = $DoRetries ;
                PS>     }CATCH [System.Management.Automation.RuntimeException] {
                PS>         if ($_.Exception.Message -like "*ResourceUnavailable*") {
                PS>             $ErrorTrapped=$Error[0] ;
                PS>             $smsg = "Failed to exec cmd because: $($ErrorTrapped.Exception.Message )" ;
                PS>             if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                PS>             else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                PS>             # re-quire a new DC
                PS>             $badDC = $domaincontroller ; 
                PS>             $smsg = "PROBLEM CONTACTING $(domaincontroller)!:Resource unavailable: $($ErrorTrapped.Exception.Message)" ; 
                PS>             $smsg += "get-GCFast() an alterate DC" ; 
                PS>             if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                PS>             else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                PS>             if($domaincontroller = get-gcfast -Exclude $$badDC -Verbose){
                PS>                 write-warning "Changing DomainController:($($badDC)->$($domaincontroller)):Waiting 20seconds, for ReplSync..." ;
                PS>                 start-sleep -Seconds 20 ;
                PS>             } ;                             
                PS>         }else {
                PS>             throw $Error[0] ;
                PS>         } ; 
                PS>     } CATCH {
                PS>         $ErrorTrapped=$Error[0] ;
                PS>         Start-Sleep -Seconds $RetrySleep ;
                PS>         $Exit ++ ;
                PS>         $smsg = "Failed to exec cmd because: $($ErrorTrapped)" ;
                PS>         $smsg += "`nTry #: $Exit" ;
                PS>         if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                PS>         else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                PS>         If ($Exit -eq $DoRetries) {
                PS>             $smsg =  "Unable to exec cmd!" ;
                PS>             if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                PS>             else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                PS>         } ;
                PS>         Continue ;
                PS>     }  ;
                PS> } Until ($Exit -eq $DoRetries) ;
                Retry demo that includes aquisition of a new DC, excluding a caught bad DC, and waiting before moving on, to permit ADRerplication from prior dc to attempt to ensure full sync of changes. 
                #>
                [CmdletBinding()]
                PARAM(
                    [Parameter(Position = 0, Mandatory = $False, HelpMessage = "Optional: DCs from what Site name? (default=Discover)")]
                        [string]$Site,
                    [Parameter(HelpMessage = 'Target AD Domain')]
                        [string]$Domain,
                    [Parameter(HelpMessage = 'Array of Domain controller names in target site/domain to exclude from returns (work around temp access issues)')]
                        [string[]]$Exclude,
                    [Parameter(HelpMessage = "Prefix string to filter for, in returns (e.g. 'ABC' would only return DCs with name starting 'ABC')")]
                        [string]$ServerPrefix,
                    [Parameter(HelpMessage = 'Threshold in ms, for AD Server response time(defaults to 100ms)')]
                        $SpeedThreshold = 100
                ) ;
                $Verbose = $($PSBoundParameters['Verbose'] -eq $true)
                $SpeedThreshold = 100 ;
                $rgxSpbDCRgx = 'CN=EDCMS'
                $ErrorActionPreference = 'SilentlyContinue' ; # Set so we don't see errors for the connectivity test
                $env:ADPS_LoadDefaultDrive = 0 ; 
                $sName = "ActiveDirectory"; 
                TRY{
                    if ( -not(Get-Module | Where-Object { $_.Name -eq $sName }) ) {
                        $smsg = "Adding ActiveDirectory Module (`$script:ADPSS)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $script:AdPSS = Import-Module $sName -PassThru -ea Stop ;
                    } ;
                    if (-not $Domain) {
                        $Domain = (get-addomain -ea Stop).DNSRoot ; # use local domain
                        $smsg = "Defaulting domain: $Domain";
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    }
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
    
                # Get all the local domain controllers
                if ((-not $Site)) {
                    # if no site, look the computer's Site Up in AD
                    TRY{
                        $Site = [System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name ;
                        $smsg = "Using local machine Site: $($Site)";
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                } ;

                # gc filter
                #$LocalDCs = Get-ADDomainController -filter { (isglobalcatalog -eq $true) -and (Site -eq $Site) } ;
                # ISSUE: ==3:26 pm 3/7/2024: NO LOCAL SITE DC'S IN SPB
                # os: LOGONSERVER=\\EDCMS8100
                TRY{
                    $LocalDCs = Get-ADDomainController -filter { (isglobalcatalog -eq $true) -and (Site -eq $Site) -and (Domain -eq $Domain) } -ErrorAction STOP
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 
                if( $LocalDCs){
                    $smsg = "`Discovered `$LocalDCs:`n$(($LocalDCs|out-string).trim())" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                } elseif($Site -eq 'Spellbrook'){
                    $smsg = "Get-ADDomainController -filter { (isglobalcatalog -eq `$true) -and (Site -eq $($Site)) -and (Domain -eq $($Domain)}"
                    $smsg += "`nFAILED to return DCs, and `$Site -eq Spellbrook:" 
                    $smsg += "`ndiverting to $($rgxSpbDCRgx) dcs in entire Domain:" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    TRY{
                        $LocalDCs = Get-ADDomainController -filter { (isglobalcatalog -eq $true) -and (Domain -eq $Domain) } -EA STOP | 
                            ?{$_.ComputerObjectDN -match $rgxSpbDCRgx } 
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                } ; 
  
                # any dc filter
                #$LocalDCs = Get-ADDomainController -filter {(Site -eq $Site)} ;

                $PotentialDCs = @() ;
                # Check connectivity to each DC against $SpeedThreshold
                if ($LocalDCs) {
                    foreach ($LocalDC in $LocalDCs) {
                        $TCPClient = New-Object System.Net.Sockets.TCPClient ;
                        $Connect = $TCPClient.BeginConnect($LocalDC.Name, 389, $null, $null) ;
                        $Wait = $Connect.AsyncWaitHandle.WaitOne($SpeedThreshold, $False) ;
                        if ($TCPClient.Connected) {
                            $PotentialDCs += $LocalDC.Name ;
                            $Null = $TCPClient.Close() ;
                        } # if-E
                    } ;
                    if($Exclude){
                        $smsg = "-Exclude specified:`n$((($exclude -join ',')|out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        foreach($excl in $Exclude){
                            $PotentialDCs = $PotentialDCs |?{$_ -ne $excl} ; 
                        } ; 
                    } ; 
                    if($ServerPrefix){
                        $smsg = "-ServerPrefix specified: $($ServerPrefix)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        $PotentialDCs = $PotentialDCs |?{$_ -match "^$($ServerPrefix)" } ; 
            
                    }
                    write-host -foregroundcolor yellow  
                    $smsg = "`$PotentialDCs: $PotentialDCs";
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $DC = $PotentialDCs | Get-Random ;

                    $smsg = "(returning random domaincontroller from result to pipeline:$($DC)" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $DC | write-output  ;
                } else {
                    write-host -foregroundcolor yellow  "NO DCS RETURNED BY GET-GCFAST()!";
                    write-output $false ;
                } ;
            }  ; 
        } ; 
        #endregion GET_GCFAST ; #*------^ END get-GCFast ^------

        #region RESOLVE_NETWORKLOCALTDO ; #*------v resolve-NetworkLocalTDO v------
        #*------v Function resolve-NetworkLocalTDO v------
        if(-not(gci function:resolve-NetworkLocalTDO -ea 0)){
            Function resolve-NetworkLocalTDO {
                <#
                .SYNOPSIS
                resolve-NetworkLocalTDO.ps1 - Retrieve local network interface descriptors, and resolved ip address PTR -> A Record FQDN
                .NOTES
                Version     : 0.0.1
                Author      : Todd Kadrie
                Website     : http://www.toddomation.com
                Twitter     : @tostka / http://twitter.com/tostka
                CreatedDate : 2025-04-28
                FileName    : resolve-NetworkLocalTDO.ps1
                License     : MIT License
                Copyright   : (c) 2025 Todd Kadrie
                Github      : https://github.com/tostka/verb-XXX
                Tags        : Powershell
                AddedCredit : REFERENCE
                AddedWebsite: URL
                AddedTwitter: URL
                REVISIONS
                .DESCRIPTION
                resolve-NetworkLocalTDO.ps1 - Retrieve local network interface descriptors, and resolved ip address PTR -> A Record FQDN                
                .INPUTS
                None. Does not accepted piped input.(.NET types, can add description)
                .OUTPUTS
                System.PsCustomObject summary of useful Nic descriptors                
                .EXAMPLE
                PS> $netsettings = resolve-NetworkLocalTDO ; 
                Demo run
                .LINK
                https://github.com/tostka/verb-Network
                #>                
                [CmdletBinding()]
                Param () ;
                BEGIN{
                    $rgxIP4Addr = "(?:\d{1,3}\.){3}\d{1,3}" ;
                    $rgxIP6Addr = "^((([0-9A-Fa-f]{1,4}:){1,6}:)|(([0-9A-Fa-f]{1,4}:){7}))([0-9A-Fa-f]{1,4})$" ; 
                    $rgxIP4AddrAuto = "169\.254\.\d{1,3}\.\d{1,3}" ;  
                    $prpNS = 'DNSHostName','ServiceName',@{N="DNSServerSearchOrder";E={"$($_.DNSServerSearchOrder)"}}, 
                        @{N='IPAddress';E={$_.IPAddress}},@{N='DefaultIPGateway';E={$_.DefaultIPGateway}} ;
                } ; 
                PROCESS {
                    $nicsettings = [ordered]@{ DNSHostName = $null ;  ServiceName = $null ;  DNSServerSearchOrder = $null ;  IPAddress = $null ;  DefaultIPGateway = $null ;  Fqdn = $null ;  }  ;                    
                    TRY{
                        $ret = Get-WMIObject Win32_NetworkAdapterConfiguration -Computername localhost -ea STOP|
                             ? {$_.IPEnabled -match "True"} | Select -property $prpNS ; 
                        $nicsettings.DNSHostName = $ret.DNSHostName; 
                        $nicsettings.ServiceName = $ret.ServiceName;  
                        $nicsettings.DNSServerSearchOrder = $ret.DNSServerSearchOrder;  
                        $nicsettings.IPAddress = $ret.IPAddress;  
                        $nicsettings.DefaultIPGateway = $ret.DefaultIPGateway;  
                        if($nicSettings.ipaddress | ?{$_ -MATCH $rgxIP4Addr -AND $_ -notmatch $rgxIP4AddrAuto} ){
                            $nicsettings.fqdn = (resolve-dnsname -name ($nicSettings.ipaddress | ?{$_ -MATCH $rgxIP4Addr -AND $_ -notmatch $rgxIP4AddrAuto} ) -type ptr).namehost | select -first 1 ;   
                        } ; 
                        [pscustomobject]$nicsettings | write-output ; 
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;                     
                } ; 
            }
        } ; 
        #*------^ END Function resolve-NetworkLocalTDO ^------
        #endregion RESOLVE_NETWORKLOCALTDO ; #*------^ END resolve-NetworkLocalTDO ^------

        #region OUT_CLIPBOARD ; #*------v out-Clipboard v------
        if(-not(gci function:out-Clipboard -ea 0)){
            Function out-Clipboard {
                [CmdletBinding()]
                Param (
                    [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Content to be copied to clipboard [-Content `$object]")]
                    [ValidateNotNullOrEmpty()]$Content,
                    [Parameter(HelpMessage="Switch to suppress the default 'append `n' clip.exe-emulating behavior[-NoLegacy]")]
                    [switch]$NoLegacy
                ) ;
                PROCESS {
                    if($host.version.major -lt 3){
                        # provide clipfunction downrev
                        if(-not (get-command out-clipboard)){
                            # build the alias if not pre-existing
                            $tClip = "$((Resolve-Path $env:SystemRoot\System32\clip.exe).path)" ;
                            #$input | "($tClip)" ; 
                            #$content | ($tClip) ; 
                            Set-Alias -Name 'Out-Clipboard' -Value $tClip -scope script ;
                        } ;
                        $content | out-clipboard ;
                    } else {
                        # emulate clip.exe's `n-append behavior on ps3+
                        if(-not $NoLegacy){
                            $content = $content | foreach-object {"$($_)$([Environment]::NewLine)"} ; 
                        } ; 
                        $content | set-clipboard ;
                    } ; 
                } ; 
            }
        } ; 
        #endregion OUT_CLIPBOARD ; #*------^ END out-Clipboard ^------

        #region CONVERTFROM_MARKDOWNTABLE ; #*------v convertFrom-MarkdownTable v------
        if(-not(gci function:convertFrom-MarkdownTable -ea 0)){
            Function convertFrom-MarkdownTable {
                <#
                .SYNOPSIS
                convertFrom-MarkdownTable.ps1 - Converts a Markdown table to a PowerShell object.
                .NOTES
                REVISION
                * 9:33 AM 4/11/2025 add alias: cfmdt (reflects standard verbalias)
                .PARAMETER markdowntext
                Markdown-formated table to be converted into an object [-markdowntext 'title text']
                .INPUTS
                Accepts piped input.
                .OUTPUTS
                System.Object[]
                .EXAMPLE
                PS> $svcs = Get-Service Bits,Winrm | select status,name,displayname | 
                    convertTo-MarkdownTable -border | ConvertFrom-MarkDownTable ;  
                Convert Service listing to and back from MD table, demo's working around border md table syntax (outter pipe-wrapped lines)
                .EXAMPLE
                PS> $mdtable = @"
                |EmailAddress|DisplayName|Groups|Ticket|
                |---|---|---|---|
                |da.pope@vatican.org||CardinalDL@vatican.org|999999|
                |bozo@clown.com|Bozo Clown|SillyDL;SmartDL|000001|
                "@ ; 
                    $of = ".\out-csv-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
                    $mdtable | convertfrom-markdowntable | export-csv -path $of -notype ;
                    cat $of ;

                    "EmailAddress","DisplayName","Groups","Ticket"
                    "da.pope@vatican.org","","CardinalDL@vatican.org","999999"
                    "bozo@clown.com","Bozo Clown","SillyDL;SmartDL","000001"

                Example simpler method for building csv input files fr mdtable syntax, without PSCustomObjects, hashes, or invoked object creation.
                .EXAMPLE
                PS> $mdtable | convertFrom-MarkdownTable | convertTo-MarkdownTable -border ; 
                Example to expand and dress up a simple md table, leveraging both convertfrom-mtd and convertto-mtd (which performs space padding to align pipe columns)
                .LINK
                https://github.com/tostka/verb-IO
                #>                
                [CmdletBinding()]
                [alias('convertfrom-mdt','in-markdowntable','in-mdt','cfmdt')]    
                Param (
                    [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Markdown-formated table to be converted into an object [-markdowntext 'title text']")]
                        $markdowntext
                ) ;
                PROCESS {
                    $content = @() ; 
                    if(($markdowntext|measure).count -eq 1){$markdowntext  = $markdowntext -split '\n' } ;
                    $markdowntext  = $markdowntext -replace '\|\|','| |' ; 
                    $content = $markdowntext  | ?{$_ -notmatch "--" } ;
                } ;  
                END {
                    $PsObj = $content.trim('|').trimend('|')| where-object{$_} | ForEach-Object{ 
                        ($_.split('|') | where-object{$_} | foreach-object{$_.trim()} |where-object{$_} )  -join '|' ; 
                    } | ConvertFrom-Csv -Delimiter '|'; # convert to object
                    $PsObj | write-output ; 
                } ; 
            } ;             
        } ; 
        #endregion CONVERTFROM_MARKDOWNTABLE ; #*------^ END convertFrom-MarkdownTable ^------

        #region REMOVE_INVALIDVARIABLENAMECHARS ; #*------v Remove-InvalidVariableNameChars v------
        #*------v Function Remove-InvalidVariableNameChars v------
        if(-not (gcm Remove-InvalidVariableNameChars -ea 0)){
            Function Remove-InvalidVariableNameChars ([string]$Name) {
                ($Name.tochararray() -match '[A-Za-z0-9_]') -join '' | write-output ;
            };
        } ;
        #*------^ END Function Remove-InvalidVariableNameChars ^------
        #endregion REMOVE_INVALIDVARIABLENAMECHARS ; #*------^ END Remove-InvalidVariableNameChars ^------

        #region REMOVE_SMTPPLUSADDRESS ; #*------v remove-SmtpPlusAddress v------
        function remove-SmtpPlusAddress {
            <#
            .SYNOPSIS
            remove-SmtpPlusAddress - Strips any Plus address Tag present in an smtp address, and returns the base address
            .NOTES
            Version     : 1.0.0
            Author      : Todd Kadrie
            Website     : http://www.toddomation.com
            Twitter     : @tostka / http://twitter.com/tostka
            CreatedDate : 2024-05-22
            FileName    : remove-SmtpPlusAddress
            License     : (none asserted)
            Copyright   : (none asserted)
            Github      : https://github.com/tostka/verb-Ex2010
            Tags        : Powershell,EmailAddress,Version
            AddedCredit : Bruno Lopes (brunokktro )
            AddedWebsite: https://www.linkedin.com/in/blopesinfo
            AddedTwitter: @brunokktro / https://twitter.com/brunokktro
            REVISIONS
            * 1:47 PM 7/9/2024 CBA github field correction
            * 1:22 PM 5/22/2024init
            .DESCRIPTION
            remove-SmtpPlusAddress - Strips any Plus address Tag present in an smtp address, and returns the base address

            Plus Addressing is supported in Exchange Online, Gmail, and other select hosts. 
            It is *not* supported for Exchange Server onprem. Any + addressed email will read as an unresolvable email address. 
            Supporting systems will truncate the local part (in front of the @), after the +, to resolve the email address for normal routing:

            monitoring+whatever@domain.tld, is cleaned down to: monitor@domain.tld. 

            .PARAMETER EmailAddress
            SMTP Email Address
            .OUTPUT
            String
            .EXAMPLE
            PS> 
            PS> $returned = remove-SmtpPlusAddress -EmailAddress 'monitoring+SolarWinds@toro.com';  
            PS> $returned ; 
            Demo retrieving get-EmailAddress, assigning to output, processing it for version info, and expanding the populated returned values to local variables. 
            .EXAMPLE
            ps> remove-SmtpPlusAddress -EmailAddress 'monitoring+SolarWinds@toro.com;notanemailaddresstoro.com,todd+spam@kadrie.net' -verbose ;
            Demo with comma and semicolon delimiting, and an invalid address (to force a regex match fail error).
            .LINK
            https://github.com/brunokktro/EmailAddress/blob/master/Get-ExchangeEnvironmentReport.ps1
            .LINK
            https://github.com/tostka/verb-Ex2010
            #>
            [CmdletBinding()]
            #[Alias('rvExVers')]
            PARAM(
                [Parameter(Mandatory = $true,Position=0,HelpMessage="Object returned by a get-EmailAddress command[-EmailAddress `$ExObject]")]
                    [string[]]$EmailAddress
            ) ;
            BEGIN {
                ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
                $verbose = $($VerbosePreference -eq "Continue")
                $rgxSMTPAddress = "([0-9a-zA-Z]+[-._+&='])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}" ; 
                $sBnr="#*======v $($CmdletName): v======" ;
                write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
                if($EmailAddress -match ','){
                    $smsg = "(comma detected, attempting split on commas)" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $EmailAddress = $EmailAddress.split(',') ; 
                } ; 
                if($EmailAddress -match ';'){
                    $smsg = "(semi-colon detected, attempting split on semicolons)" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    $EmailAddress = $EmailAddress.split(';') ; 
                } ; 
            }
            PROCESS {
                foreach ($item in $EmailAddress){
                    if($item -match $rgxSMTPAddress){
                        if($item.split('@')[0].contains('+')){
                            write-verbose  "Remove Plus Addresses from: $($item)" ; 
                            $lpart,$domain = $item.split('@') ; 
                            $item = "$($lpart.split('+')[0])@$($domain)" ; 
                            $smsg = "Cleaned Address: $($item)" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        }
                        $item | write-output ; 
                    } else { 
                        write-warning  "$($item)`ndoes not match a standard SMTP Email Address (skipping):`n$($rgxSmtpAddress)" ; 
                        continue ;
                    } ; 
                } ;     
            
            } # PROC-E
            END{
                write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
            }
        }; 
        #endregion REMOVE_SMTPPLUSADDRESS ; #*------^ END remove-SmtpPlusAddress ^------

        #region INITIALIZE_XOPEVENTIDTABLE ; #*------v Initialize-xopEventIDTable v------
        if(-not(gci function:Initialize-xopEventIDTable -ea 0)){
            function Initialize-xopEventIDTable {
                <#
                .SYNOPSIS
                Initialize-xopEventIDTable - Builds an indexed hash tabl of Exchange Server Get-MessageTrackingLog EventIDs
                .NOTES
                Version     : 1.0.0
                Author      : Todd Kadrie
                Website     : http://www.toddomation.com
                Twitter     : @tostka / http://twitter.com/tostka
                CreatedDate : 2025-04-22
                FileName    : Initialize-xopEventIDTable
                License     : (none asserted)
                Copyright   : (none asserted)
                Github      : https://github.com/tostka/verb-Ex2010
                Tags        : Powershell,EmailAddress,Version
                AddedCredit : Bruno Lopes (brunokktro )
                AddedWebsite: https://www.linkedin.com/in/blopesinfo
                AddedTwitter: @brunokktro / https://twitter.com/brunokktro
                REVISIONS
                * 2;58 pm 4/28/2025 Updated table again, and found Ex2016/19 eventid specifications online, added. Did find that 
                the online doc doesn't document the edge SendExternal event id (added below, manually).             
                * 1:47 PM 7/9/2024 CBA github field correction
                * 1:22 PM 5/22/2024init
                .DESCRIPTION
                Initialize-xopEventIDTable - Builds an indexed hash tabl of Exchange Server Get-MessageTrackingLog EventIDs

                ## Exchange 2019 EventID reference:

                [Event types in the message tracking log | Microsoft Learn](https://learn.microsoft.com/en-us/exchange/mail-flow/transport-logs/message-tracking?view=exchserver-2019#event-types-in-the-message-tracking-log)

                Doesn't include Edge eventid: 
                "SENDEXTERNAL          | A message was sent by SMTP to sent to the SMTP server responsible to receive the email for the external email address."
            
                (needs to be manually spliced in below 'SEND' during updates from source MS documentation)
            
                .OUTPUT
                System.Collections.Hashtable returns an Indexed Hash of EventIDs EventName to Description
                .EXAMPLE
                PS> $eventIDLookupTbl = Initialize-EventIDTable ; 
                PS> $smsg = "`n`n## EventID Definitions:" ; 
                PS> $TrackMsgs | group eventid | select -expand Name | foreach-object{                   
                PS>     $smsg += "`n$(($eventIDLookupTbl[$_] | ft -hidetableheaders |out-string).trim())" ; 
                PS> } ; 
                PS> $smsg += "`n`n" ; 
                PS> if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
                PS> else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Demo resolving histogram eventid uniques, to MS documented meansings of each event id in the msgtrack.
                .EXAMPLE
                ps> Initialize-xopEventIDTable -EmailAddress 'monitoring+SolarWinds@toro.com;notanemailaddresstoro.com,todd+spam@kadrie.net' -verbose ;
                PS> 
                Demo with comma and semicolon delimiting, and an invalid address (to force a regex match fail error).
                .LINK
                https://github.com/brunokktro/EmailAddress/blob/master/Get-ExchangeEnvironmentReport.ps1
                .LINK
                https://github.com/tostka/verb-Ex2010
                #>
                [CmdletBinding()]
                #[Alias('rvExVers')]
                PARAM() ;
                BEGIN {
                    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
                    $verbose = $($VerbosePreference -eq "Continue")
                    $rgxSMTPAddress = "([0-9a-zA-Z]+[-._+&='])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}" ; 
                    $sBnr="#*======v $($CmdletName): v======" ;
                    write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
                
                    $eventIDsMD = @"
EventName             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
--------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
AGENTINFO             | This event is used by transport agents to log custom data.                                                                                                                                                                                                                                                                                                                                                                                                                             
BADMAIL               | A message submitted by the Pickup directory or the Replay directory that can't be delivered or returned.                                                                                                                                                                                                                                                                                                                                                                               
CLIENTSUBMISSION      | A message was submitted from the Outbox of a mailbox.                                                                                                                                                                                                                                                                                                                                                                                                                                  
DEFER                 | Message delivery was delayed.                                                                                                                                                                                                                                                                                                                                                                                                                                                          
DELIVER               | A message was delivered to a local mailbox.                                                                                                                                                                                                                                                                                                                                                                                                                                            
DELIVERFAIL           | An agent tried to deliver the message to a folder that doesn't exist in the mailbox.                                                                                                                                                                                                                                                                                                                                                                                                   
DROP                  | A message was dropped without a delivery status notification (also known as a DSN, bounce message, non-delivery report, or NDR). For example:<br/>- Completed moderation approval request messages.<br/>- Spam messages that were silently dropped without an NDR.                                                                                                                                                                                                                     
DSN                   | A delivery status notification (DSN) was generated.                                                                                                                                                                                                                                                                                                                                                                                                                                    
DUPLICATEDELIVER      | A duplicate message was delivered to the recipient. Duplication may occur if a recipient is a member of multiple nested distribution groups. Duplicate messages are detected and removed by the information store.                                                                                                                                                                                                                                                                     
DUPLICATEEXPAND       | During the expansion of the distribution group, a duplicate recipient was detected.                                                                                                                                                                                                                                                                                                                                                                                                    
DUPLICATEREDIRECT     | An alternate recipient for the message was already a recipient.                                                                                                                                                                                                                                                                                                                                                                                                                        
EXPAND                | A distribution group was expanded.                                                                                                                                                                                                                                                                                                                                                                                                                                                     
FAIL                  | Message delivery failed. Sources include SMTP, DNS, QUEUE, and ROUTING.                                                                                                                                                                                                                                                                                                                                                                                                                
HADISCARD             | A shadow message was discarded after the primary copy was delivered to the next hop. For more information, see Shadow redundancy in Exchange Server.                                                                                                                                                                                                                                                                                                                                   
HARECEIVE             | A shadow message was received by the server in the local database availability group (DAG) or Active Directory site.                                                                                                                                                                                                                                                                                                                                                                   
HAREDIRECT            | A shadow message was created.                                                                                                                                                                                                                                                                                                                                                                                                                                                          
HAREDIRECTFAIL        | A shadow message failed to be created. The details are stored in the source-context field.                                                                                                                                                                                                                                                                                                                                                                                             
INITMESSAGECREATED    | A message was sent to a moderated recipient, so the message was sent to the arbitration mailbox for approval. For more information, see Manage message approval.                                                                                                                                                                                                                                                                                                                       
LOAD                  | A message was successfully loaded at boot.                                                                                                                                                                                                                                                                                                                                                                                                                                             
MODERATIONEXPIRE      | A moderator for a moderated recipient never approved or rejected the message, so the message expired. For more information about moderated recipients, see Manage message approval.                                                                                                                                                                                                                                                                                                    
MODERATORAPPROVE      | A moderator for a moderated recipient approved the message, so the message was delivered to the moderated recipient.                                                                                                                                                                                                                                                                                                                                                                   
MODERATORREJECT       | A moderator for a moderated recipient rejected the message, so the message wasn't delivered to the moderated recipient.                                                                                                                                                                                                                                                                                                                                                                
MODERATORSALLNDR      | All approval requests sent to all moderators of a moderated recipient were undeliverable, and resulted in non-delivery reports (also known as NDRs or bounce messages).                                                                                                                                                                                                                                                                                                                
NOTIFYMAPI            | A message was detected in the Outbox of a mailbox on the local server.                                                                                                                                                                                                                                                                                                                                                                                                                 
NOTIFYSHADOW          | A message was detected in the Outbox of a mailbox on the local server, and a shadow copy of the message needs to be created.                                                                                                                                                                                                                                                                                                                                                           
POISONMESSAGE         | A message was put in the poison message queue or removed from the poison message queue.                                                                                                                                                                                                                                                                                                                                                                                                
PROCESS               | The message was successfully processed.                                                                                                                                                                                                                                                                                                                                                                                                                                                
PROCESSMEETINGMESSAGE | A meeting message was processed by the Mailbox Transport Delivery service.                                                                                                                                                                                                                                                                                                                                                                                                             
RECEIVE               | A message was received by the SMTP receive component of the transport service or from the Pickup or Replay directories (source: SMTP), or a message was submitted from a mailbox to the Mailbox Transport Submission service (source: STOREDRIVER).                                                                                                                                                                                                                                    
REDIRECT              | A message was redirected to an alternative recipient after an Active Directory lookup.                                                                                                                                                                                                                                                                                                                                                                                                 
RESOLVE               | A message's recipients were resolved to a different email address after an Active Directory lookup.                                                                                                                                                                                                                                                                                                                                                                                    
RESUBMIT              | A message was automatically resubmitted from Safety Net. For more information, see Safety Net in Exchange Server.                                                                                                                                                                                                                                                                                                                                                                      
RESUBMITDEFER         | A message resubmitted from Safety Net was deferred.                                                                                                                                                                                                                                                                                                                                                                                                                                    
RESUBMITFAIL          | A message resubmitted from Safety Net failed.                                                                                                                                                                                                                                                                                                                                                                                                                                          
SEND                  | A message was sent by SMTP between transport services.                                                                                                                                                                                                                                                                                                                                                                                                                                 
SENDEXTERNAL          | A message was sent by SMTP to sent to the SMTP server responsible to receive the email for the external email address.                                                                                                                                                                                                                                                                                                                                                                                                                           
SUBMIT                | The Mailbox Transport Submission service successfully transmitted the message to the Transport service. For SUBMIT events, the source-context property contains the following details:<br/>- MDB: The mailbox database GUID.<br/>- Mailbox: The mailbox GUID.<br/>- Event: The event sequence number.<br/>- MessageClass: The type of message. For example, IPM.Note.<br/>- CreationTime: Date-time of the message submission.<br/>- ClientType: For example, User, OWA, or ActiveSync.
SUBMITDEFER           | The message transmission from the Mailbox Transport Submission service to the Transport service was deferred.                                                                                                                                                                                                                                                                                                                                                                          
SUBMITFAIL            | The message transmission from the Mailbox Transport Submission service to the Transport service failed.                                                                                                                                                                                                                                                                                                                                                                                
SUPPRESSED            | The message transmission was suppressed.                                                                                                                                                                                                                                                                                                                                                                                                                                               
THROTTLE              | The message was throttled.                                                                                                                                                                                                                                                                                                                                                                                                                                                             
TRANSFER              | Recipients were moved to a forked message because of content conversion, message recipient limits, or agents. Sources include ROUTING or QUEUE.
"@ ; 
                    # UPDATE NOTE: MANUAL UNDOCUMENTED ADDITION: "SENDEXTERNAL          | A message was sent by SMTP to sent to the SMTP server responsible to receive the email for the external email address."
                    # (needs to be manually spliced in below 'SEND' during updates from source MS documentation)
                    $Object = $eventIDsMD | convertfrom-MarkdownTable ; 
                    $Key = 'EventName' ; 
                    $Hashtable = @{}
                }
                PROCESS {
                    Foreach ($Item in $Object){
                        $Procd++ ; 
                        $Hashtable[$Item.$Key.ToString()] = $Item ; 
                        if($ShowProgress -AND ($Procd -eq $Every)){
                            write-host -NoNewline '.' ; $Procd = 0 
                        } ; 
                    } ;                 
                } # PROC-E
                END{
                    $Hashtable | write-output ; 
                    write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
                }
            };
        } ;      
        #endregion INITIALIZE_XOPEVENTIDTABLE ; #*------^ Initialize-xopEventIDTable ^------

        #endregion FUNCTIONS_INTERNAL ; #*======^ END FUNCTIONS_INTERNAL ^======

        #region CONSTANTS_AND_ENVIRO ; #*======v CONSTANTS_AND_ENVIRO v======
        #region ENVIRO_DISCOVER ; #*------v ENVIRO_DISCOVER v------
        $Verbose = [boolean]($VerbosePreference -eq 'Continue') ; 
        $rPSCmdlet = $PSCmdlet ; # an object that represents the cmdlet or advanced function that's being run. Available on functions w CmdletBinding (& $args will not be available). (Blank on non-CmdletBinding/Non-Adv funcs).
        $rPSScriptRoot = $PSScriptRoot ; # the full path of the executing script's parent directory., PS2: valid only in script modules (.psm1). PS3+:it's valid in all scripts. (Funcs: ParentDir of the file that hosts the func)
        $rPSCommandPath = $PSCommandPath ; # the full path and filename of the script that's being run, or file hosting the funct. Valid in all scripts.
        $rMyInvocation = $MyInvocation ; # populated only for scripts, function, and script blocks.
        # - $MyInvocation.MyCommand.Name returns name of a function, to identify the current command,  name of the current script (pop'd w func name, on Advfuncs)
        # - Ps3+:$MyInvocation.PSScriptRoot : full path to the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
        # - Ps3+:$MyInvocation.PSCommandPath : full path and filename of the script that invoked the current command. The value of this property is populated only when the caller is a script (blank on funcs & Advfuncs)
        #     ** note: above pair contain information about the _invoker or calling script_, not the current script
        $rPSBoundParameters = $PSBoundParameters ; 
        # splatted resolve-EnvironmentTDO CALL: 
        $pltRvEnv=[ordered]@{
            PSCmdletproxy = $rPSCmdlet ; 
            PSScriptRootproxy = $rPSScriptRoot ; 
            PSCommandPathproxy = $rPSCommandPath ; 
            MyInvocationproxy = $rMyInvocation ;
            PSBoundParametersproxy = $rPSBoundParameters
            verbose = [boolean]($PSBoundParameters['Verbose'] -eq $true) ; 
        } ;
        write-verbose "(Purge no value keys from splat)" ; 
        $mts = $pltRVEnv.GetEnumerator() |?{$_.value -eq $null} ; $mts |%{$pltRVEnv.remove($_.Name)} ; rv mts -ea 0 ; 
        $smsg = "resolve-EnvironmentTDO w`n$(($pltRVEnv|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        $rvEnv = resolve-EnvironmentTDO @pltRVEnv ; 
        $smsg = "`$rvEnv returned:`n$(($rvEnv |out-string).trim())" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        <#
        #region PsParams ; #*------v PSPARAMS v------
        $PSParameters = New-Object -TypeName PSObject -Property $rPSBoundParameters ;
        # DIFFERENCES $PSParameters vs $PSBoundParameters:
        # - $PSBoundParameters: System.Management.Automation.PSBoundParametersDictionary (native obj)
        # test/access: ($PSBoundParameters['Verbose'] -eq $true) ; $PSBoundParameters.ContainsKey('Referrer') #hash syntax
        # CAN use as a @PSBoundParameters splat to push through (make sure populated, can fail if wrong type of wrapping code)
        # - $PSParameters: System.Management.Automation.PSCustomObject (created obj)
        # test/access: ($PSParameters.verbose -eq $true) ; $PSParameters.psobject.Properties.name -contains 'SenderAddress' ; # cobj syntax
        # CANNOT use as a @splat to push through (it's a cobj)
        write-verbose "`$rPSBoundParameters:`n$(($rPSBoundParameters|out-string).trim())" ;
        # pre psv2, no $rPSBoundParameters autovari to check, so back them out:
        #>
        <# recycling $rPSBoundParameters into @splat calls: (can't use $psParams, it's a cobj, not a hash!)
        # rgx for filtering $rPSBoundParameters for params to pass on in recursive calls (excludes keys matching below)
        $rgxBoundParamsExcl = '^(Name|RawOutput|Server|Referrer)$' ; 
        if($rPSBoundParameters){
                $pltRvSPFRec = [ordered]@{} ;
                # add the specific Name for this call, and Server spec (which defaults, is generally not 
                $pltRvSPFRec.add('Name',"$RedirectRecord" ) ;
                $pltRvSPFRec.add('Referrer',$Name) ; 
                $pltRvSPFRec.add('Server',$Server ) ;
                $rPSBoundParameters.GetEnumerator() | ?{ $_.key -notmatch $rgxBoundParamsExcl} | foreach-object { $pltRvSPFRec.add($_.key,$_.value)  } ;
                write-host "Resolve-SPFRecord w`n$(($pltRvSPFRec|out-string).trim())" ;
                Resolve-SPFRecord @pltRvSPFRec  | write-output ;
        } else {
            $smsg = "unpopulated `$rPSBoundParameters!" ;
            write-warning $smsg ;
            throw $smsg ;
        };     
        #>
        #endregion PsParams ; #*------^ END PSPARAMS ^------
    
        #endregion ENVIRO_DISCOVER ; #*------^ END ENVIRO_DISCOVER ^------
        #region TLS_LATEST_FORCE ; #*------v TLS_LATEST_FORCE v------
        $CurrentVersionTlsLabel = [Net.ServicePointManager]::SecurityProtocol ; # Tls, Tls11, Tls12 ('Tls' == TLS1.0)  ;
        write-verbose "PRE: `$CurrentVersionTlsLabel : $($CurrentVersionTlsLabel )" ;
        # psv6+ already covers, test via the SslProtocol parameter presense
        if ('SslProtocol' -notin (Get-Command Invoke-RestMethod).Parameters.Keys) {
            $currentMaxTlsValue = [Math]::Max([Net.ServicePointManager]::SecurityProtocol.value__,[Net.SecurityProtocolType]::Tls.value__) ;
            write-verbose "`$currentMaxTlsValue : $($currentMaxTlsValue )" ;
            $newerTlsTypeEnums = [enum]::GetValues('Net.SecurityProtocolType') | Where-Object { $_ -gt $currentMaxTlsValue }
            if($newerTlsTypeEnums){
                write-verbose "Appending upgraded/missing TLS `$enums:`n$(($newerTlsTypeEnums -join ','|out-string).trim())" ;
            } else {
                write-verbose "Current TLS `$enums are up to date with max rev available on this machine" ;
            };
            $newerTlsTypeEnums | ForEach-Object {
                [Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor $_
            } ;
        } ;
        #endregion TLS_LATEST_FORCE ; #*------^ END TLS_LATEST_FORCE ^------

        #region COMMON_CONSTANTS ; #*------v COMMON_CONSTANTS v------
    
        if(-not $DoRetries){$DoRetries = 4 } ;    # # times to repeat retry attempts
        if(-not $RetrySleep){$RetrySleep = 10 } ; # wait time between retries
        if(-not $RetrySleep){$DawdleWait = 30 } ; # wait time (secs) between dawdle checks
        if(-not $DirSyncInterval){$DirSyncInterval = 30 } ; # AADConnect dirsync interval
        if(-not $ThrottleMs){$ThrottleMs = 50 ;}
        if(-not $rgxDriveBanChars){$rgxDriveBanChars = '[;~/\\\.:]' ; } ; # ;~/\.:,
        if(-not $rgxCertThumbprint){$rgxCertThumbprint = '[0-9a-fA-F]{40}' } ; # if it's a 40char hex string -> cert thumbprint  
        if(-not $rgxSmtpAddr){$rgxSmtpAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; } ; # email addr/UPN
        if(-not $rgxDomainLogon){$rgxDomainLogon = '^[a-zA-Z][a-zA-Z0-9\-\.]{0,61}[a-zA-Z]\\\w[\w\.\- ]+$' } ; # DOMAIN\samaccountname 
        if(-not $exoMbxGraceDays){$exoMbxGraceDays = 30} ; 
        if(-not $XOConnectionUri ){$XOConnectionUri = 'https://outlook.office365.com'} ; 
        if(-not $SCConnectionUri){$SCConnectionUri = 'https://ps.compliance.protection.outlook.com'} ; 
        #$rgxADDistNameGAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 1 ) -join ',')" 
        #$rgxADDistNameAT = ",$(($TORMeta.UnreplicatedOU -split ',' | select -skip 2 ) -join ',')"
        
        write-verbose "Coerce configured but blank Resultsize to Unlimited" ; 
        if(get-variable -name resultsize -ea 0){
            if( ($null -eq $ResultSize) -OR ('' -eq $ResultSize) ){$ResultSize = 'unlimited' }
            elseif($Resultsize -is [int]){} else {throw "Resultsize must be an integer or the string 'unlimited' (or blank)"} ;
        } ; 
        #$ComputerName = $env:COMPUTERNAME ;
        #$NoProf = [bool]([Environment]::GetCommandLineArgs() -like '-noprofile'); # if($NoProf){# do this};
        # XXXMeta derived constants:
        # - AADU Licensing group checks
        # calc the rgxLicGrpName fr the existing $xxxmeta.rgxLicGrpDN: (get-variable tormeta).value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
        #$rgxLicGrpName = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN.split(',')[0].replace('^','').replace('CN=','')
        # use the dn vers LicGrouppDN = $null ; # | ?{$_ -match $tormeta.rgxLicGrpDN}
        #$rgxLicGrpDN = (get-variable -name "$($tenorg)meta").value.rgxLicGrpDN
        # email trigger vari, it will be semi-delimd list of mail-triggering events
        $script:PassStatus = $null ;
        # TenOrg or other looped-specific PassStatus (auto supported by 7pswlt)
        #New-Variable -Name PassStatus_$($tenorg) -scope Script -Value $null ;
        [array]$SmtpAttachment = $null ;
        #write-verbose "start-Timer:Master" ; 
        $swM = [Diagnostics.Stopwatch]::StartNew() ;
        # $ByPassLocalExchangeServerTest = $true # rough in, code exists below for exempting service/regkey testing on this variable status. Not yet implemented beyond the exemption code, ported in from orig source.
        #endregion COMMON_CONSTANTS ; #*------^ END COMMON_CONSTANTS ^------

        #region LOCAL_CONSTANTS ; #*------v LOCAL_CONSTANTS v------

        $DaysLimit = 30 ; # technically no specific limit to Get-MessageTrackingLog, but practical matter they're limited to 30d on the drive
        $rgxIsPlusAddrSmtpAddr = "[+].*@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}" ; 
        $prpMTLfta = 'Timestamp','EventId','Sender','Recipients','MessageSubject' ; 
        $prpXCsv = "Timestamp",@{N='TimestampLocal'; E={$_.Timestamp.ToLocalTime()}},"Source","EventId","RelatedRecipientAddress","Sender",@{N='Recipients'; E={$_.Recipients}},"RecipientCount",@{N='RecipientStatus'; E={$_.RecipientStatus}},"MessageSubject","TotalBytes",@{N='Reference'; E={$_.Reference}},"MessageLatency","MessageLatencyType","InternalMessageId","MessageId","ReturnPath","ClientIp","ClientHostname","ServerIp","ServerHostname","ConnectorId","SourceContext","MessageInfo",@{N='EventData'; E={$_.EventData}} ;
        $prpMTFailFL = 'Timestamp','ClientHostname','Source','EventId','Recipients','RecipientStatus','MessageSubject','ReturnPath' ;
        $s24HTimestamp = 'yyyyMMdd-HHmm'
        $sFiletimestamp =  $s24HTimestamp
        #region LOCAL_CONSTANTS ; #*------^ END LOCAL_CONSTANTS ^------

        #region ENCODED_CONTANTS ; #*------v ENCODED_CONTANTS v------
        # ENCODED CONsTANTS & SUPPORT FUNCTIONS:
        #region 2B4 ; #*------v 2B4 v------
        if(-not (get-command 2b4 -ea 0)){function 2b4{[CmdletBinding()][Alias('convertTo-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str|%{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))}  };} ; } ; 
        #endregion 2B4 ; #*------^ END 2B4 ^------
        #region 2B4C ; #*------v 2B4C v------
        # comma-quoted return
        if(-not (get-command 2b4c -ea 0)){function 2b4c{ [CmdletBinding()][Alias('convertto-Base64StringCommaQuoted')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ;BEGIN{$outs = @()} PROCESS{[array]$outs += $str | %{[Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($_))} ; } END {'"' + $(($outs) -join '","') + '"' | out-string | set-clipboard } ; } ; } ; 
        #endregion 2B4C ; #*------^ END 2B4C ^------
        #region FB4 ; #*------v FB4 v------
        # DEMO: $SitesNameList = 'THluZGFsZQ==','U3BlbGxicm9vaw==','QWRlbGFpZGU=' | fb4 ;
        if(-not (get-command fb4 -ea 0)){function fb4{[CmdletBinding()][Alias('convertFrom-Base64String')] PARAM([Parameter(ValueFromPipeline=$true)][string[]]$str) ; PROCESS{$str | %{ [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($_)) }; } ; } ; }; 
        #endregion FB4 ; #*------^ END FB4 ^------
        # FOLLOWING CONSTANTS ARE USED FOR DEPENDANCY-LESS CONNECTIONS
        if(-not $o365_Toroco_SIDUpn){$o365_Toroco_SIDUpn = 'cy10b2RkLmthZHJpZUB0b3JvLmNvbQ==' | fb4 } ;
        $o365_SIDUpn = $o365_Toroco_SIDUpn ; 
        switch($env:Userdomain){
            'CMW'{
                if(-not $CMW_logon_SID){$CMW_logon_SID = 'Q01XXGQtdG9kZC5rYWRyaWU=' | fb4 } ; 
                $logon_SID = $CMW_logon_SID ; 
            }
            'TORO'{
                if(-not $TOR_logon_SID){$TOR_logon_SID = 'VE9ST1xrYWRyaXRzcw==' | fb4 } ; 
                $logon_SID = $TOR_logon_SID ; 
            }
            $env:COMPUTERNAME{
                $smsg = "%USERDOMAIN% -EQ %COMPUTERNAME%: $($env:computername) => non-domain-connected, likely edge role Ex server!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                if($WorkgroupName = (Get-WmiObject -Class Win32_ComputerSystem).Workgroup){
                    $smsg = "WorkgroupName:$($WorkgroupName)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                }
                if(($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup')) -or (
                        $isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup')) -or
                            $ByPassLocalExchangeServerTest){
                            $smsg = "We are on Exchange Server"
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            $IsEdgeTransport = $false
                            if((Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\EdgeTransportRole') -or (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\EdgeTransportRole')){
                                $smsg = "We are on Exchange Edge Transport Server"
                                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                                $IsEdgeTransport = $true
                            } ; 
                } else {
                    $isLocalExchangeServer = $false 
                    $IsEdgeTransport = $false ;
                } ;
            } ; 
            default{
                $smsg = "$($env:userdomain):UNRECOGIZED/UNCONFIGURED USER DOMAIN STRING!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                THROW $SMSG 
                BREAK ; 
            }
        } ; 
        #endregion ENCODED_CONTANTS ; #*------^ END ENCODED_CONTANTS ^------
        
        #endregion CONSTANTS_AND_ENVIRO ; #*======^ CONSTANTS_AND_ENVIRO ^======

        # 5:03 PM 4/22/2025 MOVED FUNCTIONS UP TO TOP OF BEGIN, NOTHING IS AVAIL, UNLESS PREDECLARED, ON CURLY

        #region SUBMAIN ; #*======v SUB MAIN v======
        $smsg = #*------v Function SUB MAIN v------"
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

        #region BANNER ; #*------v BANNER v------
        $sBnr="#*======v $(${CmdletName}): v======" ;
        $smsg = $sBnr ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #endregion BANNER ; #*------^ END BANNER ^------
            

        #region START_LOG_OPTIONS #*======v START_LOG_OPTIONS v======
        $useSLogHOl = $true ; # one or 
        $useSLogSimple = $false ; #... the other
        $useTransName = $false ; # TRANSCRIPTNAME
        $useTransPath = $false ; # TRANSCRIPTPATH
        $useTransRotate = $false ; # TRANSCRIPTPATHROTATE
        $useStartTrans = $false ; # STARTTRANS
        #region START_LOG_HOLISTIC #*------v START_LOG_HOLISTIC v------
        if($useSLogHOl){
            # Single log for script/function example that accomodates detect/redirect from AllUsers scope'd installed code, and hunts a series of drive letters to find an alternate logging dir (defers to profile variables)
            #${CmdletName} = $rPSCmdlet.MyInvocation.MyCommand.Name ;
            if(-not (get-variable LogPathDrives -ea 0)){$LogPathDrives = 'd','c' };
            foreach($budrv in $LogPathDrives){if(test-path -path "$($budrv):\scripts" -ea 0 ){break} } ;
            if(-not (get-variable rgxPSAllUsersScope -ea 0)){
                $rgxPSAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps(((d|m))*)1|dll)$" ;
            } ;
            if(-not (get-variable rgxPSCurrUserScope -ea 0)){
                $rgxPSCurrUserScope="^$([regex]::escape([Environment]::GetFolderPath('MyDocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)\\.*\.(ps((d|m)*)1|dll)$" ;
            } ;
            $pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($whatif) ;} ;
            # if using [CmdletBinding(SupportsShouldProcess)] + -WhatIf:$($WhatIfPreference):
            #$pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag=$null ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($WhatIfPreference) ;} ;
            #$pltSL=[ordered]@{Path=$null ;NoTimeStamp=$false ;Tag="$($ticket)-$($TenOrg)-LASTPASS-" ;showdebug=$($showdebug) ; Verbose=$($VerbosePreference -eq 'Continue') ; whatif=$($WhatIfPreference) ;} ;
            #$pltSL.Tag = $ModuleName ; 
            #$pltSL.Tag = "$($ticket)-$($usr)" ; 
            #$pltSL.Tag = $((@($ticket,$usr) |?{$_}) -join '-')
            if($ticket){$pltSL.Tag = $ticket} ;
            <#
            if($rPSBoundParameters.keys){ # alt: leverage $rPSBoundParameters hash
                $sTag = @() ; 
                #$pltSL.TAG = $((@($rPSBoundParameters.keys) |?{$_}) -join ','); # join all params
                if($rPSBoundParameters['Summary']){ $sTag+= @('Summary') } ; # build elements conditionally, string
                if($rPSBoundParameters['Number']){ $sTag+= @("Number$($rPSBoundParameters['Number'])") } ; # and keyname,value
                $pltSL.Tag = $sTag -join ',' ; 
            } ; 
            #>
            if($rvEnv.isScript){
                write-host "`$script:PSCommandPath:$($script:PSCommandPath)" ;
                write-host "`$PSCommandPath:$($PSCommandPath)" ;
                if($rvEnv.PSCommandPathproxy){ $prxPath = $rvEnv.PSCommandPathproxy }
                elseif($script:PSCommandPath){$prxPath = $script:PSCommandPath}
                elseif($rPSCommandPath){$prxPath = $rPSCommandPath} ; 
            } ; 
            if($rvEnv.isFunc){
                if($rvEnv.FuncDir -AND $rvEnv.FuncName){
                       $prxPath = join-path -path $rvEnv.FuncDir -ChildPath $rvEnv.FuncName ; 
                } ; 
            } ; 
            if(-not $rvEnv.isFunc){
                # under funcs, this is the scriptblock of the func, not a path
                if($rvEnv.MyInvocationproxy.MyCommand.Definition){$prxPath2 = $rvEnv.MyInvocationproxy.MyCommand.Definition }
                elseif($rvEnv.MyInvocationproxy.MyCommand.Definition){$prxPath2 = $rvEnv.MyInvocationproxy.MyCommand.Definition } ; 
            } ; 
            if($prxPath){
                if(($prxPath -match $rgxPSAllUsersScope) -OR ($prxPath -match $rgxPSCurrUserScope)){
                    $bDivertLog = $true ; 
                    switch -regex ($prxPath){
                        $rgxPSAllUsersScope{$smsg = "AllUsers"} 
                        $rgxPSCurrUserScope{$smsg = "CurrentUser"}
                    } ;
                    $smsg += " context script/module, divert logging into [$budrv]:\scripts" 
                    write-verbose $smsg  ;
                    if($bDivertLog){
                        if((split-path $prxPath -leaf) -ne $rvEnv.CmdletName){
                            # function in a module/script installed to allusers|cu - defer name to Cmdlet/Function name
                            $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($rvEnv.CmdletName).ps1") ;
                        } else {
                            # installed allusers|CU script, use the hosting script name
                            $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath -leaf)) ;
                        }
                    } ;
                } else {
                    $pltSL.Path = $prxPath ;
                } ;
            }elseif($prxPath2){
                if(($prxPath2 -match $rgxPSAllUsersScope) -OR ($prxPath2 -match $rgxPSCurrUserScope) ){
                        $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath (split-path $prxPath2 -leaf)) ;
                } elseif(test-path $prxPath2) {
                    $pltSL.Path = $prxPath2 ;
                } elseif($rvEnv.CmdletName){
                    $pltSL.Path = (join-path -Path "$($budrv):\scripts" -ChildPath "$($rvEnv.CmdletName).ps1") ;
                } else {
                    $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$rvEnv.CmdletName, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    BREAK ;
                } ; 
            } else{
                $smsg = "UNABLE TO RESOLVE A FUNCTIONAL `$rvEnv.CmdletName, FROM WHICH TO BUILD A START-LOG.PATH!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } #Error|Warn|Debug 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                BREAK ;
            }  ;
            write-verbose "start-Log w`n$(($pltSL|out-string).trim())" ; 
            $logspec = start-Log @pltSL ;
            $error.clear() ;
            TRY {
                if($logspec){
                    $logging=$logspec.logging ;
                    $logfile=$logspec.logfile ;
                    $transcript=$logspec.transcript ;
                    $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                    if($stopResults){
                        $smsg = "Stop-transcript:$($stopResults)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    } ; 
                    $startResults = start-Transcript -path $transcript ;
                    if($startResults){
                        $smsg = "start-transcript:$($startResults)" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                } else {throw "Unable to configure logging!" } ;
            } CATCH [System.Management.Automation.PSNotSupportedException]{
                if($host.name -eq 'Windows PowerShell ISE Host'){
                    $smsg = "This version of $($host.name):$($host.version) does *not* support native (start-)transcription" ; 
                } else { 
                    $smsg = "This host does *not* support native (start-)transcription" ; 
                } ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } ; 
        #endregion START_LOG_HOLISTIC #*------^ END START_LOG_HOLISTIC ^------
        #...
        #endregion START_LOG_OPTIONS #*======^ START_LOG_OPTIONS ^======

        #region NETWORK_INFO ; #*======v NETWORK_INFO v======
        $netsettings = resolve-NetworkLocalTDO ; 
        #endregion NETWORK_INFO ; #*======^ END NETWORK_INFO ^======

        #region SERVICE_CONNECTIONS #*======v SERVICE_CONNECTIONS v======
        # PRETUNE STEERING separately *before* pasting in balance of region
        # THIS BLOCK DEPS ON VERB-* FANCY CRED/AUTH HANDLING MODULES THAT *MUST* BE INSTALLED LOCALLY TO FUNCTION
        # NOTE: *DOES* INCLUDE *PARTIAL* DEP-LESS $useExopNoDep=$true OPT THAT LEVERAGES Connect-ExchangeServerTDO, VS connect-ex2010 & CREDS ARE ASSUMED INHERENT TO THE ACCOUNT) 
        # Connect-ExchangeServerTDO HAS SUBSTANTIAL BENEFIT, OF WORKING SEAMLESSLY ON EDGE SERVER AND RANGE OF DOMAIN-=CONNECTED EXOP ROLES
        $useO365 = $false ;
        $useEXO = $false ; 
        $UseOP=$true ; 
        $UseExOP=$true ;
        $useExopNoDep = $true ; # switch to use Connect-ExchangeServerTDO, vs connect-ex2010 (creds are assumed inherent to the account)
        $ExopVers = 'Ex2010' # 'Ex2019','Ex2016','Ex2013','Ex2010','Ex2007','Ex2003','Ex2000', Null for All versions
        if($Version){
            $ExopVers = $Version ; #defer to local script $version if set
        } ; 
        $useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
        $UseOPAD = $false ; 
        $UseMSOL = $false ; # should be hard disabled now in o365
        $UseAAD = $false  ; 
        if($env:userdomain -eq $env:computername){
            $isNonDomainServer = $true ; 
            $UseOPAD = $false ; 
        } 
        if(get-service MSExchangeTransport -ea 0){
            $UseExOP = $true ; 
            if( ($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\Setup')) -or
                    ($isLocalExchangeServer = (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\Setup')) -or $ByPassLocalExchangeServerTest)
                {
                    if((Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v14\EdgeTransportRole') -or
                            (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v15\EdgeTransportRole')) {
                        $smsg = "We are on Exchange Edge Transport Server"
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $IsEdgeTransport = $true ; 
                        if($IsEdgeTransport -AND $psise){
                            $smsg = "powershell_ISE UNDER Exchange Edge Transport role!" 
                            $smsg += "`nThis script is likely to fail the get-messagetrackingLog calls etc with Access Denied errors"
                            $smsg += "`nif run with this combo."
                            $smsg += "`nEXIT POWERSHELL ISE, AND RUN THIS DIRECTLY UNDER EMS FOR EDGE USE"; 
                            $smsg += "`n(bug appears to be a conflict in Remote EMS v EMS access permissions, not resolved yet)" ; 
                            write-warning $smsg ; 
                        } ; 
                    } else {
                        $IsEdgeTransport = $false ; 
                    } ; 
                } ; 
        }else{
            $isLocalExchangeServer = $false ; 
        } ; 
        $useO365 = [boolean]($useO365 -OR $useEXO -OR $UseMSOL -OR $UseAAD)
        $UseOP = [boolean]($UseOP -OR $UseExOP -OR $UseOPAD) ;
        #*------^ END STEERING VARIS ^------
        #*------v EXO V2/3 steering constants v------
        $EOMModName =  'ExchangeOnlineManagement' ;
        $EOMMinNoWinRMVersion = $MinNoWinRMVersion = '3.0.0' ; # support both names
        #*------^ END EXO V2/3 steering constants ^------
        # assert Org from Credential specs (if not param'd)
        # 1:36 PM 7/7/2023 and revised again -  revised the -AND, for both, logic wasn't working
        if($TenOrg){    
            $smsg = "Confirmed populated `$TenOrg" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } elseif(-not($tenOrg) -and $Credential){
            $smsg = "(unconfigured `$TenOrg: asserting from credential)" ; 
            if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if((get-command get-TenantTag).Parameters.keys -contains 'silent'){
                $TenOrg = get-TenantTag -Credential $Credential -silent ;;
            }else {
                $TenOrg = get-TenantTag -Credential $Credential ;
            }
        } else { 
            # if not using Credentials or a TargetTenants/TenOrg loop, default the $TenOrg on the $env:USERDOMAIN
            $smsg = "(unconfigured `$TenOrg & *NO* `$Credential: fallback asserting from `$env:USERDOMAIN)" ; 
            if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            switch -regex ($env:USERDOMAIN){
                ([regex]('(' + (( @($TORMeta.legacyDomain,$CMWMeta.legacyDomain)  |foreach-object{[regex]::escape($_)}) -join '|') + ')')).tostring() {$TenOrg = $env:USERDOMAIN.substring(0,3).toupper() } ;
                $TOLMeta.legacyDomain {$TenOrg = 'TOL' }
                $env:COMPUTERNAME {
                    # non-domain-joined, no domain, but the $netsettings.fqdn has a dns suffix that can be steered.
                    if($netsettings.fqdn){
                    switch -regex (($netsettings.fqdn.split('.') | select -last 2 ) -join '.'){
                      'toro\.com$' {$tenorg = 'TOR' ; } ; 
                      '(charlesmachineworks\.com|cmw\.internal)$' { $TenOrg = 'CMW'} ; 
                      '(torolab\.com|snowthrower\.com)$'  { $TenOrg = 'TOL'} ; 
                      default {throw "UNRECOGNIZED DNS SUFFIX!:$(($netsettings.fqdn.split('.') | select -last 2 ) -join '.')" ; break ; } ;
                    } ; 
                    }else{
                        throw "NIC.ip $($netsettings.ipaddress) does not PTR resolve to a DNS A with a full fqdn!" ; 
                    } ; 
                } ; 
                default {throw "UNRECOGNIZED `$env:USERDOMAIN!:$($env:USERDOMAIN)" ; exit ; } ;
            } ; 
        } ; 
        #region useO365 ; #*------v useO365 v------
        #$useO365 = $false ; # non-dyn setting, drives variant EXO reconnect & query code
        #if($CloudFirst){ $useO365 = $true } ; # expl: steering on a parameter
        if($useO365){
            #region GENERIC_EXO_CREDS_&_SVC_CONN #*------v GENERIC EXO CREDS & SVC CONN BP v------
            # o365/EXO creds
            <### Usage: Type defaults to SID, if not spec'd - Note: there must be a *logged in & configured *profile*
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole SID ;
            Returns a credential set for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole CSVC ;
            Returns the CSVC Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            .EXAMPLE
            $o365Cred = get-TenantCredentials -TenOrg $TenOrg -verbose -userrole B2BI ;
            Returns the B2BI Userrole credential for the $TenOrg Hybrid OnPrem Exchange Org
            ###>
            $o365Cred = $null ;
            if($Credential){
                $smsg = "`Credential:Explicit credentials specified, deferring to use..." ; 
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                # get-TenantCredentials() return format: (emulating)
                $o365Cred = [ordered]@{
                    Cred=$Credential ; 
                    credType=$null ; 
                } ; 
                $uRoleReturn = resolve-UserNameToUserRole -UserName $Credential.username -verbose:$($VerbosePreference -eq "Continue") ; # Username
                #$uRoleReturn = resolve-UserNameToUserRole -Credential $Credential -verbose = $($VerbosePreference -eq "Continue") ;   # full Credential support
                if($uRoleReturn.UserRole){
                    $o365Cred.credType = $uRoleReturn.UserRole ; 
                } else { 
                    $smsg = "Unable to resolve `$credential.username ($($credential.username))"
                    $smsg += "`nto a usable 'UserRole' spec!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw $smsg ;
                    Break ;
                } ; 
            } else { 
                $pltGTCred=@{TenOrg=$TenOrg ; UserRole=$null; verbose=$($verbose)} ;
                if($UserRole){
                    $smsg = "(`$UserRole specified:$($UserRole -join ','))" ; 
                    if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $pltGTCred.UserRole = $UserRole; 
                } else { 
                    $smsg = "(No `$UserRole found, defaulting to:'CSVC','SID' " ; 
                    if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                    $pltGTCred.UserRole = 'CSVC','SID' ; 
                } ; 
                $smsg = "get-TenantCredentials w`n$(($pltGTCred|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $o365Cred = get-TenantCredentials @pltGTCred
            } ; 
            if($o365Cred.credType -AND $o365Cred.Cred -AND $o365Cred.Cred.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                $smsg = "(validated `$o365Cred contains .credType:$($o365Cred.credType) & `$o365Cred.Cred.username:$($o365Cred.Cred.username)" ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE }
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                # 9:58 AM 6/13/2024 populate $credential with return, if not populated (may be required for follow-on calls that pass common $Credentials through)
                if((gv Credential) -AND $null -eq $Credential){
                    $credential = $o365Cred.Cred ;
                }elseif($credential.gettype().fullname -eq 'System.Management.Automation.PSCredential'){
                    $smsg = "(`$Credential is properly populated; explicit -Credential was in initial call)" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                } else {
                    $smsg = "`$Credential is `$NULL, AND $o365Cred.Cred is unusable to populate!" ;
                    $smsg = "downstream commands will *not* properly pass through usable credentials!" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw $smsg ;
                    break ;
                } ;
            } else {
                $smsg = "UNABLE TO RESOLVE FUNCTIONAL CredType/UserRole from specified explicit -Credential:$($Credential.username)!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                break ;
            } ; 
            if($o365Cred){
                # make it script scope, so we don't have to predetect & purge before using new-variable
                if(get-Variable -Name cred$($tenorg) -scope Script -ea 0 ){ remove-Variable -Name cred$($tenorg) -scope Script } ;
                New-Variable -Name cred$($tenorg) -scope Script -Value $o365Cred.cred ;
                $smsg = "Resolved $($Tenorg) `$o365cred:$($o365Cred.cred.username) (assigned to `$cred$($tenorg))" ;
                if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                $script:PassStatus += $statusdelta ;
                set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatettus_$($tenorg)).value + $statusdelta) ;
                $smsg = "Unable to resolve $($tenorg) `$o365Cred value!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                throw "Unable to resolve $($tenorg) `$o365Cred value!`nEXIT!"
                Break ;
            } ;
            # if we get here, wo a $Credential, w resolved $o365Cred, assign it 
            if(-not $Credential -AND $o365Cred){$Credential = $o365Cred.cred } ; 
            # configure splat for connections: (see above useage)
            # downstream commands
            $pltRXO = [ordered]@{
                Credential = $Credential ;
                verbose = $($VerbosePreference -eq "Continue")  ;
            } ;
            if((get-command Reconnect-EXO).Parameters.keys -contains 'silent'){
                $pltRxo.add('Silent',$silent) ;
            } ;
            # default connectivity cmds - force silent 
            $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$silent) ; 
            if((get-command Reconnect-EXO).Parameters.keys -notcontains 'silent'){
                $pltRxo.remove('Silent') ;
            } ; 
            #region EOMREV ; #*------v EOMREV Check v------
            #$EOMmodname = 'ExchangeOnlineManagement' ;
            $pltIMod = @{Name = $EOMmodname ; ErrorAction = 'Stop' ; verbose=$false} ;
            # do a gmo first, faster than gmo -list
            if([version]$EOMMv = (Get-Module @pltIMod).version){}
            elseif([version]$EOMMv = (Get-Module -ListAvailable @pltIMod).version){}
            else {
                $smsg = "$($EOMmodname) PowerShell v$($MinNoWinRMVersion) module is required, do you want to install it?" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt }
                else{ $smsg = "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $bRet = Read-Host "Enter YYY to continue. Anything else will exit"  ;
                if ($bRet.ToUpper() -eq "YYY") {
                    $smsg = "Installing $($EOMmodname) module..." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info }
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Install-Module $EOMmodname -Repository PSGallery -AllowClobber -Force ;
                } else {
                    $smsg = "Please install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module." ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN }
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #exit 1
                    break ;
                }  ;
            } ;
            $smsg = "(Checking for WinRM support in this EOM rev...)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if([version]$EOMMv -ge [version]$MinNoWinRMVersion){
                $MinNoWinRMVersion = $EOMMv.tostring() ;
                $IsNoWinRM = $true ;
            }elseif([version]$EOMMv -lt [version]$MinimumVersion){
                $smsg = "Installed $($EOMmodname) is v$($MinNoWinRMVersion): This module is obsolete!" ;
                $smsg += "`nAnd unsupported by this function!" ;
                $smsg += "`nPlease install $($EOMmodname) PowerShell v$($MinNoWinRMVersion)  module!" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break ;
            } else {
                $IsNoWinRM = $false ;
            } ;
            [boolean]$UseConnEXO = [boolean]([version]$EOMMv -ge [version]$MinNoWinRMVersion) ;
            #endregion EOMREV ; #*------^ END EOMREV Check  ^------
            #-=-=-=-=-=-=-=-=
            <### CALLS ARE IN FORM: (cred$($tenorg))
            # downstream commands
            $pltRXO = @{
                Credential = (Get-Variable -name cred$($tenorg) ).value ;
                #verbose = $($verbose) ;
                Verbose = $FALSE ; 
            } ;
            if((get-command Reconnect-EXO).Parameters.keys -contains 'silent'){
                $pltRxo.add('Silent',$false) ;
            } ; 
            # default connectivity cmds - force silent false
            $pltRXOC = [ordered]@{} ; $pltRXO.GetEnumerator() | ?{ $_.Key -notmatch 'silent' }  | ForEach-Object { $pltRXOC.Add($_.Key, $_.Value) } ; $pltRXOC.Add('silent',$true) ;
            if((get-command Reconnect-EXO).Parameters.keys -notcontains 'silent'){
                $pltRxo.remove('Silent') ;
            } ; 
            #$pltRXO creds & .username can also be used for AzureAD connections:
            #Connect-AAD @pltRXOC ;
            ###>
            #endregion GENERIC_EXO_CREDS_&_SVC_CONN #*------^ END GENERIC EXO CREDS & SVC CONN BP ^------

        } else {
            $smsg = "(`$useO365:$($useO365))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; # if-E if($useO365 ){
        #endregion useO365 ; #*------^ END useO365 ^------

        #region useEXO ; #*------v useEXO v------
        # 1:29 PM 9/15/2022 as of MFA & v205, have to load EXO *before* any EXOP, or gen get-steppablepipeline suffix conflict error
        if($useEXO){
            if ($script:useEXOv2 -OR $useEXOv2) { reconnect-eXO2 @pltRXOC }
            else { reconnect-EXO @pltRXOC } ;
        } else {
            $smsg = "(`$useEXO:$($useEXO))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ; # if-E 
        #endregion  ; #*------^ END useEXO ^------

        #region GENERIC_EXOP_CREDS_&_SRVR_CONN #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
        # steer all onprem code on $XXXMeta.ExOPAccessFromToro & Ex10Server values
        #$UseOP=$true ; 
        #$UseExOP=$true ;
        #$useExopNoDep = $true # switch to use Connect-ExchangeServerTDO, vs connect-ex2010 (creds are assumed inherent to the account) 
        #$useForestWide = $true ; # flag to trigger cross-domain/forest-wide code in AD & EXoP
        <# no onprem dep
        if((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro -AND (Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server){
            $UseOP = $UseExOP = $true ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`ENABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } else {
            $UseOP = $UseExOP = $false ;
            $smsg = "$($TenOrg):Meta.ExOPAccessFromToro($((Get-Variable  -name "$($TenOrg)Meta").value.ExOPAccessFromToro)) -AND/OR Meta.Ex10Server($((Get-Variable  -name "$($TenOrg)Meta").value.Ex10Server)),`nDISABLING use of OnPrem Ex system this pass." ;
            if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } ;
        #>
        if($UseOP){
            <#if($useExopNoDep){
                # Connect-ExchangeServerTDO use: creds are implied from the PSSession creds; assumed to have EXOP perms
                # 3:14 PM 1/9/2025 no they aren't, it still wants explicit creds to connect - I've just been doing rx10 and pre-initiating
            } else {
            #>
            # useExopNoDep: at this point creds are *not* implied from the PS context creds. So have to explicitly pass in $creds on the new-Pssession etc, 
            # so we always need the EXOP creds block, or at worst an explicit get-credential prompt to gather when can't find in enviro or profile. 
            #*------v GENERIC EXOP CREDS & SRVR CONN BP v------
            if($TenOrg -ne 'CMW'){
                # do the OP creds too
                $OPCred=$null ;
                # default to the onprem svc acct
                # userrole='ESVC','SID'
                #$pltGHOpCred=@{TenOrg=$TenOrg ;userrole='ESVC','SID'; verbose=$($verbose)} ;
                # userrole='SID','ESVC'
                $pltGHOpCred=@{TenOrg=$TenOrg ;userrole='SID','ESVC'; verbose=$($verbose)} ;
                $smsg = "get-HybridOPCredentials w`n$(($pltGHOpCred|out-string).trim())" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level verbose } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
                    # make it script scope, so we don't have to predetect & purge before using new-variable
                    if(get-Variable -Name "cred$($tenorg)OP" -scope Script -ea 0 ){ remove-Variable -Name "cred$($tenorg)OP" -scope Script } ;
                    New-Variable -Name "cred$($tenorg)OP" -scope Script -Value $OPCred ;
                    $smsg = "Resolved $($Tenorg) `$OPCred:$($OPCred.username) (assigned to `$cred$($tenorg)OP)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } else {
                    $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                    $script:PassStatus += $statusdelta ;
                    set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta) ;
                    $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole 'ESVC' value!"
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
                    Break ;
                } ;
                $smsg= "Using OnPrem/EXOP cred:`$cred$($tenorg)OP:$((Get-Variable -name "cred$($tenorg)OP" ).value.username)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                <### CALLS ARE IN FORM: (cred$($tenorg))
                $pltRX10 = @{
                    Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                    #verbose = $($verbose) ;
                    Verbose = $FALSE ; 
                } ;
                $1stConn = $false ; # below uses silent suppr for both x10 & xo!
                if($1stConn){
                    $pltRX10.silent = $pltRXO.silent = $false ;
                } else {
                    $pltRX10.silent = $pltRXO.silent =$true ;
                } ;
                if($pltRX10){ReConnect-Ex2010 @pltRX10 }
                else {ReConnect-Ex2010 }
                #$pltRx10 creds & .username can also be used for local ADMS connections
                ###>
                $pltRX10 = @{
                    Credential = (Get-Variable -name "cred$($tenorg)OP" ).value ;
                    #verbose = $($verbose) ;
                    Verbose = $FALSE ; 
                } ;
                if((get-command Reconnect-Ex2010).Parameters.keys -contains 'silent'){
                    $pltRX10.add('Silent',$false) ;
                } ;
                # defer cx10/rx10, until just before get-recipients qry
                # connect to ExOP X10
            } ; # skip above on CMW, the mods aren't installed
            if($useEXOP){
                if($useExopNoDep){ 
                    $smsg = "(Using ExOP:Connect-ExchangeServerTDO(), connect to local ComputerSite)" ; 
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;           
                    TRY{
                        $Site=[System.DirectoryServices.ActiveDirectory.ActiveDirectorySite]::GetComputerSite().Name 
                    }CATCH{$Site=$env:COMPUTERNAME} ;
                    $pltCcX10=[ordered]@{
                        siteName = $Site ;
                        RoleNames = @('HUB','CAS') ;
                        verbose  = $($rPSBoundParameters['Verbose'] -eq $true)
                        Credential = $pltRX10.Credential ; 
                    } ;
                    if($ExopVers){
                        $pltCcX10.add('Version',$ExopVers) ; 
                        write-verbose "(Adding specified -Version:$($ExopVers) to `$pltCcX10)"
                    } ; 
                    # 5:15 PM 4/22/2025 on CMW, have to patch version to Ex2016
                    #if($env:userdomain -eq 'CMW'){
                    if($TenOrg -eq 'CMW'){
                        if($pltCcX10.keys -contains 'Version'){
                            $pltCcX10.version = 'Ex2016' ; 
                        } else { $pltCcX10.add('version','Ex2016') } ;
                    } ; 
                    $smsg = "Connect-ExchangeServerTDO w`n$(($pltCcX10|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #$PSSession = Connect-ExchangeServerTDO -siteName $Site -RoleNames @('HUB','CAS') -verbose ; 
                    $PSSession = Connect-ExchangeServerTDO @pltCcX10 ; 
                } else {
                    if($pltRX10){
                        #ReConnect-Ex2010XO @pltRX10 ;
                        ReConnect-Ex2010 @pltRX10 ;
                    } else { Reconnect-Ex2010 ; } ;
                    #Add-PSSnapin -Name 'Microsoft.Exchange.Management.PowerShell.SnapIn'
                    #TK: add: test Exch & AD functional connections
                    TRY{
                        if(get-command -module (get-module |?{$_.name -like 'tmp_*'}).name -name 'get-OrganizationConfig'){} else {
                            $smsg = "(mangled Ex10 conn: dx10,rx10...)" ; 
                            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                            disconnect-ex2010 ; reconnect-ex2010 ; 
                        } ; 
                        if(-not ($OrgName = ((get-OrganizationConfig).DistinguishedName.split(',') |?{$_ -like 'DC=*'}) -join '.' -replace 'DC=','')){
                            $smsg = "Missing Exchange Connection! (no (Get-OrganizationConfig).name returned)" ; 
                            throw $smsg ; 
                            $smsg | write-warning  ; 
                        } ; 
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = $ErrTrapd ;
                        $smsg += "`n";
                        $smsg += $ErrTrapd.Exception.Message ;
                        if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        CONTINUE ;
                    } ;
                }
            } ; 
            if($useForestWide){
                #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT v------
                $smsg = "(`$useForestWide:$($useForestWide)):Enabling EXoP Forestwide)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $smsg = 'Set-AdServerSettings -ViewEntireForest `$True' ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Set-AdServerSettings -ViewEntireForest $True ;
                #endregion  ; #*------^ END OPTIONAL CODE TO ENABLE FOREST-WIDE NATIVE EXCHANGE SUPPORT ^------
            } ;
        } else {
            $smsg = "(`$useOP:$($UseOP))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        }  ;  # if-E $UseOP
        #endregion GENERIC_EXOP_CREDS_&_SRVR_CONN #*------^ END GENERIC EXOP CREDS & SRVR CONN BP ^------
    
        #region UseOPAD #*------v UseOPAD v------
        if($UseOP -OR $UseOPAD){
            if($isNonDomainServer){
                $smsg = "(non-Domain-connected server:Skipping GENERIC ADMS CONN) "  
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            }else {
                #region GENERIC_ADMS_CONN_&_XO #*------v GENERIC ADMS CONN & XO  v------
                $smsg = "(loading ADMS...)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                # always capture load-adms return, it outputs a $true to pipeline on success
                $ADMTLoaded = load-ADMS -Verbose:$FALSE ;
                # 9:32 AM 4/20/2023 trimmed disabled/fw-borked cross-org code
                TRY {
                    if(-not(Get-ADDomain  -ea STOP).DNSRoot){
                        $smsg = "Missing AD Connection! (no (Get-ADDomain).DNSRoot returned)" ; 
                        throw $smsg ; 
                        $smsg | write-warning  ; 
                    } ; 
                    $objforest = get-adforest -ea STOP ; 
                    # Default new UPNSuffix to the UPNSuffix that matches last 2 elements of the forestname.
                    $forestdom = $UPNSuffixDefault = $objforest.UPNSuffixes | ?{$_ -eq (($objforest.name.split('.'))[-2..-1] -join '.')} ; 
                    if($useForestWide){
                        #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE AD GC QRY SUPPORT v------
                        $smsg = "(`$useForestWide:$($useForestWide)):Enabling AD Forestwide)" ; 
                        if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $smsg = 'Set-AdServerSettings -ViewEntireForest `$True' ;
                        if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        #TK 9:44 AM 10/6/2022 need org wide for rolegrps in parent dom (only for onprem RBAC, not EXO)
                        $GcFwide = "$((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):3268" ;        
                        #endregion  ; #*------^ END  OPTIONAL CODE TO ENABLE FOREST-WIDE AD GC QRY SUPPORT  ^------
                    } ;    
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = $ErrTrapd ;
                    $smsg += "`n";
                    $smsg += $ErrTrapd.Exception.Message ;
                    if ($logging) { _write-log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    CONTINUE ;
                } ;        
                #endregion GENERIC_ADMS_CONN_&_XO #*------^ END GENERIC ADMS CONN & XO ^------
            } ; 
        } else {
            $smsg = "(`$UseOP:$($UseOP))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        }  ;
        #if (!$domaincontroller) { $domaincontroller = get-gcfast } ;
        #if(!$domaincontroller){ if(test-path function:get-gcfast){$domaincontroller = get-gcfast} else { throw "no get-gcfast()!" } ;} else {"(existing `$domaincontroller:$($domaincontroller))"} ;
        # use new get-GCFastXO cross-org dc finde
        # default to Op_ExADRoot forest from $TenOrg Meta
        #if($UseOP -AND -not $domaincontroller){
        if($UseOP -AND -not $isNonDomainServer -AND -not (get-variable domaincontroller -ea 0)){
            #$domaincontroller = get-GCFastXO -TenOrg $TenOrg -subdomain ((get-variable -name "$($TenOrg)Meta").value['OP_ExADRoot']) -verbose:$($verbose) |?{$_.length};
            # need to debug the above, credential issue?
            # just get it done
            $domaincontroller = get-GCFast
        }elseif($isNonDomainServer){
            $smsg = "(non-ADDomain-connected, skipping divert to EXO group resolution)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        }  else { 
            # have to defer to get-azuread, or use EXO's native cmds to poll grp members
            # TODO 1/15/2021
            $useEXOforGroups = $true ; 
            $smsg = "$($TenOrg):HAS NO ON-PREM ACTIVEDIRECTORY, DEFERRING ALL GROUP ACCESS & MGMT TO NATIVE EXO CMDS!" ; 
            if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
        if(-not $isNonDomainServer -AND $useForestWide -AND -not $GcFwide){
            #region  ; #*------v OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT: v------
            $smsg = "`$GcFwide = Get-ADDomainController -Discover -Service GlobalCatalog" ;
            if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $GcFwide = "$((Get-ADDomainController -Discover -Service GlobalCatalog).hostname):3268" ;
            $smsg = "Discovered `$GcFwide:$($GcFwide)" ; 
            if($silent){}elseif ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #endregion  ; #*------^ END OPTIONAL CODE TO ENABLE FOREST-WIDE ACTIVEDIRECTORY SUPPORT ^------
        } ;
        #endregion UseOPAD #*------^ END UseOPAD ^------

        #region MSOL_CONNECTION ; #*------v  MSOL CONNECTION v------
        #$UseMSOL = $false 
        if($UseMSOL){
            #$reqMods += "connect-msol".split(";") ;
            #if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
            $smsg = "(loading MSOL...)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #connect-msol ;
            connect-msol @pltRXOC ;
        } else {
            $smsg = "(`$UseMSOL:$($UseMSOL))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;
        #endregion MSOL_CONNECTION ; #*------^  MSOL CONNECTION ^------

        #region AZUREAD_CONNECTION ; #*------v AZUREAD CONNECTION v------
        #$UseAAD = $false 
        if($UseAAD){
            #$reqMods += "Connect-AAD".split(";") ;
            #if ( !(check-ReqMods $reqMods) ) { write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; Break ; }  ;
            $smsg = "(loading AAD...)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Connect-AAD @pltRXOC ;
        } else {
            $smsg = "(`$UseAAD:$($UseAAD))" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        } ;
        #endregion AZUREAD_CONNECTION ; #*------^ AZUREAD CONNECTION ^------

        <# defined above
        # EXO connection
        $pltRXO = @{
            Credential = (Get-Variable -name cred$($tenorg) ).value ;
            verbose = $($verbose) ; } ;
        #>
        <#
        if($VerbosePreference = "Continue"){
            $VerbosePrefPrior = $VerbosePreference ;
            $VerbosePreference = "SilentlyContinue" ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        disconnect-exo ;
        if ($script:useEXOv2) { reconnect-eXO2 @pltRXOC }
        else { reconnect-EXO @pltRXOC } ;
        # reenable VerbosePreference:Continue, if set, during mod loads
        if($VerbosePrefPrior -eq "Continue"){
            $VerbosePreference = $VerbosePrefPrior ;
            $verbose = ($VerbosePreference -eq "Continue") ;
        } ;
        #>
        #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        #endregion SERVICE_CONNECTIONS #*======^ END SERVICE_CONNECTIONS ^======

        $eventIDLookupTbl = Initialize-xopEventIDTable ; 

        # SET DAYS=0 IF USING START/END (they only get used when days is non-0); $platIn.TAG is appended to ticketNO for output vari $vn, and $ofile
        if($Days -AND ($Start -OR $End)){
            write-warning "specified -Days with (-Start -OR -End); If using Start/End, specify -Days 0!" ; 
            Break ; 
        } ; 
        if($Start){[datetime]$Start = $Start } ; 
        if($End){[datetime]$End = $End} ; 
        if($Resultsize -eq 'unlimited' -OR $ResultSize -is [int]){}
        elseif( ($null -eq $ResultSize) -OR ('' -eq $ResultSize) ){
            $ResultSize = 'unlimited' ; 
        } else { 
            throw "Resultsize must be an integer or the string 'unlimited' (or blank)" ; 
        } ;
        $pltParams=@{
            ticket=$ticket ;
            Requestor=$Requestor;
            days=$days ;
            Start=$Start ;
            End= $End ;
            Sender=$Sender ;
            Recipients=$Recipients ;
            MessageSubject=$MessageSubject ;
            EventID=$EventID ;
            MessageID=$MessageID;
            InternalMessageId=$InternalMessageId;
            NetworkMessageId=$NetworkMessageId;
            Reference=$Reference ; 
            ResultSize=$ResultSize ;
            Source=$Source ;
            Tag=$Tag ;
            ErrorAction = 'STOP' ;
            verbose = $($VerbosePreference -eq "Continue") ;
        } ; 

        #-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        # Configure the Get-xoMessageTrace splat 
        # w Ex2010 in the mix, and Ps2, [ordered] hashes won't work, config for:
        if($host.version.major -ge 3){$pltGMTL=[ordered]@{Dummy = $null ;} }
        #else {$pltGMTL = New-Object Collections.Specialized.OrderedDictionary} ;
        else{$pltGMTL=@{Dummy = $null ;} }
        If($pltGMTL.Contains("Dummy")){$pltGMTL.remove("Dummy")} ;
        $pltGMTL.add('ErrorAction',"STOP") ; 
        $pltGMTL.add('verbose',$($VerbosePreference -eq "Continue")) ; 

        <#$pltGMTL=[ordered]@{
            #SenderAddress=$SenderAddress;
            #RecipientAddress=$RecipientAddress;
            #Start=(get-date $Start);
            #Start= $Start;
            #End=(get-date $End);
            #End=$End;
            #Page= 1 ; # default it to 1 vs $null as we'll be purging empties further down
            ErrorAction = 'STOP' ;
            verbose = $($VerbosePreference -eq "Continue") ;
        } ;
        #>

        if ($PSCmdlet.ParameterSetName -eq 'Dates') {
            if($End -and -not $Start){
                $Start = (get-date $End).addDays(-1 * $DaysLimit) ; 
            } ; 
            if($Start -and -not ($End)){
                $smsg = "(Start w *NO* End, asserting currenttime)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
                else{ write-host -foregroundcolor YELLOW "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $End=(get-date) ;
            } ;
        } else {
            if (-not $Days) {
                $Start = (get-date $End).addDays(-1 * $DaysLimit) ; 
                $smsg = "No Days, Start or End specified. Defaulting to $($DaysLimit)day Search window:$((get-date).adddays(-1 * $DaysLimit))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $End = (get-date) ;
                $Start = (get-date $End).addDays(-1 * $Days) ; 
                $smsg = "-Days:$($Days) specified: "
                #$smsg += "calculated Start:$((get-date $Start -format $sFulltimeStamp ))" ; 
                #$smsg += ", calculated End:$((get-date $End -format $sFulltimeStamp ))" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #(get-date -format $sFiletimestamp);
            } ; 
        } ;

        $smsg = "(converting `$Start & `$End to UTC, using input as `$StartLocal & `$EndLocal)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        TRY {
            $OrgName = (Get-OrganizationConfig -ea STOP).name ; 
            if($OrgName -eq 'First Organization'){
                if($TenOrg -AND $IsEdgeTransport){
                    $OrgTag = "$($TenOrg)edge" ; 
                } else {
                    $OrgTag = ($orgname  -replace '[^\w]','') ; 
                } ; 
            }elseif(($orgname.ToCharArray() | ?{$_ -cmatch '[A-Z]'}).count -gt 1){
                $OrgTag = ($orgname.ToCharArray() | ?{$_ -cmatch '[A-Z]'}) -join '' ; #Acroynymize the OrgName on caps
            } else { 
                $OrgTag = $orgname  -replace '[^\w]','' ; # use orgname with non-\W chars replaced
            } ; 
            # convert dates to GMT .ToUniversalTime(
            $Start = ([datetime]$Start).ToUniversalTime() ; 
            $End = ([datetime]$End).ToUniversalTime() ; 
            $StartLocal = ([datetime]$Start).ToLocalTime() ; 
            $EndLocal = ([datetime]$End).ToLocalTime() ; 
        
            # sanity test the start/end dates, just in case (won't throw an error in gxmt)
            if($Start -gt $End){
                $smsg = "`-Start:$($Start) is GREATER THAN -End:($End)!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                throw $smsg ; 
                break ; 
            } ;

            $smsg = "`$Start:$(get-date -Date $StartLocal -format $sFulltimeStamp )" ;
            $smsg += "`n`$End:$(get-date -Date $EndLocal -format $sFulltimeStamp )" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            if((New-TimeSpan -Start $Start -End $End).days -gt $DaysLimit){
                $smsg = "Search span (between -Start & -End, or- Days in use) *exceeds* MS supported days history limit!`nReduce the window below a historical 10d, or use get-HistoricalSearch instead!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                Break ; 
            } ; 

            if($Sender){
                if($Sender -match $rgxIsPlusAddrSmtpAddr){
                    $smsg = "WARNING! Sender $($Sender) HAS PLUS-ADDRESSING, WON'T WORK FOR EXOP RECIPIENTS!"
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                } ; 
                $pltGMTL.add("Sender",$Sender) ;
                <# 2;18 pm 4/28/2025 drop the testing, the param is [string], let an err occur if a bad sender comes in
                if( ($Sender -split ' *, *') -is [array]){
                    # get-messagetrackinglog  -Sender is a [string] (not [string[]])!
                    $smsg = "-Sender specified - $($Sender) - resolves to an ARRAY, not a supported single-address string!" ; 
                    $smsg += "`nmultipole Senders are _not_ supported for get-messagetrackinglog!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    throw $smsg ; 
                    BREAK ; 
                }else {
                    #$pltGMTL.add('Sender',($Sender -split ' *, *')) ;
                    $pltGMTL.add('Sender',($Sender| out-string)) ; 
                    # this is resulting in an elipses trailing the sender, clearly borked.
                    #$ofile+=",From-$($pltGMTL.Sender.replace("*","ANY"))"  ; 
                } ; 
                #>
            } ;
            if($Recipients){
                #$pltGMTL.add("Recipients",$Recipients) ;
                if($Recipients -match $rgxIsPlusAddrSmtpAddr){write-warning "WARNING! RecipientS $($Recipients) HAS PLUS-ADDRESSING, WON'T WORK FOR EXOP!"} ; 
                #$ofile+=",To-$($Recipients)" ;
                $pltGMTL.add('Recipients',($Recipients -split ' *, *')) ;
                #$ofile+=",To-$($pltGMTL.RecipientAddress.replace("*","ANY"))" ;
            } ;
            if($Start){
                $pltGMTL.add('Start',$Start) ; 
                #$ofile+= "-$(get-date $pltGMTL.Start -format $sFiletimestamp)-"  ;
            } ;
            if($End){
                $pltGMTL.add('End',$End) ; 
                #$ofile+= "$(get-date $pltGMTL.End -format $sFiletimestamp)" ;
            } ;
            if($MessageSubject){
                #$ofile+=",Subj-$($MessageSubject.substring(0,[System.Math]::Min(15,$MessageSubject.Length)))..." 
            } ;
            if($EventID){
                $pltGMTL.add('EventID',($EventID -split ' *, *')) ; 
                #$ofile+= "-Evt-$($EventID -join ',')" ;
            } ;
            if($MessageId){
                $pltGMTL.add('MessageId',($MessageId -split ' *, *')) ; 
                #$ofile+=",MsgId-$($pltGMTL.MessageId.replace('<','').replace('>',''))" ;
            } ;
            if($InternalMessageId){
                $pltGMTL.add("InternalMessageId",$InternalMessageId)  ;
                #$ofile+=",MsgID-$($InternalMessageId.replace('<','').replace('>','').substring(0,10))" ;
            } ;
            if($NetworkMessageId){
                $pltGMTL.add("NetworkMessageId",$NetworkMessageId)  ;
                #$ofile+=",MsgID-$($NetworkMessageId.replace('<','').replace('>','').substring(0,10))" ;
            } ;
             # Reference
            if($Reference){     $pltGMTL.add("Reference",$Reference)  ;
                #$ofile+=",Ref-$($Reference.replace('<','').replace('>','').substring(0,10))" ;
            } ;
            if($TransportTrafficType){     $pltGMTL.add("TransportTrafficType",$TransportTrafficType)  ;
                #$ofile+=",TTT-$(Remove-IllegalFileNameChars -Name $TransportTrafficType )" ;
            } ;
            if($Source){     $pltGMTL.add("Source",$Source)  ;
                #$ofile+=",Source-$($Source )" ;
            } ;
            if($Server){
                $pltGMTL.Server = $Server  ;
                if($Server -ne 'unlimited'){
                    #$ofile+="-$($Server)" ;
                } ; 
            } ;
            if($ResultSize){
                $pltGMTL.ResultSize = $ResultSize  ;
                if($ResultSize -ne 'unlimited'){
                    #$ofile+=",RSize-$($ResultSize)" ;
                } ; 
            } ;


            #region MSGTRKFILENAME ; #*------v MSGTRKFILENAME v------
            $LogPath = split-path $logfile ; 
            $smsg = "Writing export files to discovered `$LogPath: $($LogPath)" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            if (-not (test-path $LogPath )){mkdir $LogPath -verbose  }
            [string[]]$ofile=@() ; 
            write-verbose "Add comma-delimited elements" ; 
            #$ofile+=if($ticket -AND $Tag){@($ticket,$tag) -join '_'}else{$ticket} ;
            $ofile+= (@($ticket,$tag) | ?{$_}) -join '_' ; 
            $ofile+= (@($Ten,$Requestor,'XOPMsgTrk') | ?{$_} ) -join '-' ;
            $ofile+=if($Sender){
                "FROM_$((($Sender | select -first 2) -join ',').replace('*','ANY'))"
            }else{''} ;
            $ofile+=if($Recipients){
                "TO_$(( ($Recipients| select -first 2) -join ',').replace('*','ANY'))"
            }else{''} ;
            $ofile+=if($MessageId){
                if($MessageId -is [array]){
                    "MSGID_$($MessageId[0] -replace '[\<\>]','')..."
                } else { 
                    "MSGID_$($MessageId -replace '[\<\>]','')"                
                } ; 
            }else{''} ;
            $ofile+=if($MessageSubject){"SUBJ_$($MessageSubject.substring(0,[System.Math]::Min(10,$MessageSubject.Length)))..."}else{''} ;
            $ofile+=if($EventID){
                "EVT_$($EventID -join ',')"
            }else{''} ;
            $ofile+=if($OrgTag){
                "O_$($OrgTag)"
            }else{''} ;
            write-verbose "comma join the non-empty elements" ; 
            [string[]]$ofile=($ofile |  ?{$_} ) -join ',' ; 
            write-verbose "add the dash-delimited elements" ; 
            $ofile+=if($days){"$($days)d"}else{''} ;
            $ofile+=if($Start){"$(get-date $Start -format 'yyyyMMdd-HHmm')"}else{''} ;
            $ofile+=if($End){$ofile+= "$(get-date $End -format 'yyyyMMdd-HHmm')"}else{''} ;
            $ofile+=if($MessageSubject){"Subj_$($MessageSubject.replace("*"," ").replace("\"," "))"}else{''} ;
            $ofile+="run$(get-date -format 'yyyyMMdd-HHmm').csv" ;
            write-verbose "dash-join non-empty elems" ; 
            [string]$ofile=($ofile |  ?{$_} ) -join '-' ; 
            write-verbose "replace filesys illegal chars" ; 
            [string]$ofile=[RegEx]::Replace($ofile, "[{0}]" -f ([RegEx]::Escape(-join [System.IO.Path]::GetInvalidFileNameChars())), '') ;
            if($LogPath){
                write-verbose "add configured `LogPath" ; 
                $ofile = join-path $LogPath $ofile ; 
            } else { 
                write-verbose "add relative path" ; 
                $ofile=".\logs\$($ofile)" ;
            } ; 

            $hReports = [ordered]@{} ; 
            #rx10 ;
            $error.clear() ;

            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Running Get-MessageTrackingLog w`n$(($pltGMTL|out-string).trim())" ; 
            $Srvrs=Get-ExchangeServer -ea STOP ;
            if($Srvrs.name -contains $Site){
                write-verbose "Edge Role detected" ;
                $Srvrs=$Srvrs | where {$_.name -eq $Site -AND $_.IsEdgeServer} | select -expand Name ;
            }else{$Srvrs=($Srvrs | where { $_.isHubTransportServer -eq $true -and $_.Site -match ".*\/$($Site)$"} | select -expand Name)} ;

            #if($tag){$vn =  Remove-InvalidVariableNameChars -name "msgsOP$($ticket)_$($tag)"} else {$vn =  Remove-InvalidVariableNameChars -name "msgsOP$($ticket)" } ;
            #write-host "`$vn: $($vn)" ;
            #write-host -fore gray "collecting to variable: `$$($vn)" ;
            #if(gv $vn -ea 0){sv -name $vn -value $null } else {nv -name $vn -value $null } ;

            if($Server){
                $Msgs=($Server| get-messagetrackinglog @pltGMTL) | sort Timestamp ;
            } else { 
                $Msgs=($Srvrs| get-messagetrackinglog @pltGMTL) | sort Timestamp ;
            } ; 
            $smsg = "Raw matches:$(($msgs|measure).Count) events" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            if($Connectorid){
                write-host -foregroundcolor gray   "Filtering on Conn:$($Connectorid)" ;
                $Msgs = $Msgs | ?{$_.connectorid -like $Connectorid} ;
                $ofile+="-conn-$($Connectorid.replace("*"," ").replace("\"," "))" ;
                write-host -foregroundcolor gray   "Post Conn filter matches:$(($Msgs|measure).Count)" ;
            } ;
            if($Source){
                write-host -foregroundcolor gray   "Filtering on Source:$($Source)" ;
                $Msgs = $Msgs | ?{$_.Source -like $Source} ;
                write-host -foregroundcolor gray   "Post Src filter matches:$(($Msgs|measure).Count)" ;
                $ofile+="-src-$($Source)" ;
            } ;

            if($MessageSubject){
                $smsg = "Post-Filtering on MessageSubject:$($MessageSubject)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                # detect whether to filter on -match (regex) or -like (asterisk, or default non-regex)
                if(test-IsRegexPattern -string $MessageSubject -verbose:$($VerbosePreference -eq "Continue")){
                    $smsg = "(detected -MessageSubject as regex - using -match comparison)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $MsgsFltrd = $Msgs | ?{$_.MessageSubject -match $MessageSubject} ;
                    if(-not $MsgsFltrd){
                        $smsg = "MessageSubject: regex -match comparison *FAILED* to return matches`nretrying MessageSubject filter as -Like..." ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $MsgsFltrd = $Msgs | ?{$_.MessageSubject -like $MessageSubject} ;
                    } ; 
                } else { 
                    $smsg = "(detected -MessageSubject as NON-regex - using -like comparison)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $MsgsFltrd = $Msgs | ?{$_.MessageSubject -like $MessageSubject} ;
                    if(-not $MsgsFltrd){
                        $smsg = "MessageSubject: -like comparison *FAILED* to return matches`nretrying MessageSubject filter as -match..." ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $MsgsFltrd = $Msgs | ?{$_.MessageSubject -match $MessageSubject} 
                    } ; 
                } ; 
                $smsg = "Post Subj filter matches:$(($MsgsFltrd|measure).Count)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                $msgs = $MsgsFltrd ; 
            } ;

        
            #if(get-variable -name $vn -scope global -ea 0){remove-variable -name $vn -scope global -force -ea 0} ; 
            #set-variable -name $vn -Value ($Msgs) -scope global ;
        
            if($Msgs){
                if($DoExports){
                    $smsg = "($(($Msgs|measure).count) events | export-csv $($ofile))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    TRY{
                        $Msgs | SELECT $prpXCsv | EXPORT-CSV -notype -path $ofile ;
                        $smsg = "export-csv'd to:`n$((resolve-path $ofile).path)" ; 
                    } CATCH {
                        $ErrTrapd=$Error[0] ;
                        $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $smsg = "(adding `$hReports.MTMessages)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    
                    # add the csvfilename
                    $smsg = "(adding `$hReports.MTMessagesCSVFile:$($ofile))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $hReports.add('MTMessagesCSVFile',$ofile) ; 
                } ; 

                $hReports.add('MTMessages',$msgs) ; 

                $smsg = "`n`n#*------v EventID DISTRIB v------`n`n" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                if($Msgs){
                    $hReports.add('EventIDHisto',($Msgs | select -expand EventID | group | sort count,count -desc | select count,name)) ;

                    #$smsg = "$(($Msgs | select -expand EventID | group | sort count,count -desc | select count,name|out-string).trim())" ;
                    $smsg = "`n$(($hReports.EventIDHisto|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $smsg = "`n`n#*------^ EventID DISTRIB ^------`n`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    # $hReports.add('EventIDHisto'
                    $smsg = "`n`n## EventID Definitions:" ; 
                    $hReports.EventIDHisto | select -expand Name | foreach-object{                   
                        $smsg += "`n$(($eventIDLookupTbl[$_] | ft -HideTableHeaders |out-string).trim())" ; 
                    } ; 
                    $smsg += "`n`n"
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success


                    $smsg = "`n`n#*------v MOST RECENT MATCH v------`n`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                    $hReports.add('MsgLast',($msgs[-1]| fl $prpMTLfta)) ;
            
                    $smsg = "`n$(($hReports.MsgLast |out-string).trim())";
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $smsg = "`n`n#*------^ MOST RECENT MATCH ^------`n`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor white "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                } ; 


                <#---
                write-host -foregroundcolor gray   "`n#*------v MOST RECENT MATCH v------" ;
                write-host "$(($msgs[-1]| format-list $prpMTLfta|out-string).trim())";
                write-host -foregroundcolor gray   "`n#*------^ MOST RECENT MATCH ^------`n" ;
                write-host -foregroundcolor gray   "`n#*------v EventID DISTRIB v------" ;
                write-host -foregroundcolor yellow "$(($Msgs | group EventID | sort count -desc | ft -a count,name |out-string).trim())";
                write-host -foregroundcolor gray   "`n#*------^ EventID DISTRIB ^------" ;
                #---
                #>

                if($mFails = $msgs | ?{$_.EventID -eq 'FAIL'}){
                    $hReports.add('MsgsFail',$mFails) ; 
                    $ofileF = $ofile.replace('-XOPMsgTrk,','FAILMsgs,') ;
                    if($DoExports){
                        TRY{
                            $mFails | export-csv -notype -path $ofileF -ea STOP ;
                            $smsg = "export-csv'd to:`n$((resolve-path $ofileF).path)" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        } CATCH {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ; 
                    } ; 
                    if($mOOO = $mFails | ?{$_.Subject -match '^Automatic\sreply:\s'} ){
                        $smsg = $sBnr3="`n#*~~~~~~v EventID FAIL: Expected Policy Blocked External OutOfOffice (up to last $($DetailLimit))v~~~~~~" ;
                        $smsg += "`n$($mOOO| measure | select -expand count) msgs:Expected Out-of-Office Policy:(attempt to send externally)`n$(($mOOO | select -last $DetailLimit | ft -a $prpGXMTfta |out-string).trim())" ;
                        $smsg += "`n$($sBnr3.replace('~v','~^').replace('v~','^~'))`n"  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ;
                    if($mRecl = $mFails | ?{$_.Subject -match '^Recall:\s'}){
                        $smsg = $sBnr3="`n#*~~~~~~v EventID FAIL: Expected: Recalled message (up to last $($DetailLimit)) v~~~~~~" ;
                        $smsg += "`n$($mRecl| measure | select -expand count) msgs:Expected Sender Recalled Message `n$(($mRecl| select -last $DetailLimit| ft -a $prpGXMTfta |out-string).trim())" ;
                        $smsg += "`n$($sBnr3.replace('~v','~^').replace('v~','^~'))`n"  ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    } ;

                    # reclass everything *not* one of the above as $mfails:
                    if($mFails = $mFails | ?{$_.Subject -notmatch '^Recall:\s' -AND $_.Subject -notmatch '^Automatic\sreply:\s'}){
                        <#$smsg = $sBnr3="`n#*~~~~~~v EventID FAIL: Other Failure message (up to last $($DetailLimit)) v~~~~~~" ;
                        $smsg += "`n$(($mFails| select -last $DetailLimit | ft -a |out-string).trim())" ;
                        $smsg += "`n$($sBnr3.replace('~v','~^').replace('v~','^~'))`n"  ;
                        write-host -foregroundcolor yellow $smsg ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        #>
                        if($mFailAddr = $mFails | ?{$_.EventID -eq 'FAIL' -AND $_.Source -eq 'ROUTING'}){
                            $smsg = $sBnr3="`n#*~~~~~~v EventID FAIL: BAD ADDRESS FAILS: (EventID:'FAIL' & Source:'ROUTING') ($(($mFailAddr|measure).count)msgs, echo up to last $($DetailLimit))) v~~~~~~" ;
                            $smsg += "`n$(($mFailAddr| select -last $DetailLimit | ft -a |out-string).trim())" ;
                            $smsg += "`n$($sBnr3.replace('~v','~^').replace('v~','^~'))`n"  ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        } ;
                        if($mFailRej = $mFails | ?{$_.EventID -eq 'FAIL' -AND $_.Source -eq 'SMTP'}){
                            $smsg = $sBnr3="`n#*~~~~~~v EventID FAIL: REJECTED BY RECIPIENT SERVER : (EventID:'FAIL' & Source:'SMTP') ($(($mFailRej|measure).count)msgs, echo up to last $($DetailLimit)) v~~~~~~" ;
                            $smsg += "`n$(($mFailRej| select -last $DetailLimit | ft -a |out-string).trim())" ;
                            $smsg += "`n$($sBnr3.replace('~v','~^').replace('v~','^~'))`n"  ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        } ;
                        if($mFailDom = $mFails | ?{$_.EventID -eq 'FAIL' -AND $_.Source -eq 'DNS'}){
                            $smsg = $sBnr3="`n#*~~~~~~v EventID FAIL: BAD DOMAIN : (EventID:'FAIL' & Source:'DNS') ($(($mFailDom|measure).count)msgs, echo up to last $($DetailLimit)) v~~~~~~" ;
                            $smsg += "`n$(($mFailDom| select -last $DetailLimit | ft -a |out-string).trim())" ;
                            $smsg += "`n$($sBnr3.replace('~v','~^').replace('v~','^~'))`n"  ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        } ;
                        # anything *not* filtered above
                        if($mFailsOther = $mFails | 
                            ?{$_.Subject -notmatch '^Recall:\s' -AND $_.Subject -notmatch '^Automatic\sreply:\s' -AND -not(
                                $_.EventID -eq 'FAIL' -AND $_.Source -eq 'ROUTING') -AND -NOT($_.EventID -eq 'FAIL' -AND $_.Source -eq 'SMTP') -AND -NOT(
                                $_.EventID -eq 'FAIL' -AND $_.Source -eq 'DNS') }){
                            $smsg = $sBnr3="`n#*~~~~~~v EventID FAIL: OTHER:) ($(($mFailsOther|measure).count)msgs, echo up to last $($DetailLimit)) v~~~~~~" ;
                            $smsg += "`n$(($mFailsOther| select -last $DetailLimit | ft -a |out-string).trim())" ;
                            $smsg += "`n$($sBnr3.replace('~v','~^').replace('v~','^~'))`n"  ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor blue "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        } ;

                    } else {
                        $smsg = "(no non-RECALL,non-OOO block, FAILs logged)" 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;


                } ;

                if($mDefers = $msgs|?{$_.EventID -eq 'DEFER'}){
                    $smsg = "`n`n#*------v DEFER's Distribution v------`n`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

                
                    $hReports.add('MsgsDefer',$mDefers) ;

                    $smsg = "`n$(($mDefers | select -expand RecipientStatus | group | sort count -desc | ft -auto count,name|out-string).trim())";
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    $smsg = "`n`n#*------^ DEFER's Distribution ^------`n`n" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    # defers are infra issue, not recipient/resolution, no sense dumping details, other than to let user know which delayed

                    $smsg = $sBnrS="`n#*------v DEFER's RETRY handling (up to last $($DetailLimit) messages) v------" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H2 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                    # hash index the main msg list: (post filtering lags)
                    $swSEND = [Diagnostics.Stopwatch]::StartNew();
                    $mSends = $msgs|?{$_.EventID -eq 'SEND'}
                    $ndxMsgsSEND = @{} ;
                    $mSends | foreach-object{
                        $ndxMsgsSEND[$_.MessageId] = $_ ; 
                    } ; 
                    remove-variable mSends -force 
                    if($host.version.major -ge 3){
                        $smsg =  ("$($smsg) {0:dd}d {0:hh}h {0:mm}m {0:ss}s {0:fff}ms" -f $swSEND.Elapsed) ; #outputs: Elapsed Time: 0d 0h 0m 10s 101ms
                    } else {
                        $smsg = "$($smsg) $($swSEND.Elapsed.ToString()))" ; # outputs: Elapsed Time: (HH:MM:SS.ms) 00:00:15.8418655
                    } ;
                    if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                    #

                    $midn = 20 ; $namn = 15 ; 
                    $dmprcd = 0 ; 
                    foreach($dmsg in ($mDefers | select -last $DetailLimit)){
                        $dmprcd++ ; 
                        #$smsg ="`n#*~~~~~~v " ; 
                        $smsg = "#$($dmprcd) " ; 
                        $smsg += "MsgID:$(($dmsg.MessageId -replace '[\<\>]','').substring(0,[System.Math]::Min(($dmsg.MessageId -replace '[\<\>]','').length,((($dmsg.MessageId -replace '[\<\>]','').ToCharArray() | select -first $midn) -join '').length)))..." ; 
                        $smsg += " Fr:$($dmsg.Sender.substring(0,[System.Math]::Min($dmsg.Sender.length,(($dmsg.Sender.ToCharArray() | select -first $namn) -join '').length)))..." ; 
                        #$smsg += " To:$($dmsg.Recipients.substring(0,[System.Math]::Min($dmsg.Recipients.length,(($dmsg.Recipients.ToCharArray() | select -first $namn) -join '').length)))..." ; 
                        #$smsg += " To:$( ($dmsg.Recipients -join ',').substring(0,[System.Math]::Min(($dmsg.Recipients -join ',').length,((($dmsg.Recipients -join ',').ToCharArray() | select -first $namn) -join '').length)))..." ; 
                        $sRcp = $dmsg.Recipients -join ',' ; 
                        $smsg += " To:$( $sRcp.substring(0,[System.Math]::Min($sRcp.length,(($sRcp.ToCharArray() | select -first $namn) -join '').length)))..." ; 
                        $smsg += " Sub:$($dmsg.MessageSubject.substring(0,[System.Math]::Min($dmsg.MessageSubject.length,(($dmsg.MessageSubject.ToCharArray() | select -first $namn) -join '').length)))..." ;         
                        #$smsg += " v~~~~~~" ; 
                        #$sBnr3 = $smsg ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;   
        
                        #$handling = $msgs |?{$_.messageid -eq $dmsg.MessageId -AND $_.eventid -match 'DEFER|SEND'} | sort TimestampLocal ;
                        # use $ndxMsgsSEND, postfilter too slow, aah, but msgid is repeated across evts pftftf
                        if($confirmedSEND = $ndxMsgsSEND[$dmsg.MessageId]){
                            $aHndl = @() ; 
                            $aHndl += @('DEFER') ; 
                            #$aHndl += @($handling[0].Timestamp) ; 
                            $aHndl += @($dmsg.Timestamp) ; 
                            $aHndl += @('SEND') ; 
                            #$aHndl += @($handling[1].Timestamp) ; 
                            $aHndl += @($confirmedSEND.Timestamp) ; 
                    

                            $aHndl += @('Retried Sent') ; 
                            #$aHndl += @("{0:dd}d:{0:hh}h:{0:mm}m:{0:ss}s:{0:fff}ms" -f (new-timespan -start $handling[0].Timestamp -end $handling[-1].Timestamp)) ; 
                            $aHndl += @("{0:dd}d:{0:hh}h:{0:mm}m:{0:ss}s:{0:fff}ms" -f (new-timespan -start $dmsg.Timestamp -end $confirmedSEND.Timestamp)) ; 
                            $smsg = "=>$($ahndl -join ' : ')`n`n" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level SUCCESS } else{ write-host -foregroundcolor green $smsg } ;                         

                        } else {
                            $smsg = "UNABLE TO LOCATE A SUCCESFUL SEND eventID for:" ; 
                            $smsg += "`n$(($dmsg | fl |out-string).trim())" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        }


                        #$smsg = "$($sBnr3.replace('~v','~^').replace('v~','^~'))`n" ;
                        #if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H3 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;   
                    } ; 
    
                    $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H2 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                } else {
                    $smsg = "(no DEFERs logged)" 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;

                $msgs = $null ;
                if(test-path -path $ofile){  
                    write-host -foregroundcolor green  "(log file confirmed)" ;
                    #Resolve-Path -Path $ofile | select -expand Path | out-clipboard ;
                    $smsg = "`n(Tracked output file confirmed)" ;
                    write-host -fore green $smsg ;
                } else { write-warning "MISSING LOG FILE!" } ;
            } else {
                $smsg = "NO MATCHES FOUND From Qry:" ; 
                $smsg += "`n$(($pltGMTL|out-string).trim())" ; 
                write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
            } ;
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "$('*'*5)`nFailed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: `n$(($ErrTrapd|out-string).trim())`n$('-'*5)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #-=-record a STATUSWARN=-=-=-=-=-=-=
            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
            #-=-=-=-=-=-=-=-=
            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
        } ; 

        write-verbose "#*------^ END Function SUB MAIN ^------" ;
    } ;  # BEG-E
    END {
        if($SimpleTrack -AND ($hReports.Keys.Count -gt 0)){
            $smsg = "-SimpleTrack specified: Only returning net message tracking set to pipeline" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            $msgs | write-output ; 
        } else { 
            $smsg = "(no -SimpleTrack: returning full summary object to pipeline)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            if($hReports.Keys.Count -gt 0){
                # convert the hashtable to object for output to pipeline
                #$Rpt += New-Object PSObject -Property $hReports ;
                $smsg = "(Returning summary object to pipeline)" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                
                TRY{
                    New-Object -TypeName PsObject -Property $hReports | write-output ; 
                    # export the entire return object into xml
                    $smsg = "(exporting `$hReports summary object to xml:$($ofile.replace('.csv','.xml')))" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    New-Object -TypeName PsObject -Property $hReports | export-clixml -path $ofile.replace('.csv','.xml') -ea STOP -verbose
                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ; 

            } else { 
                $smsg = "Unpopulated `$hReports, skipping output to pipeline" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARNING } 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                $false | write-output ; 
            } ;  
        } ; 
    } ; 
}

#*------^ Get-MessageTrackingLogTDO.ps1 ^------


#*------v get-UserMailADSummary.ps1 v------
function get-UserMailADSummary {
    <#
    .SYNOPSIS
    get-UserMailADSummary.ps1 - Resolve specified array of -users (displayname, emailaddress, samaccountname) to mail asset and AD details
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-07-30
    FileName    : get-UserMailADSummary.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Powershell,Exchange,ExchangeOnline,ActiveDirectory
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 2:16 PM 6/24/2024: rem'd out #Requires -RunasAdministrator; sec chgs in last x mos wrecked RAA detection
    * 3:27 PM 3/8/2022 CBH update, pointed link at verb-ex2010 module repo
    * 10:57 AM 8/2/2021 add 'Unresolved' (failed to return an object from 
    get-recipient, normally a 'System.Management.Automation.RemoteException', 
    Exception -match "couldn't\sbe\sfound\son") & 'Failed' (catch failure that 
    doesn't match the prior) properties, stuffing in the input designators as a raw 
    array (indicates cloud objects hybrid sync'd to another external directory) 
    * 12:07 PM 7/30/2021 added CustAttribs to the props dumped ; pulled 'verb-Ex2010' from #requires (nesting limit) ; init
    .DESCRIPTION
    get-UserMailADSummary.ps1 - Resolve specified array of -users (displayname, emailaddress, samaccountname) to mail asset and AD details
    The specific goal of this function is to assist in differentiated 'Active' user mailboxes from termainted/disabled/offboarded user mailboxes (or (Shared|Room|Equpment)mailboxes with disabled ADUser accounts.
    
    Fed an array of mailbox descriptors - emailaddress/UPN, alias, displayname, etc) - the function attempts to resolve a local recipient object, and a matching local ADUser object. 

    The ADUser is evaluated for .enabled status, and the distinguishedName is checked to locate 'non-Active/Term' users (by OU name in their DN). 
    
    The resulting lookups are categorized into four properties of the returned SystemObject:
    - Enabled - resolved local recipient & local ADUser. ADUser.Enabled=$true, ADUser.distinguishedName does not include a 'Disabled*' or 'Termed*' OU in it's tree.
    - Disabled - resolved local recipient, & local ADUser. ADUser.Enabled=$false and/or ADUser.distinguishedName includes a 'Disabled*' or 'Termed*' OU in it's tree.
    - UnResolved - get-recipient failed to return a local recipient matching the specified mailbox designator (most frequently reflects EXO cloud mailboxes that are hybrid-federated out of an other external AD as Source-Of-Authority.
    - Failed - any get-recipient try/catch fail that doesn't appear to be Exception.Type 'System.Management.Automation.RemoteException', Exception match "couldn't\sbe\sfound\son"

    The resulting SystemObject from the above is returned to the pipeline.
    .PARAMETER  users
    Array of user descriptors: displayname, emailaddress, UPN, samaccountname (checks clipboard where unspecified)
    .PARAMETER ADDisabledOnly
    Switch to exclude users solely on ADUser.disabled (not Disabled OU presense), or with that have the ADUser below an OU matching '*OU=(Disabled|TERMedUsers)'  [-ADDisabledOnly]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    Returns a System.Object[] object to pipeline, with subsets of processed users as 'Enabled' (ADUser.enabled),'Disabled', and 'Contacts' properties. 
    .EXAMPLE
    PS> $rpt = get-UserMailADSummary -users 'username1','user2@domain.com','[distinguishedname]' ;
    PS> $rpt | export-csv -nottype ".\pathto\usersummaries-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
    Processes local/remotemailbox & ADUser details on three specified users (alias,email address, DN). Summaries are returned to pipeline, and assigned to the $rpt variable, which is then exported to csv.
    .EXAMPLE
    PS> $rpt = get-UserMailADSummary -users 'username1','user2@domain.com','[distinguishedname]' -ADDisabledOnly ;
    PS> $rpt | export-csv -nottype ".\pathto\usersummaries-ENABLEDUSERS-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ; 
    Processes local/remotemailbox & ADUser details on three specified users (alias,email address, DN). 
    And allocate as 'Disabled', accounts that are *solely* ADUser.disabled 
    (e.g. considers users below OU's with names like 'OU=Disabled*' as 'Enabled' users), 
    and then exports to csv. 
    .EXAMPLE
    $rpt = get-UserMailADSummary -users 'username1','user2@domain.com','[distinguishedname]' ;
    $rpt.enabled | export-csv -nottype ".\pathto\usersummaries-ENABLEDUSERS-$(get-date -format 'yyyyMMdd-HHmmtt').csv" ;
    Process specified identifiers, and export solely the 'Enabled' users returned to csv. 
    .LINK
    https://github.com/tostka/verb-ex2010
    .LINK
    #>
    ###Requires -Version 5
    #Requires -Modules ActiveDirectory, MSOnline, AzureAD, ExchangeOnlineManagement, verb-AAD, verb-ADMS
    ##Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    ##[Alias('ulu')]
    PARAM(
        [Parameter(Position=0,Mandatory=$False,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Array of user descriptors: displayname, emailaddress, UPN, samaccountname (checks clipboard where unspecified)")]
        #[ValidateNotNullOrEmpty()]
        #[Alias('ALIAS1', 'ALIAS2')]
        [array]$users,
        [Parameter(HelpMessage="Switch to exclude users solely on ADUser.disabled (not Disabled OU presense), or with that have the ADUser below an OU matching '*OU=(Disabled|TERMedUsers)'[-ADDisabledOnly]")]
        [switch] $ADDisabledOnly,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2
    ) ;
    BEGIN{
        $Verbose = ($VerbosePreference -eq 'Continue') ; 

        $rgxDisabledOUs = '.*OU=(Disabled|TERMedUsers).*' ; 
        if(!$users){
            $users= (get-clipboard).trim().replace("'",'').replace('"','') ; 
            if($users){
                write-verbose "No -users specified, detected value on clipboard:`n$($users)" ; 
            } else { 
                write-warning "No -users specified, nothing matching dname, emailaddress or samaccountname, found on clipboard. EXITING!" ; 
                Break ; 
            } ; 
        } ; 
        $ttl = ($users|measure).count ; 
        if($ttl -lt 10){
            write-verbose "($(($users|measure).count)) user(s) specified:`n'$($users -join "','")'" ;    
        } else { 
            write-verbose "($(($users|measure).count)) user(s) specified (-gt 10, suppressing details)" ;    
        } 

        rx10 -Verbose:$false ; #rxo  -Verbose:$false ; #cmsol  -Verbose:$false ;
        connect-ad -Verbose:$false; 
        
        $propsmbx='Database','UseDatabaseRetentionDefaults','SingleItemRecoveryEnabled','RetentionPolicy','ProhibitSendQuota',
            'ProhibitSendReceiveQuota','SamAccountName','ServerName','UseDatabaseQuotaDefaults','IssueWarningQuota','Office',
            'UserPrincipalName','Alias','OrganizationalUnit  global.ad.toro.com/TERMedUsers','DisplayName','EmailAddresses',
            'HiddenFromAddressListsEnabled','LegacyExchangeDN','PrimarySmtpAddress','RecipientType','RecipientTypeDetails',
            'WindowsEmailAddress','DistinguishedName','CustomAttribute1','CustomAttribute2','CustomAttribute3','CustomAttribute4',
            'CustomAttribute5','CustomAttribute6','CustomAttribute7','CustomAttribute8','CustomAttribute9','CustomAttribute10',
            'CustomAttribute11','CustomAttribute12','CustomAttribute13','CustomAttribute14','CustomAttribute15''EmailAddressPolicyEnabled',
            'WhenChanged','WhenCreated' ;
        $propsadu = "accountExpires","CannotChangePassword","Company","Compound","Country","countryCode","Created","Department",
            "Description","DisplayName","DistinguishedName","Division","EmployeeID","EmployeeNumber","employeeType","Enabled","Fax",
            "GivenName","homeMDB","homeMTA","info","Initials","lastLogoff","lastLogon","LastLogonDate","mail","mailNickname","Manager",
            "mobile","MobilePhone","Modified","Name","Office","OfficePhone","Organization","physicalDeliveryOfficeName","POBox","PostalCode",
            "SamAccountName","sAMAccountType","State","StreetAddress","Surname","Title","UserPrincipalName",'CustomAttribute1',
            'CustomAttribute2','CustomAttribute3','CustomAttribute4','CustomAttribute5','CustomAttribute6','CustomAttribute7',
            'CustomAttribute8','CustomAttribute9','CustomAttribute10','CustomAttribute11','CustomAttribute12','CustomAttribute13',
            'CustomAttribute14','CustomAttribute15','EmailAddressPolicyEnabled',"whenChanged","whenCreated" ;
        $propsMC = 'ExternalEmailAddress','Alias','DisplayName','EmailAddresses','PrimarySmtpAddress','RecipientType',
            'RecipientTypeDetails','WindowsEmailAddress','Name','DistinguishedName','Identity','CustomAttribute1','CustomAttribute2',
            'CustomAttribute3','CustomAttribute4','CustomAttribute5','CustomAttribute6','CustomAttribute7','CustomAttribute8',
            'CustomAttribute9','CustomAttribute10','CustomAttribute11','CustomAttribute12','CustomAttribute13','CustomAttribute14',
            'CustomAttribute15','EmailAddressPolicyEnabled','whenChanged','whenCreated' ;
    } 
    PROCESS{
        $Procd=0 ;$pct = 0 ; 
        $aggreg =@() ; $contacts =@() ; $UnResolved = @() ; $Failed = @() ;
        $pltGRcp=[ordered]@{identity=$null;erroraction='STOP';resultsize=1;} ; 
        $pltGMbx=[ordered]@{identity=$null;erroraction='STOP'} ; 
        $pltGadu=[ordered]@{Identity = $null ; Properties='*' ;errorAction='STOP'} ;
        foreach ($usr in $users){
            $procd++ ; $pct = '{0:p0}' -f ($procd/$ttl) ; 
            $rrcp = $mbx = $mc = $mbxspecs = $adspecs = $summary = $NULL ; 
            #write-verbose "processing:$($usr)" ; 
            $sBnrS="`n#*------v PROCESSING ($($procd)/$($ttl)):$($usr)`t($($pct)) v------" ; 
            if($verbose){
                write-verbose "$((get-date).ToString('HH:mm:ss')):$($sBnrS)" ;
            } else { 
                write-host "." -NoNewLine ; 
            } ; 
            
            TRY {
                $pltGRcp.identity = $usr ; 
                write-verbose "get-recipient  w`n$(($pltGRcp|out-string).trim())" ; 
                $rrcp = get-recipient @pltGRcp ;
                if($rrcp){
                    $pltgmbx.identity = $rrcp.PrimarySmtpAddress ; 
                    switch ($rrcp.recipienttype){
                        'MailUser'{
                            write-verbose "get-remotemailbox  w`n$(($pltgmbx|out-string).trim())" ; 
                            $mbx = get-remotemailbox @pltgmbx 
                        } 
                        'UserMailbox' {
                            write-verbose "get-mailbox w`n$(($pltgmbx|out-string).trim())" ; 
                            $mbx = get-mailbox @pltgmbx ;
                        }
                        'MailContact' {
                            write-verbose "get-mailcontact w`n$(($pltgmbx|out-string).trim())" ; 
                            $mc = get-mailcontact @pltgmbx ;
                        }
                        default {throw "$($rrcp.alias):Unsupported RecipientType:$($rrcp.recipienttype)" }
                    } ; 
                    if(-not($mc)){
                        $mbxspecs =  $mbx| select $propsmbx ;
                        $pltGadu.identity = $mbx.samaccountname ; 
                        write-verbose "Get-ADUser w`n$(($pltGadu|out-string).trim())" ; 
                        Try {
                            $adspecs =Get-ADUser @pltGadu | select $propsadu ;
                        } CATCH [Microsoft.ActiveDirectory.Management.ADIdentityNotFoundException] {
                            $smsg = "(no matching ADuser found:$($pltGadu.identity))" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } catch {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            Continue ;
                        } ; 
                        $summary = @{} ;
                        foreach($object_properties in $mbxspecs.PsObject.Properties) {
                            $summary.add($object_properties.Name,$object_properties.Value) ;
                        } ;
                        foreach($object_properties in $adspecs.PsObject.Properties) {
                            $summary.add("AD$($object_properties.Name)",$object_properties.Value) ;
                        } ;
                        $aggreg+= New-Object PSObject -Property $summary ;

                    } else { 
                        $smsg = "Resolved user for $($usr) is RecipientType:$($mc.RecipientType)`nIt is not a local mail object, or AD object, and simply reflects a pointer to an external mail recipient.`nThis object is being added to the 'Contacts' section of the output.." ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $contacts += $mc | select $propsMC ;
                    } ; 
                } else { 
                    # in ISE $Error[0] is empty
                    #$ErrTrapd=$Error[0] ;
                    #if($ErrTrapd.Exception -match "couldn't\sbe\sfound\son"){
                        $UnResolved += $pltGRcp.identity ;
                    #} else { 
                        #$Failed += $pltGRcp.identity ;
                    #} ; 
                } ; 
            } CATCH [System.Management.Automation.RemoteException] {
                # catch error never gets here (at least not in ISE)
                $ErrTrapd=$Error[0] ;
                if($ErrTrapd.Exception -match "couldn't\sbe\sfound\son"){
                    $UnResolved += $pltGRcp.identity ;
                } else { 
                    $Failed += $pltGRcp.identity ;
                } ;                 
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                $Failed += $pltGRcp.identity ;
            } ; 

            if($verbose){
                write-verbose "$((get-date).ToString('HH:mm:ss')):$($sBnrS.replace('-v','-^').replace('v-','^-'))" ; ;
            } ; 
            
        } ; 
    }
    END{
        if(-not($ADDisabledOnly)){
            $Report = [ordered]@{
                Enabled = $Aggreg|?{($_.ADEnabled -eq $true ) -AND -not($_.distinguishedname -match $rgxDisabledOUs) } ;#?{$_.adDisabled -ne $true -AND -not($_.distinguishedname -match $rgxDisabledOUs)}
                Disabled = $Aggreg|?{($_.ADEnabled -eq $False) } ; 
                Contacts = $contacts ; 
                Unresolved = $Unresolved ; 
                Failed = $Failed;
            } ; 
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):outputing $(($Report.Enabled|measure).count) Enabled User summaries,`nand $(($Report.Disabled|measure).count) ADUser.Disabled or Disabled/TERM-OU account summaries`nand $(($Report.Contacts|measure).count) users resolved to MailContacts" ; 
        } else { 
            $Report = [ordered]@{
                Enabled = $Aggreg|?{($_.ADEnabled -eq $true) -AND -not($_.distinguishedname -match $rgxDisabledOUs) } ;#?{$_.adDisabled -ne $true -AND -not($_.distinguishedname -match $rgxDisabledOUs)}
                Disabled = $Aggreg|?{($_.ADEnabled -eq $False) -OR ($_.distinguishedname -match $rgxDisabledOUs) } ; 
                Contacts = $contacts ; 
                Unresolved = $Unresolved ; 
                Failed = $Failed;
            } ; 
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):outputing $(($Report.Enabled|measure).count) Enabled User summaries,`nand $(($Report.Disabled|measure).count) ADUser.Disabled`nand $(($Report.Contacts|measure).count) users resolved to MailContacts" ; 
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):-ADDisabledOnly specified: 'Disabled' output are *solely* ADUser.Disabled (no  Disabled/TERM-OU account filtering applied)`nand $(($Report.Contacts|measure).count) users resolved to MailContacts" ; 
        } ; 
        New-Object PSObject -Property $Report | write-output ;
        
     } ; 
 }

#*------^ get-UserMailADSummary.ps1 ^------


#*------v get-xopServerAdminDisplayVersion.ps1 v------
function get-xopServerAdminDisplayVersion {
    <#
    .SYNOPSIS
    get-xopServerAdminDisplayVersion.ps1 - Retrieves specified ComputerName's (get-exchangeserver).AdminDisplayVersion ~ Cumulative Update version (can optionally retrieve actual Service Update version w -getSErviceUpdate param)
    .NOTES
    Version     : 1.0.2
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2025-
    FileName    : get-xopServerAdminDisplayVersion.ps1
    License     : (non asserted)
    Copyright   : (non asserted)
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Powershell,ExchangeServer,Version
    AddedCredit : theSysadminChannel
    AddedWebsite: https://thesysadminchannel.com/get-exchange-cumulative-update-version-and-build-numbers-using-powershell/
    AddedTwitter: URL
    REVISION
    * 11:06 AM 4/4/2025:
        - udpated CBH (updates more extensive demos);
        - add: -GetServiceUpdate; echo's last BuildTable date, and url to screen; 
            pre-resolve specified Computername to DNS A record fqdn (( via Resolve-DNS -name Computername -Type A).name)
            Object returned to pipeline includes ServiceUpdateVersion & ServiceUpdateProduct , when -getServiceUpdate param is used.
        - removed: fqdn retry code (no longer needed if pre-fqdn'ing)
    * 1:28 PM 3/26/2025 updated CBH, with description/specifics on admindisplayversion returned by get-exchangeserver
        strange: initial atttempts on the lowest # local hub consisntly failed lookup on nbname, so added code to retry with resolved A record/fqdn; 
        ren Get-ExchangeVersion -> get-xopServerAdminDisplayVersion ; 
        updated CBH; 
        updated BuildToProductName indexed hash to specs posted as of 3/26/2025 at https://learn.microsoft.com/en-us/exchange/new-features/build-numbers-and-release-dates
            Maxes reflected in this script, as of that time:
             - Exchange Server 2019 CU15 (2025H1) 	February 10, 2025 	15.2.1748.10 	15.02.1748.010
             - Exchange Server 2016 CU23 Nov24SUv2 	November 27, 2024 	15.1.2507.44 	15.01.2507.044
             - Exchange Server 2013 CU23 Mar23SU 	March 14, 2023 	15.0.1497.48 	15.00.1497.048
             - Update Rollup 32 for Exchange Server 2010 SP3 	March 2, 2021 	14.3.513.0 	14.03.0513.000
    * 2021-Nov-9 tSC's posted vers at https://thesysadminchannel.com
    .DESCRIPTION
    get-xopServerAdminDisplayVersion.ps1 - Retrieves specified ComputerName's (get-exchangeserver).AdminDisplayVersion ~ Cumulative Update version (can optionally retrieve actual Service Update version w -getSErviceUpdate param)

    Expanded variant of tSC's posted script at https://thesysadminchannel.com. 
    - Expands coverage back through 'Exchange Server 2010 RTM', and as of latest BuildToProductName update, through 'Exchange Server 2019 CU15 (2025H1)'
    - Adds SU retrieval (via -getServiceUpdate param, reads remote server ExSetup.exe file version)
    - More fault tolerance (pre-expands specified -ComputerNames into DNS A record fqdn's - seems to avoid sporadic issues retrieving get-exchangeserver & remote invoke-expression; 
        adds code to retry failing queries)
    - BuildToProductName is updated through 3/25/25 current info, and reflects the MS Build table product name strings (unmodified; simpler to maintain over time). 

    Per [Exchange Server build numbers and release dates | Microsoft Learn](https://learn.microsoft.com/en-us/exchange/new-features/build-numbers-and-release-dates?view=exchserver-2019)

    Method details: 
    get-exchangeserver [server] returns Admindisplayversion like : 
    
        Version nn.n (Build nnn.n)
    
    The Buildnumber Shortstring can be converted to a value suitable for BuildToProductName indexed hash lookup, 
    by combining the 'Version nn.n' digits with the '(Build nnn.n)' digits, into: nn.n.nnn.n
    Handled via this regex: 
    
        [regex]::Matches($AdminDisplayVersion,"(\d*\.\d*)").value -join '.'

    If using version-specific code, do any matching on the nn.n for each Major rev, if you want to be sure of your supported commandset targets
        - 2019, 'Version 15.2'
        - 2016, 'Version 15.1'
        - 2013, 'Version 15.0'
        - 2010sp3, 'Version 14.3'
        - 2010sp2, 'Version 14.2'
        - 2010sp1, 'Version 14.1'
        - 2010, 'Version 14.0'

    .PARAMETER ComputerName
    Array of Exchange server names to be queried
    .PARAMETER GetServiceUpdate
    Switch to remote-query the ServiceUpdate revision (polling Version on Exsetup.exe)
    .INPUTS
    None. Does not accepted piped input.(.NET types, can add description)
    .OUTPUTS
    None. Returns no objects or output (.NET types)
    System.Boolean
    [| get-member the output to see what .NET obj TypeName is returned, to use here]
    .EXAMPLE
    PS> Get-ExchangeServer | get-xopServerAdminDisplayVersion ; 

        ComputerName Edition    BuildNumber   ProductName
        ------------ -------    ------------  -----------
        nnnnnnn1     Standard   15.2.1748.10  Exchange Server 2019 CU15 (2025H1)
        nnnnnnn2     Enterprise 15.2.1748.10  Exchange Server 2019 CU15 (2025H1)

    Pipeline demo
    .EXAMPLE
    PS> get-xopServerAdminDisplayVersion -ComputerName @(ExchSrv01, ExchSrv02) ; 
    Typical pass on an array of servers
    .EXAMPLE
    PS> get-xopServerAdminDisplayVersion -ComputerName @(ExchSrv01, ExchSrv02) -getServiceUpdate ; 

        ComputerName         : xxxxxxxx
        Edition              : Standard
        BuildNumber          : 14.3.123.4
        ProductName          : Exchange Server 2010 SP3
        ServiceUpdateVersion : 14.3.513.0
        ServiceUpdateProduct : Update Rollup 32 for Exchange Server 2010 SP3
        ...

    Typical pass on an array of servers, and return SU version (in addition to CU reported by AdminDisplayVersion)
    .EXAMPLE
    PS> $results = get-exchangeserver | get-xopServerAdminDisplayVersion -getSU ; 
    PS> $results | %{
    PS>     $smsg = "`n$(($_ | ft -a ($_.psobject.Properties.name[0..3])|out-string).trim())" ; 
    PS>     $smsg += "`n$(($_ | ft -a ($_.psobject.Properties.name[-2..-1])|out-string).trim())`n" ;
    PS>     write-host -foregroundcolor green $smsg ; 
    PS> } ;     

        ComputerName Edition    BuildNumber ProductName             
        ------------ -------    ----------- -----------             
        xxxxxxxx     Enterprise 14.3.123.4  Exchange Server 2010 SP3
        ServiceUpdateVersion ServiceUpdateProduct                         
        -------------------- --------------------                         
        14.3.513.0           Update Rollup 32 for Exchange Server 2010 SP3

    Fancier formatted output demo, using -getSU alias for -getServiceUpdate
    .LINK
    https://github.com/tostka/verb-ex2010
    .LINK
    https://thesysadminchannel.com/get-exchange-cumulative-update-version-and-build-numbers-using-powershell/
    .LINK
    https://docs.microsoft.com/en-us/exchange/new-features/build-numbers-and-release-dates?
    #>
    [CmdletBinding()]
    PARAM(
        [Parameter(Mandatory = $true,ValueFromPipeline=$true,HelpMessage="Array of Exchange server names to be queried")]
            [string[]] $ComputerName,
        [Parameter(Mandatory = $true,ValueFromPipeline=$true,HelpMessage="Switch to remote-query the ServiceUpdate revision (polling Version on Exsetup.exe")]
            [Alias('getSU')]
            [switch]$GetServiceUpdate
    ) ; 
    BEGIN {
        # when updating $BuildToProductName table (below), also record date of last update here (echos to console, for awareness on results)
        [datetime]$lastBuildTableUpedate = '3/26/2025' ; 
        $BuildTableUpedateUrl = 'https://docs.microsoft.com/en-us/exchange/new-features/build-numbers-and-release-date' ; 
        #Creating the hash table with build numbers and cumulative updates
        # updated as of 9:56 AM 3/26/2025 to curr https://learn.microsoft.com/en-us/exchange/new-features/build-numbers-and-release-dates?view=exchserver-2019
        # also using unmodified MS Build names, from the chart (changing just burns time)
        write-verbose "`$ComputerName:$($ComputerName)" ; 
        $smsg = "NOTE:`$BuildToProductName table was last updated on $($lastBuildTableUpedate.ToShortDateString())" ; 
        $smsg += "`n(update from:$($BuildTableUpedateUrl))" ;
        write-host -foregroundcolor yellow $smsg ; 
        $BuildToProductName = @{
            '15.2.1748.10' = 	'Exchange Server 2019 CU15 (2025H1)'
            '15.2.1544.14' = 	'Exchange Server 2019 CU14 Nov24SUv2'
            '15.2.1544.13' = 	'Exchange Server 2019 CU14 Nov24SU'
            '15.2.1544.11' = 	'Exchange Server 2019 CU14 Apr24HU'
            '15.2.1544.9' = 	'Exchange Server 2019 CU14 Mar24SU'
            '15.2.1544.4' = 	'Exchange Server 2019 CU14 (2024H1)'
            '15.2.1258.39' = 	'Exchange Server 2019 CU13 Nov24SUv2'
            '15.2.1258.38' = 	'Exchange Server 2019 CU13 Nov24SU'
            '15.2.1258.34' = 	'Exchange Server 2019 CU13 Apr24HU'
            '15.2.1258.32' = 	'Exchange Server 2019 CU13 Mar24SU'
            '15.2.1258.28' = 	'Exchange Server 2019 CU13 Nov23SU'
            '15.2.1258.27' = 	'Exchange Server 2019 CU13 Oct23SU'
            '15.2.1258.25' = 	'Exchange Server 2019 CU13 Aug23SUv2'
            '15.2.1258.23' = 	'Exchange Server 2019 CU13 Aug23SU'
            '15.2.1258.16' = 	'Exchange Server 2019 CU13 Jun23SU'
            '15.2.1258.12' = 	'Exchange Server 2019 CU13 (2023H1)'
            '15.2.1118.40' = 	'Exchange Server 2019 CU12 Nov23SU'
            '15.2.1118.39' = 	'Exchange Server 2019 CU12 Oct23SU'
            '15.2.1118.37' = 	'Exchange Server 2019 CU12 Aug23SUv2'
            '15.2.1118.36' = 	'Exchange Server 2019 CU12 Aug23SU'
            '15.2.1118.30' = 	'Exchange Server 2019 CU12 Jun23SU'
            '15.2.1118.26' = 	'Exchange Server 2019 CU12 Mar23SU'
            '15.2.1118.25' = 	'Exchange Server 2019 CU12 Feb23SU'
            '15.2.1118.21' = 	'Exchange Server 2019 CU12 Jan23SU'
            '15.2.1118.20' = 	'Exchange Server 2019 CU12 Nov22SU'
            '15.2.1118.15' = 	'Exchange Server 2019 CU12 Oct22SU'
            '15.2.1118.12' = 	'Exchange Server 2019 CU12 Aug22SU'
            '15.2.1118.9' = 	'Exchange Server 2019 CU12 May22SU'
            '15.2.1118.7' = 	'Exchange Server 2019 CU12 (2022H1)'
            '15.2.986.42' = 	'Exchange Server 2019 CU11 Mar23SU'
            '15.2.986.41' = 	'Exchange Server 2019 CU11 Feb23SU'
            '15.2.986.37' = 	'Exchange Server 2019 CU11 Jan23SU'
            '15.2.986.36' = 	'Exchange Server 2019 CU11 Nov22SU'
            '15.2.986.30' = 	'Exchange Server 2019 CU11 Oct22SU'
            '15.2.986.29' = 	'Exchange Server 2019 CU11 Aug22SU'
            '15.2.986.26' = 	'Exchange Server 2019 CU11 May22SU'
            '15.2.986.22' = 	'Exchange Server 2019 CU11 Mar22SU'
            '15.2.986.15' = 	'Exchange Server 2019 CU11 Jan22SU'
            '15.2.986.14' = 	'Exchange Server 2019 CU11 Nov21SU'
            '15.2.986.9' = 	'Exchange Server 2019 CU11 Oct21SU'
            '15.2.986.5' = 	'Exchange Server 2019 CU11'
            '15.2.922.27' = 	'Exchange Server 2019 CU10 Mar22SU'
            '15.2.922.20' = 	'Exchange Server 2019 CU10 Jan22SU'
            '15.2.922.19' = 	'Exchange Server 2019 CU10 Nov21SU'
            '15.2.922.14' = 	'Exchange Server 2019 CU10 Oct21SU'
            '15.2.922.13' = 	'Exchange Server 2019 CU10 Jul21SU'
            '15.2.922.7' = 	'Exchange Server 2019 CU10'
            '15.2.858.15' = 	'Exchange Server 2019 CU9 Jul21SU'
            '15.2.858.12' = 	'Exchange Server 2019 CU9 May21SU'
            '15.2.858.10' = 	'Exchange Server 2019 CU9 Apr21SU'
            '15.2.858.5' = 	'Exchange Server 2019 CU9'
            '15.2.792.15' = 	'Exchange Server 2019 CU8 May21SU'
            '15.2.792.13' = 	'Exchange Server 2019 CU8 Apr21SU'
            '15.2.792.10' = 	'Exchange Server 2019 CU8 Mar21SU'
            '15.2.792.3' = 	'Exchange Server 2019 CU8'
            '15.2.721.13' = 	'Exchange Server 2019 CU7 Mar21SU'
            '15.2.721.2' = 	'Exchange Server 2019 CU7'
            '15.2.659.12' = 	'Exchange Server 2019 CU6 Mar21SU'
            '15.2.659.4' = 	'Exchange Server 2019 CU6'
            '15.2.595.8' = 	'Exchange Server 2019 CU5 Mar21SU'
            '15.2.595.3' = 	'Exchange Server 2019 CU5'
            '15.2.529.13' = 	'Exchange Server 2019 CU4 Mar21SU'
            '15.2.529.5' = 	'Exchange Server 2019 CU4'
            '15.2.464.15' = 	'Exchange Server 2019 CU3 Mar21SU'
            '15.2.464.5' = 	'Exchange Server 2019 CU3'
            '15.2.397.11' = 	'Exchange Server 2019 CU2 Mar21SU'
            '15.2.397.3' = 	'Exchange Server 2019 CU2'
            '15.2.330.11' = 	'Exchange Server 2019 CU1 Mar21SU'
            '15.2.330.5' = 	'Exchange Server 2019 CU1'
            '15.2.221.18' = 	'Exchange Server 2019 RTM Mar21SU'
            '15.2.221.12' = 	'Exchange Server 2019 RTM'
            '15.2.196.0' = 	'Exchange Server 2019 Preview'
            '15.1.2507.44' = 	'Exchange Server 2016 CU23 Nov24SUv2'
            '15.1.2507.43' = 	'Exchange Server 2016 CU23 Nov24SU'
            '15.1.2507.39' = 	'Exchange Server 2016 CU23 Apr24HU'
            '15.1.2507.37' = 	'Exchange Server 2016 CU23 Mar24SU'
            '15.1.2507.35' = 	'Exchange Server 2016 CU23 Nov23SU'
            '15.1.2507.34' = 	'Exchange Server 2016 CU23 Oct23SU'
            '15.1.2507.32' = 	'Exchange Server 2016 CU23 Aug23SUv2'
            '15.1.2507.31' = 	'Exchange Server 2016 CU23 Aug23SU'
            '15.1.2507.27' = 	'Exchange Server 2016 CU23 Jun23SU'
            '15.1.2507.23' = 	'Exchange Server 2016 CU23 Mar23SU'
            '15.1.2507.21' = 	'Exchange Server 2016 CU23 Feb23SU'
            '15.1.2507.17' = 	'Exchange Server 2016 CU23 Jan23SU'
            '15.1.2507.16' = 	'Exchange Server 2016 CU23 Nov22SU'
            '15.1.2507.13' = 	'Exchange Server 2016 CU23 Oct22SU'
            '15.1.2507.12' = 	'Exchange Server 2016 CU23 Aug22SU'
            '15.1.2507.9' = 	'Exchange Server 2016 CU23 May22SU'
            '15.1.2507.6' = 	'Exchange Server 2016 CU23 (2022H1)'
            '15.1.2375.37' = 	'Exchange Server 2016 CU22 Nov22SU'
            '15.1.2375.32' = 	'Exchange Server 2016 CU22 Oct22SU'
            '15.1.2375.31' = 	'Exchange Server 2016 CU22 Aug22SU'
            '15.1.2375.28' = 	'Exchange Server 2016 CU22 May22SU'
            '15.1.2375.24' = 	'Exchange Server 2016 CU22 Mar22SU'
            '15.1.2375.18' = 	'Exchange Server 2016 CU22 Jan22SU'
            '15.1.2375.17' = 	'Exchange Server 2016 CU22 Nov21SU'
            '15.1.2375.12' = 	'Exchange Server 2016 CU22 Oct21SU'
            '15.1.2375.7' = 	'Exchange Server 2016 CU22'
            '15.1.2308.27' = 	'Exchange Server 2016 CU21 Mar22SU'
            '15.1.2308.21' = 	'Exchange Server 2016 CU21 Jan22SU'
            '15.1.2308.20' = 	'Exchange Server 2016 CU21 Nov21SU'
            '15.1.2308.15' = 	'Exchange Server 2016 CU21 Oct21SU'
            '15.1.2308.14' = 	'Exchange Server 2016 CU21 Jul21SU'
            '15.1.2308.8' = 	'Exchange Server 2016 CU21'
            '15.1.2242.12' = 	'Exchange Server 2016 CU20 Jul21SU'
            '15.1.2242.10' = 	'Exchange Server 2016 CU20 May21SU'
            '15.1.2242.8' = 	'Exchange Server 2016 CU20 Apr21SU'
            '15.1.2242.4' = 	'Exchange Server 2016 CU20'
            '15.1.2176.14' = 	'Exchange Server 2016 CU19 May21SU'
            '15.1.2176.12' = 	'Exchange Server 2016 CU19 Apr21SU'
            '15.1.2176.9' = 	'Exchange Server 2016 CU19 Mar21SU'
            '15.1.2176.2' = 	'Exchange Server 2016 CU19'
            '15.1.2106.13' = 	'Exchange Server 2016 CU18 Mar21SU'
            '15.1.2106.2' = 	'Exchange Server 2016 CU18'
            '15.1.2044.13' = 	'Exchange Server 2016 CU17 Mar21SU'
            '15.1.2044.4' = 	'Exchange Server 2016 CU17'
            '15.1.1979.8' = 	'Exchange Server 2016 CU16 Mar21SU'
            '15.1.1979.3' = 	'Exchange Server 2016 CU16'
            '15.1.1913.12' = 	'Exchange Server 2016 CU15 Mar21SU'
            '15.1.1913.5' = 	'Exchange Server 2016 CU15'
            '15.1.1847.12' = 	'Exchange Server 2016 CU14 Mar21SU'
            '15.1.1847.3' = 	'Exchange Server 2016 CU14'
            '15.1.1779.8' = 	'Exchange Server 2016 CU13 Mar21SU'
            '15.1.1779.2' = 	'Exchange Server 2016 CU13'
            '15.1.1713.10' = 	'Exchange Server 2016 CU12 Mar21SU'
            '15.1.1713.5' = 	'Exchange Server 2016 CU12'
            '15.1.1591.18' = 	'Exchange Server 2016 CU11 Mar21SU'
            '15.1.1591.10' = 	'Exchange Server 2016 CU11'
            '15.1.1531.12' = 	'Exchange Server 2016 CU10 Mar21SU'
            '15.1.1531.3' = 	'Exchange Server 2016 CU10'
            '15.1.1466.16' = 	'Exchange Server 2016 CU9 Mar21SU'
            '15.1.1466.3' = 	'Exchange Server 2016 CU9'
            '15.1.1415.10' = 	'Exchange Server 2016 CU8 Mar21SU'
            '15.1.1415.2' = 	'Exchange Server 2016 CU8'
            '15.1.1261.35' = 	'Exchange Server 2016 CU7'
            '15.1.1034.26' = 	'Exchange Server 2016 CU6'
            '15.1.845.34' = 	'Exchange Server 2016 CU5'
            '15.1.669.32' = 	'Exchange Server 2016 CU4'
            '15.1.544.27' = 	'Exchange Server 2016 CU3'
            '15.1.466.34' = 	'Exchange Server 2016 CU2'
            '15.1.396.30' = 	'Exchange Server 2016 CU1'
            '15.1.225.42' = 	'Exchange Server 2016 RTM'
            '15.1.225.16' = 	'Exchange Server 2016 Preview'
            '15.0.1497.48' = 	'Exchange Server 2013 CU23 Mar23SU'
            '15.0.1497.47' = 	'Exchange Server 2013 CU23 Feb23SU'
            '15.0.1497.45' = 	'Exchange Server 2013 CU23 Jan23SU'
            '15.0.1497.44' = 	'Exchange Server 2013 CU23 Nov22SU'
            '15.0.1497.42' = 	'Exchange Server 2013 CU23 Oct22SU'
            '15.0.1497.40' = 	'Exchange Server 2013 CU23 Aug22SU'
            '15.0.1497.36' = 	'Exchange Server 2013 CU23 May22SU'
            '15.0.1497.33' = 	'Exchange Server 2013 CU23 Mar22SU'
            '15.0.1497.28' = 	'Exchange Server 2013 CU23 Jan22SU'
            '15.0.1497.26' = 	'Exchange Server 2013 CU23 Nov21SU'
            '15.0.1497.24' = 	'Exchange Server 2013 CU23 Oct21SU'
            '15.0.1497.23' = 	'Exchange Server 2013 CU23 Jul21SU'
            '15.0.1497.18' = 	'Exchange Server 2013 CU23 May21SU'
            '15.0.1497.15' = 	'Exchange Server 2013 CU23 Apr21SU'
            '15.0.1497.12' = 	'Exchange Server 2013 CU23 Mar21SU'
            '15.0.1497.2' = 	'Exchange Server 2013 CU23'
            '15.0.1473.6' = 	'Exchange Server 2013 CU22 Mar21SU'
            '15.0.1473.3' = 	'Exchange Server 2013 CU22'
            '15.0.1395.12' = 	'Exchange Server 2013 CU21 Mar21SU'
            '15.0.1395.4' = 	'Exchange Server 2013 CU21'
            '15.0.1367.3' = 	'Exchange Server 2013 CU20'
            '15.0.1365.1' = 	'Exchange Server 2013 CU19'
            '15.0.1347.2' = 	'Exchange Server 2013 CU18'
            '15.0.1320.4' = 	'Exchange Server 2013 CU17'
            '15.0.1293.2' = 	'Exchange Server 2013 CU16'
            '15.0.1263.5' = 	'Exchange Server 2013 CU15'
            '15.0.1236.3' = 	'Exchange Server 2013 CU14'
            '15.0.1210.3' = 	'Exchange Server 2013 CU13'
            '15.0.1178.4' = 	'Exchange Server 2013 CU12'
            '15.0.1156.6' = 	'Exchange Server 2013 CU11'
            '15.0.1130.7' = 	'Exchange Server 2013 CU10'
            '15.0.1104.5' = 	'Exchange Server 2013 CU9'
            '15.0.1076.9' = 	'Exchange Server 2013 CU8'
            '15.0.1044.25' = 	'Exchange Server 2013 CU7'
            '15.0.995.29' = 	'Exchange Server 2013 CU6'
            '15.0.913.22' = 	'Exchange Server 2013 CU5'
            '15.0.847.64' = 	'Exchange Server 2013 SP1 Mar21SU'
            '15.0.847.32' = 	'Exchange Server 2013 SP1'
            '15.0.775.38' = 	'Exchange Server 2013 CU3'
            '15.0.712.24' = 	'Exchange Server 2013 CU2'
            '15.0.620.29' = 	'Exchange Server 2013 CU1'
            '15.0.516.32' = 	'Exchange Server 2013 RTM'
            '14.3.513.0' = 	'Update Rollup 32 for Exchange Server 2010 SP3'
            '14.3.509.0' = 	'Update Rollup 31 for Exchange Server 2010 SP3'
            '14.3.496.0' = 	'Update Rollup 30 for Exchange Server 2010 SP3'
            '14.3.468.0' = 	'Update Rollup 29 for Exchange Server 2010 SP3'
            '14.3.461.1' = 	'Update Rollup 28 for Exchange Server 2010 SP3'
            '14.3.452.0' = 	'Update Rollup 27 for Exchange Server 2010 SP3'
            '14.3.442.0' = 	'Update Rollup 26 for Exchange Server 2010 SP3'
            '14.3.435.0' = 	'Update Rollup 25 for Exchange Server 2010 SP3'
            '14.3.419.0' = 	'Update Rollup 24 for Exchange Server 2010 SP3'
            '14.3.417.1' = 	'Update Rollup 23 for Exchange Server 2010 SP3'
            '14.3.411.0' = 	'Update Rollup 22 for Exchange Server 2010 SP3'
            '14.3.399.2' = 	'Update Rollup 21 for Exchange Server 2010 SP3'
            '14.3.389.1' = 	'Update Rollup 20 for Exchange Server 2010 SP3'
            '14.3.382.0' = 	'Update Rollup 19 for Exchange Server 2010 SP3'
            '14.3.361.1' = 	'Update Rollup 18 for Exchange Server 2010 SP3'
            '14.3.352.0' = 	'Update Rollup 17 for Exchange Server 2010 SP3'
            '14.3.336.0' = 	'Update Rollup 16 for Exchange Server 2010 SP3'
            '14.3.319.2' = 	'Update Rollup 15 for Exchange Server 2010 SP3'
            '14.3.301.0' = 	'Update Rollup 14 for Exchange Server 2010 SP3'
            '14.3.294.0' = 	'Update Rollup 13 for Exchange Server 2010 SP3'
            '14.3.279.2' = 	'Update Rollup 12 for Exchange Server 2010 SP3'
            '14.3.266.2' = 	'Update Rollup 11 for Exchange Server 2010 SP3'
            '14.3.248.2' = 	'Update Rollup 10 for Exchange Server 2010 SP3'
            '14.3.235.1' = 	'Update Rollup 9 for Exchange Server 2010 SP3'
            '14.3.224.2' = 	'Update Rollup 8 v2 for Exchange Server 2010 SP3'
            '14.3.224.1' = 	'Update Rollup 8 v1 for Exchange Server 2010 SP3 (recalled)'
            '14.3.210.2' = 	'Update Rollup 7 for Exchange Server 2010 SP3'
            '14.3.195.1' = 	'Update Rollup 6 for Exchange Server 2010 SP3'
            '14.3.181.6' = 	'Update Rollup 5 for Exchange Server 2010 SP3'
            '14.3.174.1' = 	'Update Rollup 4 for Exchange Server 2010 SP3'
            '14.3.169.1' = 	'Update Rollup 3 for Exchange Server 2010 SP3'
            '14.3.158.1' = 	'Update Rollup 2 for Exchange Server 2010 SP3'
            '14.3.146.0' = 	'Update Rollup 1 for Exchange Server 2010 SP3'
            '14.3.123.4' = 	'Exchange Server 2010 SP3'
            '14.2.390.3' = 	'Update Rollup 8 for Exchange Server 2010 SP2'
            '14.2.375.0' = 	'Update Rollup 7 for Exchange Server 2010 SP2'
            '14.2.342.3' = 	'Update Rollup 6 Exchange Server 2010 SP2'
            '14.2.328.10' = 	'Update Rollup 5 v2 for Exchange Server 2010 SP2'
            '14.3.328.5' = 	'Update Rollup 5 for Exchange Server 2010 SP2'
            '14.2.318.4' = 	'Update Rollup 4 v2 for Exchange Server 2010 SP2'
            '14.2.318.2' = 	'Update Rollup 4 for Exchange Server 2010 SP2'
            '14.2.309.2' = 	'Update Rollup 3 for Exchange Server 2010 SP2'
            '14.2.298.4' = 	'Update Rollup 2 for Exchange Server 2010 SP2'
            '14.2.283.3' = 	'Update Rollup 1 for Exchange Server 2010 SP2'
            '14.2.247.5' = 	'Exchange Server 2010 SP2'
            '14.1.438.0' = 	'Update Rollup 8 for Exchange Server 2010 SP1'
            '14.1.421.3' = 	'Update Rollup 7 v3 for Exchange Server 2010 SP1'
            '14.1.421.2' = 	'Update Rollup 7 v2 for Exchange Server 2010 SP1'
            '14.1.421.0' = 	'Update Rollup 7 for Exchange Server 2010 SP1'
            '14.1.355.2' = 	'Update Rollup 6 for Exchange Server 2010 SP1'
            '14.1.339.1' = 	'Update Rollup 5 for Exchange Server 2010 SP1'
            '14.1.323.6' = 	'Update Rollup 4 for Exchange Server 2010 SP1'
            '14.1.289.7' = 	'Update Rollup 3 for Exchange Server 2010 SP1'
            '14.1.270.1' = 	'Update Rollup 2 for Exchange Server 2010 SP1'
            '14.1.255.2' = 	'Update Rollup 1 for Exchange Server 2010 SP1'
            '14.1.218.15' = 	'Exchange Server 2010 SP1'
            '14.0.726.0' = 	'Update Rollup 5 for Exchange Server 2010'
            '14.0.702.1' = 	'Update Rollup 4 for Exchange Server 2010'
            '14.0.694.0' = 	'Update Rollup 3 for Exchange Server 2010'
            '14.0.689.0' = 	'Update Rollup 2 for Exchange Server 2010'
            '14.0.682.1' = 	'Update Rollup 1 for Exchange Server 2010'
            '14.0.639.21' = 	'Exchange Server 2010 RTM'            
        }; 
        $Retries = 4 ;
        $RetrySleep = 2 ;
    } ;  # BEG-E
    PROCESS {
        foreach ($Computer in $ComputerName) {
            $Computer = $Computer.ToUpper()
            write-verbose "==Computer:$($Computer)" ; 
            $Exit = 0 ;
            Do {
                TRY {
                    # getting errors on the invoke-expression: always preconvert DNS nbname to FQDN: 
                    if($cFQDN = (resolve-dnsname -type A $computer | sort { $_.IPAddress -replace '\d+', { $_.Value.PadLeft(3, '0') } } )[-1].name){
                        write-verbose "`$cFQDN:$($cFQDN)" ; 
                        if($Server = get-exchangeserver -Identity $cFQDN -ErrorAction Stop -Verbose:($PSBoundParameters['Verbose'] -eq $true)){
                            $Exit = $Retries ;
                        }; 
                    }elseif($Server = get-exchangeserver -Identity $Computer -ErrorAction Stop -Verbose:($PSBoundParameters['Verbose'] -eq $true)){
                        $Exit = $Retries ;
                    } else { 
                        write-warning "Unable to either:resolve-dnsname -type A $($computer) to FQDN, and/or get-exchangeserver -Identity $($Computer)!`nSKIPPING!" ; 
                        CONTINUE
                    }  ; 
                    write-verbose "`$Server:`n$(($Server|out-string).trim())" ; 
                } CATCH {
                    $ErrorTrapped=$Error[0] ;
                    Write-warning "Failed to exec cmd because: $($ErrorTrapped.Exception.Message )" ;
                    Start-Sleep -Seconds $RetrySleep ;
                    $Exit ++ ;
                    Write-Verbose "Try #: $Exit" ;
                    If ($Exit -eq $Retries) {Write-Warning "Unable to exec cmd!"; BREAK ; } ;
                }  ;
            } Until ($Exit -eq $Retries) ; 

            TRY {
                $Version = $Server.AdminDisplayVersion
                $Version = [regex]::Matches($Version, "(\d*\.\d*)").value -join '.'
                $Product = $BuildToProductName[$Version]
                if($GetServiceUpdate){
                    if($cFQDN){
                        $targetName = $cFQDN ; 
                    }else{
                        $targetName = $Server.Name ; 
                    }
                    if($FileversionInfo = Invoke-Command -ComputerName $targetName -ScriptBlock { Get-Command Exsetup.exe | ForEach-Object { $_.FileversionInfo } } ){
                        write-verbose "`$FileversionInfo:`n$(($FileversionInfo | ft -a |out-string).trim())" ; 
                        [version]$ExsetupRev = (@($FileversionInfo.FileMajorPart,$FileversionInfo.FileMinorPart,$FileversionInfo.FileBuildPart,$FileversionInfo.FilePrivatePart) -join '.')
                        $ExsetupProduct = $BuildToProductName[$ExsetupRev.tostring()]
                        write-verbose "`$ExsetupProduct:$($ExsetupProduct)" ; 
                    } else { 
                        throw "$($Server.name):Unable to remote retrieve: Get-Command Exsetup.exe | ForEach-Object { $_.FileversionInfo}"
                    } ; 
                    $Object = [pscustomobject]@{
                        ComputerName = $Computer
                        Edition      = $Server.Edition
                        BuildNumber  = $Version
                        ProductName  = $Product
                        ServiceUpdateVersion = $ExsetupRev.tostring() ; 
                        ServiceUpdateProduct = $ExsetupProduct ; 
                    }
                }else{
                    $Object = [pscustomobject]@{
                        ComputerName = $Computer ; 
                        Edition      = $Server.Edition ; 
                        BuildNumber  = $Version ; 
                        ProductName  = $Product ; 
                    } ; 
                } ; 
                Write-Output $Object
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" ;
            } FINALLY {
                $Server  = $null ; 
                $Version = $null ; 
                $Product = $null ; 
                $ExsetupRev = $null  ; 
                $ExsetupProduct = $null  ; 
                $FileversionInfo = $null  ; 
                $FileversionInfo = $null  ; 
                $ExsetupProduct = $null  ; 
            }
        } ;  # loop-E
    };  # PROC-E
    END {}
}

#*------^ get-xopServerAdminDisplayVersion.ps1 ^------


#*------v import-EMSLocalModule.ps1 v------
Function import-EMSLocalModule {
  <#
    .SYNOPSIS
    import-EMSLocalModule - Setup local server bin-module-based ExchOnPrem Mgmt Shell connection (contrasts with Ex2007/10 snapin use ; validated Exch2016)
    .NOTES
    Author: Todd Kadrie
    Website:	http://toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    Version     : 1.0.0
    CreatedDate : 2021-04-15
    FileName    : import-EMSLocalModule()
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Exchange,Exchange-2013,Exchange-2016
    REVISIONS   :
    * 9:48 AM 7/27/2021 added verbose to -pstitlebar
    * 11:40 AM 5/14/2021 added -ea 0 to the gv tests (suppresses not-found error when called without logging config)
    * 9:21 AM 4/16/2021 renamed load-emsmodule -> import-EMSLocalModule, added pretest and post verify
    * 10:14 AM 4/12/2021 init vers
    .DESCRIPTION
    import-EMSLocalModule - Setup local server bin-module-based ExchOnPrem Mgmt Shell connection (contrasts with Ex2007/10 snapin use ; validated Exch2016)
    Wraps the native ex server desktop EMS, .lnk commands:
    . 'C:\Program Files\Microsoft\Exchange Server\V15\bin\RemoteExchange.ps1';
    Connect-ExchangeServer -auto -ClientApplication:ManagementShell
    Handy for loading local non-dehydrated support in ISE, regular PS etc, where existing code relies on non-dehydrated objects.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    import-EMSLocalModule ;
    .LINK
    https://github.com/tostka/verb-Ex2010/
    #>
    [CmdletBinding()]
    #[Alias()]
    Param()  ;
    BEGIN{
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;  # BEG-E
    PROCESS{
        $error.clear() ;
        TRY {
            if($tMod = get-module ([System.Net.Dns]::gethostentry($(hostname))).hostname -ea 0){
                write-verbose "(local EMS module already loaded:)`n$(($tMod | ft -auto ModuleType,Version,Name,ExportedCommands|out-string).trim())" ;
            } else {
                write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):(importing local Exchange Mgmt Shell binary module)" ;
                if($env:ExchangeInstallPath){
                    $rExps1 = "$($env:ExchangeInstallPath)bin\RemoteExchange.ps1"
                    if(test-path $rExps1){
                        . $rExps1 ;
                        if(Get-Command Connect-ExchangeServer){
                            Connect-ExchangeServer -auto -ClientApplication:ManagementShell ;
                        } else {
                            throw "Unable to gcm Connect-ExchangeServer!" ;
                        } ;
                    } else {
                        throw "Unable to locate: `$(`$env:ExchangeInstallPath)bin\RemoteExchange.ps1" ;
                    } ;
                } else {
                    throw "Unable to locate: `$env:ExchangeInstallPath Environment Variable (Exchange does not appear to be locally installed)" ;
                } ;
            } ;
        } CATCH {
            $ErrTrapd = $_ ;
            write-warning "$(get-date -format 'HH:mm:ss'): Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            #-=-record a STATUSERROR=-=-=-=-=-=-=
            $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(Get-Variable passstatus -scope Script -ea 0 ){$script:PassStatus += $statusdelta } ;
            if(Get-Variable -Name PassStatus_$($tenorg) -scope Script  -ea 0 ){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
            #-=-=-=-=-=-=-=-=
        } ;
        # 7:54 AM 11/1/2017 add titlebar tag
        if(Get-Command Add-PSTitleBar -ea 0 ){Add-PSTitleBar 'EMSL' -verbose:$($VerbosePreference -eq "Continue");} ;
        # tag E10IsDehydrated
        $Global:ExOPIsDehydrated = $false ;
    } ;  # PROC-E
    END {
        $tMod = $null ;
        if($tMod = GET-MODULE ([System.Net.Dns]::gethostentry($(hostname))).HOSTNAME){
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):(local EMS module loaded:)`n$(($tMod | ft -auto ModuleType,Version,Name,ExportedCommands|out-string).trim())" ;
        } else {
            throw "Unable to resolve target local EMS module:GET-MODULE $([System.Net.Dns]::gethostentry($(hostname))).HOSTNAME)" ;
        } ;
    }
}

#*------^ import-EMSLocalModule.ps1 ^------


#*------v Initialize-xopEventIDTable.ps1 v------
if(-not(gci function:Initialize-xopEventIDTable -ea 0)){
    function Initialize-xopEventIDTable {
        <#
        .SYNOPSIS
        Initialize-xopEventIDTable - Builds an indexed hash tabl of Exchange Server Get-MessageTrackingLog EventIDs
        .NOTES
        Version     : 1.0.0
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2025-04-22
        FileName    : Initialize-xopEventIDTable
        License     : (none asserted)
        Copyright   : (none asserted)
        Github      : https://github.com/tostka/verb-Ex2010
        Tags        : Powershell,EmailAddress,Version
        AddedCredit : Bruno Lopes (brunokktro )
        AddedWebsite: https://www.linkedin.com/in/blopesinfo
        AddedTwitter: @brunokktro / https://twitter.com/brunokktro
        REVISIONS
        * 2;58 pm 4/28/2025 Updated table again, and found Ex2016/19 eventid specifications online, added. Did find that 
        the online doc doesn't document the edge SendExternal event id (added below, manually).             
        * 1:47 PM 7/9/2024 CBA github field correction
        * 1:22 PM 5/22/2024init
        .DESCRIPTION
        Initialize-xopEventIDTable - Builds an indexed hash tabl of Exchange Server Get-MessageTrackingLog EventIDs

        ## Exchange 2019 EventID reference:

        [Event types in the message tracking log | Microsoft Learn](https://learn.microsoft.com/en-us/exchange/mail-flow/transport-logs/message-tracking?view=exchserver-2019#event-types-in-the-message-tracking-log)

        Doesn't include Edge eventid: 
        "SENDEXTERNAL          | A message was sent by SMTP to sent to the SMTP server responsible to receive the email for the external email address."
    
        (needs to be manually spliced in below 'SEND' during updates from source MS documentation)
    
        .OUTPUT
        System.Collections.Hashtable returns an Indexed Hash of EventIDs EventName to Description
        .EXAMPLE
        PS> $eventIDLookupTbl = Initialize-EventIDTable ; 
        PS> $smsg = "`n`n## EventID Definitions:" ; 
        PS> $TrackMsgs | group eventid | select -expand Name | foreach-object{                   
        PS>     $smsg += "`n$(($eventIDLookupTbl[$_] | ft -hidetableheaders |out-string).trim())" ; 
        PS> } ; 
        PS> $smsg += "`n`n" ; 
        PS> if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Prompt } 
        PS> else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        Demo resolving histogram eventid uniques, to MS documented meansings of each event id in the msgtrack.        
        .LINK
        https://github.com/tostka/verb-Ex2010
        #>
        [CmdletBinding()]
        #[Alias('ALIASNAME')]
        PARAM() ;
        BEGIN {
            ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
            $verbose = $($VerbosePreference -eq "Continue")
            $rgxSMTPAddress = "([0-9a-zA-Z]+[-._+&='])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}" ; 
            $sBnr="#*======v $($CmdletName): v======" ;
            write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
            $eventIDsMD = @"
EventName             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
--------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
AGENTINFO             | This event is used by transport agents to log custom data.                                                                                                                                                                                                                                                                                                                                                                                                                             
BADMAIL               | A message submitted by the Pickup directory or the Replay directory that can't be delivered or returned.                                                                                                                                                                                                                                                                                                                                                                               
CLIENTSUBMISSION      | A message was submitted from the Outbox of a mailbox.                                                                                                                                                                                                                                                                                                                                                                                                                                  
DEFER                 | Message delivery was delayed.                                                                                                                                                                                                                                                                                                                                                                                                                                                          
DELIVER               | A message was delivered to a local mailbox.                                                                                                                                                                                                                                                                                                                                                                                                                                            
DELIVERFAIL           | An agent tried to deliver the message to a folder that doesn't exist in the mailbox.                                                                                                                                                                                                                                                                                                                                                                                                   
DROP                  | A message was dropped without a delivery status notification (also known as a DSN, bounce message, non-delivery report, or NDR). For example:<br/>- Completed moderation approval request messages.<br/>- Spam messages that were silently dropped without an NDR.                                                                                                                                                                                                                     
DSN                   | A delivery status notification (DSN) was generated.                                                                                                                                                                                                                                                                                                                                                                                                                                    
DUPLICATEDELIVER      | A duplicate message was delivered to the recipient. Duplication may occur if a recipient is a member of multiple nested distribution groups. Duplicate messages are detected and removed by the information store.                                                                                                                                                                                                                                                                     
DUPLICATEEXPAND       | During the expansion of the distribution group, a duplicate recipient was detected.                                                                                                                                                                                                                                                                                                                                                                                                    
DUPLICATEREDIRECT     | An alternate recipient for the message was already a recipient.                                                                                                                                                                                                                                                                                                                                                                                                                        
EXPAND                | A distribution group was expanded.                                                                                                                                                                                                                                                                                                                                                                                                                                                     
FAIL                  | Message delivery failed. Sources include SMTP, DNS, QUEUE, and ROUTING.                                                                                                                                                                                                                                                                                                                                                                                                                
HADISCARD             | A shadow message was discarded after the primary copy was delivered to the next hop. For more information, see Shadow redundancy in Exchange Server.                                                                                                                                                                                                                                                                                                                                   
HARECEIVE             | A shadow message was received by the server in the local database availability group (DAG) or Active Directory site.                                                                                                                                                                                                                                                                                                                                                                   
HAREDIRECT            | A shadow message was created.                                                                                                                                                                                                                                                                                                                                                                                                                                                          
HAREDIRECTFAIL        | A shadow message failed to be created. The details are stored in the source-context field.                                                                                                                                                                                                                                                                                                                                                                                             
INITMESSAGECREATED    | A message was sent to a moderated recipient, so the message was sent to the arbitration mailbox for approval. For more information, see Manage message approval.                                                                                                                                                                                                                                                                                                                       
LOAD                  | A message was successfully loaded at boot.                                                                                                                                                                                                                                                                                                                                                                                                                                             
MODERATIONEXPIRE      | A moderator for a moderated recipient never approved or rejected the message, so the message expired. For more information about moderated recipients, see Manage message approval.                                                                                                                                                                                                                                                                                                    
MODERATORAPPROVE      | A moderator for a moderated recipient approved the message, so the message was delivered to the moderated recipient.                                                                                                                                                                                                                                                                                                                                                                   
MODERATORREJECT       | A moderator for a moderated recipient rejected the message, so the message wasn't delivered to the moderated recipient.                                                                                                                                                                                                                                                                                                                                                                
MODERATORSALLNDR      | All approval requests sent to all moderators of a moderated recipient were undeliverable, and resulted in non-delivery reports (also known as NDRs or bounce messages).                                                                                                                                                                                                                                                                                                                
NOTIFYMAPI            | A message was detected in the Outbox of a mailbox on the local server.                                                                                                                                                                                                                                                                                                                                                                                                                 
NOTIFYSHADOW          | A message was detected in the Outbox of a mailbox on the local server, and a shadow copy of the message needs to be created.                                                                                                                                                                                                                                                                                                                                                           
POISONMESSAGE         | A message was put in the poison message queue or removed from the poison message queue.                                                                                                                                                                                                                                                                                                                                                                                                
PROCESS               | The message was successfully processed.                                                                                                                                                                                                                                                                                                                                                                                                                                                
PROCESSMEETINGMESSAGE | A meeting message was processed by the Mailbox Transport Delivery service.                                                                                                                                                                                                                                                                                                                                                                                                             
RECEIVE               | A message was received by the SMTP receive component of the transport service or from the Pickup or Replay directories (source: SMTP), or a message was submitted from a mailbox to the Mailbox Transport Submission service (source: STOREDRIVER).                                                                                                                                                                                                                                    
REDIRECT              | A message was redirected to an alternative recipient after an Active Directory lookup.                                                                                                                                                                                                                                                                                                                                                                                                 
RESOLVE               | A message's recipients were resolved to a different email address after an Active Directory lookup.                                                                                                                                                                                                                                                                                                                                                                                    
RESUBMIT              | A message was automatically resubmitted from Safety Net. For more information, see Safety Net in Exchange Server.                                                                                                                                                                                                                                                                                                                                                                      
RESUBMITDEFER         | A message resubmitted from Safety Net was deferred.                                                                                                                                                                                                                                                                                                                                                                                                                                    
RESUBMITFAIL          | A message resubmitted from Safety Net failed.                                                                                                                                                                                                                                                                                                                                                                                                                                          
SEND                  | A message was sent by SMTP between transport services.                                                                                                                                                                                                                                                                                                                                                                                                                                 
SENDEXTERNAL          | A message was sent by SMTP to sent to the SMTP server responsible to receive the email for the external email address.                                                                                                                                                                                                                                                                                                                                                                                                                           
SUBMIT                | The Mailbox Transport Submission service successfully transmitted the message to the Transport service. For SUBMIT events, the source-context property contains the following details:<br/>- MDB: The mailbox database GUID.<br/>- Mailbox: The mailbox GUID.<br/>- Event: The event sequence number.<br/>- MessageClass: The type of message. For example, IPM.Note.<br/>- CreationTime: Date-time of the message submission.<br/>- ClientType: For example, User, OWA, or ActiveSync.
SUBMITDEFER           | The message transmission from the Mailbox Transport Submission service to the Transport service was deferred.                                                                                                                                                                                                                                                                                                                                                                          
SUBMITFAIL            | The message transmission from the Mailbox Transport Submission service to the Transport service failed.                                                                                                                                                                                                                                                                                                                                                                                
SUPPRESSED            | The message transmission was suppressed.                                                                                                                                                                                                                                                                                                                                                                                                                                               
THROTTLE              | The message was throttled.                                                                                                                                                                                                                                                                                                                                                                                                                                                             
TRANSFER              | Recipients were moved to a forked message because of content conversion, message recipient limits, or agents. Sources include ROUTING or QUEUE.
"@ ; 
            # UPDATE NOTE: MANUAL UNDOCUMENTED ADDITION: "SENDEXTERNAL          | A message was sent by SMTP to sent to the SMTP server responsible to receive the email for the external email address."
            # (needs to be manually spliced in below 'SEND' during updates from source MS documentation)
            $Object = $eventIDsMD | convertfrom-MarkdownTable ; 
            $Key = 'EventName' ; 
            $Hashtable = @{}
        }
        PROCESS {
            Foreach ($Item in $Object){
                $Procd++ ; 
                $Hashtable[$Item.$Key.ToString()] = $Item ; 
                if($ShowProgress -AND ($Procd -eq $Every)){
                    write-host -NoNewline '.' ; $Procd = 0 
                } ; 
            } ;                 
        } # PROC-E
        END{
            $Hashtable | write-output ; 
            write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
        }
    };
}

#*------^ Initialize-xopEventIDTable.ps1 ^------


#*------v Invoke-ExchangeCommand.ps1 v------
function Invoke-ExchangeCommand{
    <#
    .SYNOPSIS
    Invoke-ExchangeCommand.ps1 - PowerShell function allows you to run PowerShell commands and script blocks on Exchange servers in different forests without a forest trust.
    .NOTES
    Version     : 0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2020-09-15
    FileName    : IInvoke-ExchangeCommand.ps1
    License     : MIT License
    Copyright   : (c) 2015 Mark Gossa
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Powershell,Exchange,ExchangeForestMigration,CrossForest,ExchangeRemotePowerShell,ExchangePowerShell
    AddedCredit : Mark Gossa
    AddedWebsite: https://gallery.technet.microsoft.com/Exchange-Cross-Forest-e25d48eb
    AddedTwitter:
    REVISIONS
    * 2:40 PM 9/17/2020 cleanup <?> encode damage (emdash's for dashes)
    * 4:28 PM 9/15/2020 cleanedup, added CBH, added to verb-Ex2010
    * 10/26/2015 posted vers
    .DESCRIPTION
    Invoke-ExchangeCommand.ps1 - PowerShell function allows you to run PowerShell commands and script blocks on Exchange servers in different forests without a forest trust.
    This PowerShell function allows you to run PowerShell commands and script blocks on Exchange servers in different forests without a forest trust.
    To run Invoke-ExchangeCommand, you must connect to the Exchange server using a hostname and not an IP address. Invoke-ExchangeCommand works best on Server 2012 R2/Windows 8.1 and later but also works on Server 2008 R2/Windows 7. Tested on Exchange 2010 and later. More information on cross-forest Exchange PowerShell can be found here: http://markgossa.blogspot.com/2015/10/exchange-2010-2013-cross-forest-remote-powershell.html
    Usage:
    1. Enable connections to all PowerShell hosts:
    winrm s winrm/config/client '@{TrustedHosts="*"}'
    # TSK: OR BETTER: _SELECTIVE_ HOSTS:
    Set-Item -Path WSMan:\localhost\Client\TrustedHosts -Value 'LYNMS7330.global.ad.toro.com' -Concatenate -Force ; Get-Item -Path WSMan:\localhost\Client\TrustedHosts | fl Name, Value ;
    cd WSMan:\localhost\Client ;
    dir | format-table -auto ; # review existing settings:
    # AllowEncrypted is defined on the client end, via the WSMAN: drive
    set-item .\allowunencrypted $true ;
    # You probably will need to set the AllowUnencrypted config setting in the Service as well, which has to be changed in the remote server using the following:
    set-item -force WSMan:\localhost\Service\AllowUnencrypted $true ;
    # tsk: reverted it back out:
    #-=-=-=-=-=-=-=-=
    [PS] WSMan:\localhost\Service\Auth> set-item -force WSMan:\localhost\Service\AllowUnencrypted $false ;
    cd ..
    [PS] WSMan:\localhost\Service>dir | format-table -auto ;
       WSManConfig: Microsoft.WSMan.Management\WSMan::localhost\Service
    Type          Name                             SourceOfValue Value
    ----          ----                             ------------- -----
    System.String RootSDDL                                       O:NSG:BAD:P(A;;GA;;;BA)(A;;GR;;;IU)S:P(AU;FA;GA;;;WD)(A...
    System.String MaxConcurrentOperations                        4294967295
    System.String MaxConcurrentOperationsPerUser                 1500
    System.String EnumerationTimeoutms                           240000
    System.String MaxConnections                                 300
    System.String MaxPacketRetrievalTimeSeconds                  120
    System.String AllowUnencrypted                               false
    Container     Auth
    Container     DefaultPorts
    System.String IPv4Filter                                     *
    System.String IPv6Filter                                     *
    System.String EnableCompatibilityHttpListener                false
    System.String EnableCompatibilityHttpsListener               false
    System.String CertificateThumbprint
    System.String AllowRemoteAccess                              true
    #-=-=-=-=-=-=-=-=
    TSK: try it *without* AllowUnencrypted before opening it up
    # And don't forget to also enable Digest Authorization:
    set-item -force WSMan:\localhost\Service\Auth\Digest $true ;
    # (to allow the system to digest the new settings)
    TSK: I don't even see the path existing on the lab Ex651
    WSMan:\localhost\Service\Auth\Digest
    TSK: but winrm shows the config enabled with Digest:
    winrm get winrm/config/client
    #-=-=-=-=-=-=-=-=
    Client
      NetworkDelayms = 5000
      URLPrefix = wsman
      AllowUnencrypted = true
      Auth
          Basic = true
          Digest = true
          Kerberos = true
          Negotiate = true
          Certificate = true
          CredSSP = false
      DefaultPorts
          HTTP = 5985
          HTTPS = 5986
      TrustedHosts = LYNMS7330
    #-=-=-=-=-=-=-=-=
    #-=-=L650'S settings-=-=-=-=-=-=
    # SERVICE AUTH
    [PS] C:\scripts>winrm get winrm/config/service/auth
    Auth
        Basic = false
        Kerberos = true
        Negotiate = true
        Certificate = false
        CredSSP = false
        CbtHardeningLevel = Relaxed
    # SERVICE OVERALL
    [PS] C:\scripts>winrm get winrm/config/service
    Service
    RootSDDL = O:NSG:BAD:P(A;;GA;;;BA)S:P(AU;FA;GA;;;WD)(AU;SA;GWGX;;;WD)
    MaxConcurrentOperations = 4294967295
    MaxConcurrentOperationsPerUser = 15
    EnumerationTimeoutms = 60000
    MaxConnections = 25
    MaxPacketRetrievalTimeSeconds = 120
    AllowUnencrypted = false
    Auth
        Basic = false
        Kerberos = true
        Negotiate = true
        Certificate = false
        CredSSP = false
        CbtHardeningLevel = Relaxed
    DefaultPorts
        HTTP = 5985
        HTTPS = 5986
    IPv4Filter = *
    IPv6Filter = *
    EnableCompatibilityHttpListener = false
    EnableCompatibilityHttpsListener = false
    CertificateThumbprint
    #-=-=-=-=-=-=-=-=
    ==3:22 PM 9/17/2020:POST settings on CurlyHoward:
    #-=-=-=-=-=-=-=-=
    [PS] WSMan:\localhost\Client>winrm get winrm/config/client
    Client
        NetworkDelayms = 5000
        URLPrefix = wsman
        AllowUnencrypted = true
        Auth
            Basic = true
            Digest = true
            Kerberos = true
            Negotiate = true
            Certificate = true
            CredSSP = false
        DefaultPorts
            HTTP = 5985
            HTTPS = 5986
        TrustedHosts = LYNMS7330
    [PS] WSMan:\localhost\Client>winrm get winrm/config/client
    Client
        NetworkDelayms = 5000
        URLPrefix = wsman
        AllowUnencrypted = true
        Auth
            Basic = true
            Digest = true
            Kerberos = true
            Negotiate = true
            Certificate = true
            CredSSP = false
        DefaultPorts
            HTTP = 5985
            HTTPS = 5986
        TrustedHosts = LYNMS7330
    [PS] WSMan:\localhost\Client>winrm get winrm/config/service/auth
    Auth
        Basic = false
        Kerberos = true
        Negotiate = true
        Certificate = false
        CredSSP = false
        CbtHardeningLevel = Relaxed
    [PS] WSMan:\localhost\Client>winrm get winrm/config/service
    Service
        RootSDDL = O:NSG:BAD:P(A;;GA;;;BA)(A;;GR;;;IU)S:P(AU;FA;GA;;;WD)(AU;SA;GXGW;;;WD)
        MaxConcurrentOperations = 4294967295
        MaxConcurrentOperationsPerUser = 1500
        EnumerationTimeoutms = 240000
        MaxConnections = 300
        MaxPacketRetrievalTimeSeconds = 120
        AllowUnencrypted = true
        Auth
            Basic = false
            Kerberos = true
            Negotiate = true
            Certificate = false
            CredSSP = false
            CbtHardeningLevel = Relaxed
        DefaultPorts
            HTTP = 5985
            HTTPS = 5986
        IPv4Filter = *
        IPv6Filter = *
        EnableCompatibilityHttpListener = false
        EnableCompatibilityHttpsListener = false
        CertificateThumbprint
        AllowRemoteAccess = true
    #-=-=-=-=-=-=-=-=
    #-=-ABOVE SETTINGS VIA WSMAN: PSDRIVE=-=-=-=-=-=-=
    [PS] WSMan:\localhost\Client>cd WSMan:\localhost\Client ;
    [PS] WSMan:\localhost\Client>dir | format-table -auto ;
       WSManConfig: Microsoft.WSMan.Management\WSMan::localhost\Client
    Type          Name             SourceOfValue Value
    ----          ----             ------------- -----
    System.String NetworkDelayms                 5000
    System.String URLPrefix                      wsman
    System.String AllowUnencrypted               true
    Container     Auth
    Container     DefaultPorts
    System.String TrustedHosts                   LYNMS7330

    [PS] WSMan:\localhost\Client>cd WSMan:\localhost\Service
    [PS] WSMan:\localhost\Service>dir | format-table -auto ;
       WSManConfig: Microsoft.WSMan.Management\WSMan::localhost\Service
    Type          Name                             SourceOfValue Value
    ----          ----                             ------------- -----
    System.String RootSDDL                                       O:NSG:BAD:P(A;;GA;;;BA)(A;;GR;;;IU)S:P(AU;FA;GA;;;WD)(A...
    System.String MaxConcurrentOperations                        4294967295
    System.String MaxConcurrentOperationsPerUser                 1500
    System.String EnumerationTimeoutms                           240000
    System.String MaxConnections                                 300
    System.String MaxPacketRetrievalTimeSeconds                  120
    System.String AllowUnencrypted                               true
    Container     Auth
    Container     DefaultPorts
    System.String IPv4Filter                                     *
    System.String IPv6Filter                                     *
    System.String EnableCompatibilityHttpListener                false
    System.String EnableCompatibilityHttpsListener               false
    System.String CertificateThumbprint
    System.String AllowRemoteAccess                              true

    [PS] WSMan:\localhost\Service>cd WSMan:\localhost\Service\Auth\
    [PS] WSMan:\localhost\Service\Auth>dir | format-table -auto ;
       WSManConfig: Microsoft.WSMan.Management\WSMan::localhost\Service\Auth
    Type          Name              SourceOfValue Value
    ----          ----              ------------- -----
    System.String Basic                           false
    System.String Kerberos                        true
    System.String Negotiate                       true
    System.String Certificate                     false
    System.String CredSSP                         false
    System.String CbtHardeningLevel               Relaxed
    #-=-=-=-=-=-=-=-=
    # ^ clearly digest doesn't even exist in the list on the service\auth
    
    Need to set to permit Basic Auth too?
    cd .\Auth ;
    Set-Item Basic $True ;
    Check if the user you're connecting with has proper authorizations on the remote machine (triggers GUI after the confirm prompt; use -force to suppress).
    Set-PSSessionConfiguration -ShowSecurityDescriptorUI -Name Microsoft.PowerShell ;
    .PARAMETER  ExchangeServer
    Target Exchange Server[-ExchangeServer server.domain.com]
    .PARAMETER  Scriptblock
    Scriptblock/Command to be executed on target server[-ScriptBlock {Get-Mailbox | ft}]
    .PARAMETER  $Credential
    Credential object to be used for connection[-Credential cred]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass [-Whatif switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns objects returned to pipeline
    .EXAMPLE
    .\Invoke-ExchangeCommand.ps1
    .EXAMPLE
    .\Invoke-ExchangeCommand.ps1
    .LINK
    https://github.com/tostka/verb-Ex2010
    .LINK
    https://gallery.technet.microsoft.com/Exchange-Cross-Forest-e25d48eb
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true, HelpMessage = "Target Exchange Server[-ExchangeServer server.domain.com]")]
        [string] $ExchangeServer,
        [Parameter(Mandatory = $true, HelpMessage = "Scriptblock/Command to be executed[-ScriptBlock {Get-Mailbox | ft}]")]
        [string] $ScriptBlock,
        [Parameter(Mandatory = $true, HelpMessage = "Credentials [-Credential credobj]")]
        [System.Management.Automation.PSCredential] $Credential
    ) ;
    BEGIN {
        #${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        # Get parameters this function was invoked with
        #$PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        # silently stop any running transcripts
        $stopResults = try { Stop-transcript -ErrorAction stop } catch {} ;
        $WarningPreference = "SilentlyContinue" ;
    } ; # BEGIN-E
    PROCESS {
        $Error.Clear() ;
        #Connect to DC and pass through credential variable
        $pltICPS = @{
            ComputerName   = $ExchangeServer ;
            ArgumentList   = $Credential, $ExchangeServer, $ScriptBlock, $WarningPreference ;
            Credential     = $Credential ;
            Authentication = 'Negotiate'
        } ;
        write-verbose "Invoke-Command  w`n$(($pltICPS|out-string).trim())`n`$ScriptBlock:`n$(($ScriptBlock|out-string).trim())" ;
        #Invoke-Command -ComputerName $ExchangeServer -ArgumentList $Credential,$ExchangeServer,$ScriptBlock,$WarningPreference -Credential $Credential -Authentication Negotiate
        Invoke-Command @pltICPS -ScriptBlock {

                #Specify parameters
                param($Credential,$ExchangeServer,$ScriptBlock,$WarningPreference)

                #Create new PS Session
                $Session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri http://$ExchangeServer/PowerShell/ `
                -Authentication Kerberos -Credential $Credential

                #Import PS Session
                Import-PSSession $Session | Out-Null

                #Run commands
                foreach($Script in $ScriptBlock){
                    Invoke-Expression $Script
                }

                #Close all open sessions
                Get-PSSession | Remove-PSSession -Confirm:$false
            }
    } ; # PROC-E
    END {    } ; # END-E
}

#*------^ Invoke-ExchangeCommand.ps1 ^------


#*------v load-EMSLatest.ps1 v------
function load-EMSLatest {
  #  #Checks local machine for registred E20[13|10|07] EMS, and then loads the newest one found
  #Returns the string 2013|2010|2007 for reuse for version-specific code

  <#
  .SYNOPSIS
  load-EMSLatest - Checks local machine for registred E20[13|10|07] EMS, and then loads the newest one found.
  Attempts remote Ex2010 connection if no local EMS installed
  Returns the string 2013|2010|2007 for reuse for version-specific code
    .NOTES
  Author: Todd Kadrie
  Website:	http://tinstoys.blogspot.com
  Twitter:	http://twitter.com/tostka
  REVISIONS   :
  * 6:59 PM 1/15/2020 cleanup
  9:39 AM 2/4/2015 updated to remote to a local hub, updated latest TOR
    .INPUTS
  None. Does not accepted piped input.
    .OUTPUTS
  Returns version number connected to: [2013|2010|2007]
    .EXAMPLE
  .\load-EMSLatest
    .LINK
  #>

  # check registred & loaded ;
  $SnapsReg = Get-PSSnapin -Registered ;
  $SnapsLoad = Get-PSSnapin ;
  $Snapin13 = "Microsoft.Exchange.Management.PowerShell.E2013";
  $Snapin10 = "Microsoft.Exchange.Management.PowerShell.E2010";
  $Snapin7 = "Microsoft.Exchange.Management.PowerShell.Admin";
  # check/load E2013, E2010, or E2007, stop at newest (servers wouldn't be running multi-versions)
  if (($SnapsReg | where { $_.Name -eq $Snapin13 })) {
    if (!($SnapsLoad | where { $_.Name -eq $Snapin13 })) {
      Add-PSSnapin $Snapin13 -ErrorAction SilentlyContinue ; return "2013" ;
    }
    else {
      return "2013" ;
    } # if-E
  }
  elseif (($SnapsReg | where { $_.Name -eq $Snapin10 })) {
    if (!($SnapsLoad | where { $_.Name -eq $Snapin10 })) {
      Add-PSSnapin $Snapin10 -ErrorAction SilentlyContinue ; return "2010" ;
    }
    else {
      return "2010" ;
    } # if-E
  }
  elseif (($SnapsReg | where { $_.Name -eq $Snapin7 })) {
    if (!($SnapsLoad | where { $_.Name -eq $Snapin7 })) {
      Add-PSSnapin $Snapin7 -ErrorAction SilentlyContinue ; return "2007" ;
    }
    else {
      return "2007" ;
    } # if-E
  }
  else {
    Write-Verbose "Unable to locate Exchange tools on localhost, attempting to remote to Exchange 2010 server...";
    #Try implicit remoting-only works for Exchange 2010
    Try {
      # connect to a local hub (leverages ADSI function)
      $Ex2010Server = (Get-ExchangeServerInSite | ? { $_.Roles -match "^(36|38)$" })[0].fqdn
      $ExchangeSession = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri http://$Ex2010Server/PowerShell/ -ErrorAction Stop ;
      Import-PSSession $ExchangeSession -ErrorAction Stop;
    }
    Catch {
      Write-Host -ForegroundColor Red "Unable to import Exchange tools from $Exchange2010Server, is it running Exchange 2010?" ;
      Write-Host -ForegroundColor Magenta "Error:  $($Error[0])" ;
      Exit;
    } # try-E
  }# if-E
}

#*------^ load-EMSLatest.ps1 ^------


#*------v Load-EMSSnap.ps1 v------
function Load-EMSSnap {
  <#
    .SYNOPSIS
    Checks local machine for registred Exchange2010 EMS, and loads the component
    .NOTES
    Author: Todd Kadrie
    Website:	http://toddomation.com
    Twitter:	http://twitter.com/tostka

    REVISIONS   :
    # 11:20 AM 4/21/2021 fixed/suppressed noisy verbose calls
    # 8:34 AM 3/31/2021 added verbose suppress to all import-mods/add-Pssnapins
    * 6:59 PM 1/15/2020 cleanup
    vers: 9:39 AM 8/12/2015: retool into generic switched version to support both modules & snappins with same basic code ; building a stock EMS version (vs the fancier load-EMSSnapLatest)
    vers: 10:43 AM 1/14/2015 fixed return & syntax expl to true/false
    vers: 10:20 AM 12/10/2014 moved commentblock into function
    vers: 11:40 AM 11/25/2014 adapted to Lync
    ers: 2:05 PM 7/19/2013 typo fix in 2013 code
    vers: 1:46 PM 7/19/2013
    .INPUTS
    None.
    .OUTPUTS
    Outputs $true if successful. $false if failed.
    .EXAMPLE
    $EMSLoaded = Load-EMSSnap ; Write-Debug "`$EMSLoaded: $EMSLoaded" ;
    Stock free-standing Exchange Mgmt Shell load
    .EXAMPLE
    $EMSLoaded = Load-EMSSnap ; Write-Debug "`$EMSLoaded: $EMSLoaded" ; get-exchangeserver | out-null ;
    Example utilizing a workaround for bug in EMS, where loading ADMS causes Powershell/ISE to crash if ADMS is loaded after EMS, before EMS has executed any commands
    .EXAMPLE
    TRY {
        if(($host.version.major -lt 3) -AND (get-service MSExchangeADTopology -ea SilentlyContinue)){
                write-verbose -verbose:$bshowVerbose  "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Using Local Server EMS10 Snapin" ;
                $sName="Microsoft.Exchange.Management.PowerShell.E2010"; if (!(Get-PSSnapin | where {$_.Name -eq $sName})) {Add-PSSnapin $sName -ea Stop} ;
        } else {
             write-verbose -verbose:$bshowVerbose  "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Initiating REMS connection" ;
            $reqMods="connect-Ex2010;Disconnect-Ex2010;".split(";") ;
            $reqMods | % {if( !(test-path function:$_ ) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing $($_) function. EXITING." } } ;
            Reconnect-Ex2010 ;
        } ;
    } CATCH {
        Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
        Exit #STOP(debug)|EXIT(close)|Continue(move on in loop cycle) ;
    } ;
    Example demo'ing check for local psv2 & ADtopo svc to defer
    #>

  # check registred v loaded ;
  # style of plugin we want to test/load
  $PlugStyle = "Snapin"; # for Exch EMS
  #"Module" ; # for Lync/ADMS
  $PlugName = "Microsoft.Exchange.Management.PowerShell.E2010" ;

  switch ($PlugStyle) {
    "Module" {
      # module-style (for LMS or ADMS
      $PlugsReg = Get-Module -ListAvailable;
      $PlugsLoad = Get-Module;
    }
    "Snapin" {
      $PlugsReg = Get-PSSnapin -Registered ;
      $PlugsLoad = Get-PSSnapin ;
    }
  } # switch-E

  TRY {
    if ($PlugsReg | where { $_.Name -eq $PlugName }) {
      if (!($PlugsLoad | where { $_.Name -eq $PlugName })) {
        #
        switch ($PlugStyle) {
          "Module" {
            Import-Module $PlugName -ErrorAction Stop -verbose:$($false); write-output $TRUE ;
          }
          "Snapin" {
            Add-PSSnapin $PlugName -ErrorAction Stop -verbose:$($false); write-output $TRUE
          }
        } # switch-E
      }
      else {
        # already loaded
        write-output $TRUE;
      } # if-E
    }
    else {
      Write-Error { "$(Get-TimeStamp):($env:computername) does not have $PlugName installed!"; };
      #return $FALSE ;
      write-output $FALSE ;
    } # if-E ;
  } CATCH {
        Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
        Exit #STOP(debug)|EXIT(close)|Continue(move on in loop cycle) ;
  } ;

}

#*------^ Load-EMSSnap.ps1 ^------


#*------v new-MailboxGenericTOR.ps1 v------
function new-MailboxGenericTOR {

    <#
    .SYNOPSIS
    new-MailboxGenericTOR.ps1 - Wrapper/pre-processor function to create New shared Mbx (leverages new-MailboxShared generic function)
    .NOTES
    Version     : 1.1.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : http://twitter.com/tostka
    CreatedDate : 2021-05-11
    FileName    : new-MailboxGenericTOR.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-ex2010
    Tags        : Exchange,ExchangeOnPremises,Mailbox,Creation,Maintenance,UserMailbox
    REVISIONS
    # 2:46 PM 1/24/2025 add support for $OfficeOverride = 'Pune, IN' ; support for Office that doesn't match SITE OU code: $OfficeOverride = 'Pune, IN' ; 
    # 1:15 PM 9/6/2023 updated CBH, pulled in expls from 7PSnMbxG/psb-PSnewMbxG.cbp. Works with current cba auth etc. 
    # 10:30 AM 10/13/2021 pulled [int] from $ticket , to permit non-numeric & multi-tix
    * 11:37 AM 9/16/2021 string
    * 8:55 AM 5/11/2021 functionalized into verb-ex2010 ; ren: internal helper func Cleanup() -> _cleanup() ; subbed some wv -v:v,=> wh (silly to use wv, w force display; should use it solely for optional verbose details
    # 2:35 PM 4/3/2020 genericized for pub, moved material into infra, updated hybrid mod loads, cleaned up comments/remmed material ; updated to use start-log, debugged to funciton on jumpbox, w divided modules
    # 8:48 AM 11/26/2019 new-MailboxShared():moved the Office spec from $MbxSplat => $MbxSetSplat. New-Mailbox syntax set that supports -Shared, doesn't support -Office 
    # 12:10 PM 10/10/2019 default $mbxsplat.Office to $SiteCode value - they should always match, no reason to have a blank offic, if you know the OU & Site. Updated load-ADMS call to specific -cmdlets (speed)
    # 12:51 PM 10/4/2019 passing initial whatif on -Room
    # 2:22 PM 10/1/2019 2076 & 1549 added: $FallBackBaseUserOU, OU that's used when can't find any baseuser for the owner's OU, default to a random shared from SITECODE (avoid crapping out):
    # 9:48 AM 9/27/2019 new-MailboxShared:added `a 'beep' to YYY prompt
    # 1:47 PM 9/20/2019 switched to auto mailbox distribution (ALL TO SITECODE dbs)
    # 10:44 AM 6/18/2019 #2779, rem'd assign repl'd with explicit add
    # 12:52 PM 6/13/2019 repl get-timestamp with expanded cmd in remaining
    # 11:48 AM 6/13/2019 repl function cleanup() with the 10/2/18 vers
    # 11:46 AM 6/13/2019 updated write-log() with deferring verb-transcript.ps1 code
    # 8:04 AM 5/31/2019 2441 exempted EAS info reporting from shared/generic mailboxes (EAS isn't core supported by EXO, no sense pointing out it is onprem)
    # 11:17 AM 5/8/2019 spliced in updated hybrid baseuser resolve code from new-mailboxConfRm.ps1
    # 8:41 AM 4/30/2019 #2327: add lab support for UPN build fr email addr:
    # 2:19 PM 4/29/2019 add $($DomTOLfqdn) to the domain param validateset on get-gcfast copy (sync'd in from verb-ex2010.ps1 vers), lab psv2 LACKS the foreign-lang cleanup funtions below, exempt use on psv2
    # 10:39 AM 4/1/2019 added: Remove-StringDiacritic, Remove-StringLatinCharacters(), and purging non-AAD-syncable chars from upn, mail alias etc. Ran a test pass. Also pre-cleaning the fname/lname/dname before using it to build samaccountname. Debugged & ran fine, creating a mbx.
    # 11:15 AM 2/15/2019 copied in bug-fixed write-log() with fixed debug support
    # 10:41 AM 2/15/2019 updated write-log to latest deferring version
    # 2:26 PM 12/13/2018 SITECODE has all mbxs moved out, need to poll remotembxs for baseuser!
    # 10:00 AM 11/20/2018 major update, switched 99% of write-xxx to write-log support, so it now produces a realtime 'log' of the build of the mailbox. Better than transcript because it still logs the changes right up to crashes. And it's only the _relevant) changes.
    # downside: lacks color coding unless I want to code in WARNs, which would be logged as warns.
    # 12:04 PM 7/18/2018 made display of password conditional (!shared)
    # 10:28 AM 6/27/2018 add $domaincontroller param option - skips dc discovery process and uses the spec, also updated $findOU code to work with torolab dom
    # 10:59 AM 5/21/2018 Fixed broken -nongeneric $true functionality: (corrected samaccountname gen code for blank fname field). Also added Mailuser/RemoteMailbox support for -Owner value. Validated functional for creation of the LYNCmonacct1 mbx.
    # 11:25 AM 12/22/2017 missing casmailbox splat construct for psv2 section, update CU5 test regx for perrotde & perrotpl, output an error when it fails to find a BaseUser (new empty site with empty target OU to draw from, prompts to hand spec -BaseUser param with mbx in another OU or loc
    # 11:58 AM 11/15/2017 1321: accommodate EXO-hosted Owners by testing with get-remotemailbox -AND get-mailbox on the owner spec. Created a mailbox, seemed to work. Not sure of access grant script yet.
    # 11:43 AM 10/6/2017 made $Cu5 Mandatry:$false
    # 10:30 AM 10/6/2017 fix typo in $cu5 switch
    # 8:41 AM 10/6/2017 major re-splict to read lost set-mailbox (alt domain assignment) & set-casmailbox material. Need to splice this code
            into the other new-mailbox based scripts. This explains why nothing has been setting owner-based domains in recent (months)?.
    # 3:22 PM 10/4/2017 midway through adding CU5 support
    # 2:38 PM 6/22/2017 LastName too, strip all names back
    # 2:30 PM 6/22/2017 Mbx.Name attrib appears to be a 64char limit!
    # 12:49 PM 5/31/2017 add $NoPrompt
    # 8:18 AM 5/9/2017 fixed minotr #region/#endregion typos
    # 1:29 PM 4/3/2017 #1764: this should have the -server spec
    # 2:39 PM 3/21/2017 spliced over sitemailboxOU() from new-mailboxconfrm.ps1
    # 8:03 AM 3/16/2017 suppress error make sure the $($script:ExPSS).ID  is EVEN POPULATED!
    # 7:56 AM 3/16/2017 gadu need a dawdle loop, also add -server $(InputSplat.domaincontroller)
    # 9:48 AM 3/2/2017 merged in updated Add-EMSRemote Set
    # 1:30 PM 2/27/2017 neither vscan cu9 nor owner's cu5 values got properly populated.
    # 12:36 PM 2/27/2017 get-SiteMbxOU(): fixed to cover breaks frm AD reorg OU name changes, Generics are all now in a single OU per site
    # 1:04 PM 2/24/2017 tweak below
    #12:56 PM 2/24/2017 doesn't run worth a damn SITECODE-> $($ADSiteCodeAU)/$($ADSiteCodeUK), force it to abort (avoid half-built remote objects that take too long to replicate back to SITECODE)
    # 11:37 AM 2/24/2017 Reporting loop: add RecipientType,RecipientTypeDetails
    # 11:35 AM 2/24/2017 ran initial debug pass, may work.
    # # 11:09 AM 2/24/2017 DMG gone: switch generics to real shared mbxs "Shared" = $True / $Inputsplat.shared
    #* 9:11 AM 9/30/2016 added pretest if(get-command -name set-AdServerSettings -ea 0)
    # 10:38 AM 6/7/2016 tested debugged 378194, generic creation. Now has new UPN set based on Primary SMTP dirname@toro.com.
    # 8:17 AM 6/7/2016 fixed to missing )'s in the splat dummy refactor bloc
    # 7:51 AM 6/7/2016 roughed in retries, and if/then cleanupexit blocks to make more fault tolerant. Needs debugging
    # 12:51 PM 5/10/2016 updated debug BP blocks
    # 2:07 PM 4/8/2016 minor tweaking
    # 12:32 PM 4/8/2016 submain: added validation that an existing $script:ExPSS is actually functional, or forces an Add-Emsremote
    # 11:28 AM 4/8/2016 passed EMSRemote dynamic
    # 11:25 AM 4/8/2016 passed initial test on Ex EMS local
    # 11:22 AM 4/8/2016 I think I've finally got it properly managing EMSRemote, purging redudant, and outputing functional report. needs to be tested in Ex EMS local
    # 12:31 PM 4/6/2016 it's crapping out in local EMS on SITECODE-3V6KSY1 Add-EMSRemote isn't picking up on the existing verbs, and noclobber etc.
    # 12:29 PM 4/6/2016 validated Generic in rEMS
    # 12:23 PM 4/6/2016: seems functional for testing.
        Added Validate-Password, and looping pw gen, to generate consistently compliant complexity.
        Debugged through a lot of inconsistencies. I think it can now serve as the base template for other scripts.
        needs testing to confirm that the new Add-EMSRemote will work in EMS, rEMS, and v2ps EMS on servers.
    # 12:28 PM 4/1/2016 synced all $whatif tests against the std $bWhatif, not a mix
    # 11:39 AM 3/31/2016 ren Manager/ManagedBy -> Owner in splats, dropping ManagedBy use on AD Objects
    # 2:32 PM 3/22/2016 rem out ManagedBy support (need to implement Owner)
    # 1:12 PM 2/11/2016 fixed new bug in get-GCFast, wasn't detecting blank $site
    # 12:20 PM 2/11/2016 updated to standard EMS/AD Call block & Add-EMSRemote()
    # 11:31 AM 2/11/2016 updated [ordered] to exempt psv2
    #10:49 AM 2/11/2016: updated get-GCFast to current spec, updated any calls for "-site 'SITENAME'" to just default to local machine lookup
    # 7:40 AM Add-EMSRemote: 2/5/2016 another damn cls REM IT! I want to see all the connectivity info, switched wh->wv, added explicit echo's of what it's doing.
    # 11:08 AM 1/15/2016 re-updated Add-EMSRemote, using a -eq v -like with a wildcard string. Have to repush copies all over now. Also removed 2 Clear-Host's
    # 10:02 AM 1/13/2016: fixed cls bug due to spurious ";cls" included in the try/catch boilerplate: Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;cls => Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;
    # 1:48 PM 10/29/2015 fixed blank surname/givenname - was generic-only setting it. Also sub'd insput fname/lname for std firstname lastname field names (ported from new-mailboxCN.ps1)
    # 1:30 PM 10/29/2015: 780 get-aduser needs -server, fails:, also added -server to the get-AD* cmds missing it, and added XIA sitecode steering to the $OU find process
    # 2:07 PM 10/26/2015 had to split out the new-mailbox | set-mailbox, with a do/while wait for the mbx to be visible, in between, because the set wasn't finding a mbx, when it executed
    # 1:53 PM 10/26/2015 fixed failure to assign $InputSplat.SiteCode, for Generic mbxs
    # 12:24 PM 10/21/2015 added/debugged -Vscan YES|NO|null param. Created OEV\Generic\Test XXXOffboard mbx with it
    # 11:41 AM 10/21/2015 update clean-up param & help info
    # 11:32 AM 10/21/2015 613: added NonGeneric detect and trigger ResetPasswordOnNextLogon flag
    # 11:26 AM 10/21/2015 fixed rampant issues created by OEV's non-standard OU naming choices: had a Generic*Win7*Computers ou, that had to be one-off excluded, and also had GPOTest users that likewise had to be excluded to ensure only a single OU came through.
    # 9:40 AM 10/21/2015 #531:fix missing trailing )
    # 9:08 AM 10/14/2015 added debugpref maint code to get write-debug to work
    # 7:31 AM 10/14/2015 added -dc specs to all *-user & *-mailbox cmds, to ensure we're pulling back data from same dc that was updated in the set-* commands
    # 7:27 AM 10/14/2015 rplcd all get-timestamps -> $((get-date).ToString('HH:mm:ss'))
    # 1:12 PM 10/6/2015 updated to spec, looks functional
    # 10:49 AM 10/6/2015: updated vers of Get-AdminInitials
    * 2:48 PM 10/2/2015 updated Catch blocks to be specific on crash
    * 10:23 AM 10/2/2015 initial port from add-mbxaccessgrant & bp code

    .DESCRIPTION 
    new-MailboxGenericTOR.ps1 - Wrapper/pre-processor function to create New shared Mbx (leverages new-MailboxShared generic function)
    No service connectivity or module dependancies: Preprocesses the specified inputs into values suitable for the service-specific functions
    Typical intputs (can splat):
    ticket="355925";
    DisplayName="XXX Confirms" ;
    MInitial="" ;
    Owner="LOGON";
    BaseUser="AccountsReceivable";
    IsContractor=$false;
    NonGeneric=$true

    # splat entries
    ticket "355925";  DisplayName "XXX Confirms" ;  MInitial "" ;  Owner "LOGON";  BaseUser "AccountsReceivable";  IsContractor $false;  NonGeneric $true
    # equiv params use:
    -ticket "355925" -DisplayName "XXX Confirms"  -MInitial ""  -Owner "LOGON" -BaseUser "AccountsReceivable" -NonGeneric

    .PARAMETER DisplayName
    Display Name for mailbox ["fname lname","genericname"]
    .PARAMETER MInitial
    Middle Initial for mailbox (for non-Generic)["a"]
    .PARAMETER Owner
    Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]
    .PARAMETER SiteOverride
    Optionally specify a 3-letter Site Code. Used to force DL name/placement to vary from Owner's site)[3-letter Site code]
    .PARAMETER OfficeOverride
    Optionally specify an override Office value (assigned to mailbox Office, instead of SiteCode)['City, CN']
    .PARAMETER BaseUser
    Optionally specify an existing mailbox upon which to base the new mailbox & OU settings[name,emailaddr,alias]
    .PARAMETER Room
    Optional parameter indicating new mailbox Is Room-type[-Room `$true]
    .PARAMETER Equip
    Optional parameter indicating new mailbox Is Equipment-type[-Equip `$true]
    .PARAMETER NonGeneric
    Optionally specify new mailbox Is NON-Generic-type (defaults $false)[-NonGeneric $true]
    .PARAMETER IsContractor
    Parameter indicating new mailbox belongs to a Contractor[-IsContractor switch]
    .PARAMETER Vscan
    Parameter indicating new mailbox will have Vscan access (prompts if not specified)[-Vscan Yes|No|Null]
    .PARAMETER Cu5
    Optionally force CU5 (variant domain assign) [-Cu5 Exmark]
    .PARAMETER ticket
    Incident number for the change request[[int]nnnnnn]
    .PARAMETER domaincontroller
    Option to hardcode a specific DC [-domaincontroller xxxx]
    .PARAMETER TenOrg 
	TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']
	.PARAMETER Credential
	Credential to use for this connection [-credential [credential obj variable]")][System.Management.Automation.PSCredential]
	.PARAMETER UserRole
	Role of account (SID|CSID|UID|B2BI|CSVC|ESvc|LSvc)[-UserRole SID]
    .PARAMETER NoPrompt
    Suppress YYY confirmation prompts
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .PARAMETER NoOutput
    Switch to enable output (success/fail), defaults false, but adding to support tested function execution.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE 
    write-verbose "==SPLAT-DRIVEN, CREATE & IMMED GRANT & MIGRATE WRAPPER==" ; 
    write-verbose "For CU5 support, add to `$spltINPUTS hash: CU5='Exmark'" 
    write-verbose "CU5 OPTIONS: Exmark|Irritrol|IrritrolEurope|Lawn-boy|Lawngenie|Toro.be|TheToroCompany|Hayter|Toroused|EZLinkSupport|TheToroCo|Torodistributor|Dripirrigation|Toro.hu|Toro.co.uk|Torohosted|Uniquelighting|ToroExmark|RainMaster|Boss|perrotde|perrotpl"
    $whatIf=$true ;
    $spltINPUTS=@{
        ticket="TICKET" ;
        DisplayName="DNAME"  ;
        MInitial="" ;
        Owner="OWNER" ;
        showDebug=$true ;
        PermsDays=999 ;
        members="GRANTEE1,GRANTEE2";
    } ;
    if(!$dc){$dc=get-gcfast} ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):using common `$dc:$($dc)" ;
    $pltNmbx=[ordered]@{ ticket=$pltINPUTS.ticket ; DisplayName=$pltINPUTS.DisplayName  ; MInitial="" ; Owner=$pltINPUTS.Owner ; NonGeneric=$false  ; Vscan="YES" ; domaincontroller=$dc ; showDebug=$true ; whatIf=$($whatif) ; } ;
    if($pltINPUTS.Cu5){$pltNmbx.add("CU5",$pltINPUTS.CU5)} ;
    write-host -foregroundcolor green "`n$((get-date).ToString('HH:mm:ss')):`$pltINPUTS:`n$(($pltINPUTS|out-string).trim())" ;
    write-host -foregroundcolor green "`n$((get-date).ToString('HH:mm:ss')):new-MailboxGenericTOR w`n$(($pltNmbx|out-string).trim())" ;
    new-MailboxGenericTOR @pltNmbx;
    if(!$whatif){
        Do {write-host "." -NoNewLine; Start-Sleep -m (1000 * 5)} Until (($tmbx = get-mailbox $pltINPUTS.DisplayName -domaincontroller $dc )) ;
        if($tmbx){
            $pltGrant=[ordered]@{ ticket=$pltINPUTS.ticket  ; TargetID=$tmbx.samaccountname ; Owner=$pltINPUTS.Owner ; PermsDays=$pltINPUTS.PermsDays ; members=$pltINPUTS.members ; domaincontroller=$dc ; showDebug=$true ; whatIf=$whatif ; } ;
            write-host -foregroundcolor green "n$((get-date).ToString('HH:mm:ss')):add-MbxAccessGrant w`n$(($pltGrant|out-string).trim())" ;
            add-MbxAccessGrant @pltGrant ;
            caad ;
            write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):PREPARING DAWDLE LOOP!($($tmbx.PrimarySmtpAddress))`nAADLastSync:`n$((get-AADLastSync| ft -a TimeGMT,TimeLocal|out-string).trim())" ;
            Do {rxo ;  write-host "." -NoNewLine;  Start-Sleep -s 30} Until ((get-xorecipient $tmbx.PrimarySmtpAddress -EA 0)) ;
            write-host "`n*READY TO MOVE*!`a" ; sleep -s 1 ; write-host "*READY TO MOVE*!`a" ; sleep -s 1 ; write-host "*READY TO MOVE*!`a`n" ;
            write-host -foregroundcolor green "`n$((get-date).ToString('HH:mm:ss')):Running:`nmove-EXOmailboxNow.ps1 -TargetMailboxes $($tmbx.ALIAS) -showDebug -whatIf`n`n" ;
            . move-EXOmailboxNow.ps1 -TargetMailboxes $tmbx.ALIAS -showDebug -whatIf ;
            $strMoveCmd="move-EXOmailboxNow.ps1 -TargetMailboxes $($tmbx.ALIAS) -showDebug -NoTEST -whatIf:`$false" ;
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Move Command (copied to cb):`n`n$($strMoveCmd)`n" ;
            $strMoveCmd | out-clipboard ;
            $strCleanCmd="get-xomoverequest -BatchName ExoMoves-* | ?{`$_.status -eq 'Completed'} | Remove-xoMoveRequest -whatif" ;
            write-host -foregroundcolor green "`n$((get-date).ToString('HH:mm:ss')):Post-completion Cleanup Command :`n`n$($strCleanCmd)`n" ;
        } else { write-warning "No mbx found matching $($pltINPUTS.DisplayName). ABORTING"} ;
    } else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):(WHATIF skipping AMPG & move)" } ;
    BP Scriptblock that pre-parses basic $spltINPUTS inputs and feeds new-MailboxGenericTOR.ps1, add-MbxAccessGrant.ps1 & move-EXOmailboxNow.ps1 (normally stored in psb-PSnewMbxG.cbp)
    .EXAMPLE
    write-verbose "==BULK CREATE WITH CU5 SUPPORT + MBPG==" ; 
    write-verbose "- For dnames from email address: use '!' where you want a space to appear (is collapsed out for emailaddr, expanded to space for dname)" ; 
    write-verbose "- Also where any Capitals appear in email addr, it will trigger replacement of any ! with space, and it will use the address dirname _as Capitalized_, for the final Dname.
    write-verbose "   Otherwise it replaces all underscores & periods in the dname with spaces, and converts to TitleCase, to create final Dname"; 
    write-verbose "- If put period (.) in dname, this will use it in new-sharedmailbox to split fname/lname to drive requested address (where explicitly asked for an email w a fname.lname period).
    write-verbose "    Other wise, the displayname is pushed into the LName of the mailbox" ; 
    write-verbose "`$mbxs specs an array of semicolon-delim'd data PER NEW MAILBOX: [email@domain.com];[FwdContactAddr];[CU5Spec];[OWNERUPN];[COMMA-DELIM'D GRANTEE ADDRESSES]"  ; 
    write-verbose "Note: The FWDCONTACTADDR value ISN'T USED IN INITIAL MBX CREATE (CAN BE USED MANUALLY IF RECYCLING THE SAME SAME ARRAY TO LATER CREATE MAILCONTACTS)" ; 
    $whatif=$true ;
    [array]$mbxs="ADDR1@toro.com; NOFWD@NOTHING.COM; TORO; OWNER1; GRANTEE1A@toro.com,GRANTEE1B@toro.com" ;
    $mbxs+="ADDR2@toro.com; NOFWD@NOTHING.COM; TORO; OWNER2; GRANTEE2A@toro.com,GRANTEE2B@toro.com" ;
    $ticket="TICKETNO" ;
    $SiteOverride="LYN" ;
    if(!$dc){$dc=get-gcfast} ;
    $moveTargets=@() ;
    $sQot = [char]34 ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):using common `$dc:$($dc)" ;
    $cultTxt=$((Get-Culture).TextInfo) ;
    $ttl = ($mbxs|measure).count ;
    $Procd=0 ;
    foreach($mbx in $mbxs) {
        $dname,$fwd,$cu5,$owner,$grantees= $mbx.split(';').trim() ;
        write-verbose "detect periods, go into email address" ;
        if($dname.split('@')[0].contains('.')){
            write-host "Dname contains periods, preserving for inclusion in new-MailboxShared as period-delimtied email addr" ;
            write-verbose "if Dname (emladdr) contains any caps: Split at @ & take 1st half as Dname, replacing any ! with a space (no other capitalization chgs are made to the specified emladdr string" ; 
            write-verbose "if Dname (emladdr) does *not* contain any caps, split at @, take 1st half as Dname, and recapitalize as TitleCase (Fname Lname)" ; 
            if($dname -cmatch '([A-Z])'){$dname = $dname.split("@")[0].replace('!',' ')} else {  $dname =  $cultTxt.ToTitleCase(($dname.split("@")[0].replace("_"," ").toLower())) } ;
        }else{ ;
            if($dname -cmatch '([A-Z])'){$dname = $dname.split("@")[0].replace('!',' ')} else {  $dname =  $cultTxt.ToTitleCase(($dname.split("@")[0].replace("_"," ").replace("."," ").toLower()))} ;
        } ;
        $sBnr="#*======v ($($Procd)/$($ttl)):$($dname) v======" ;
        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
        $pltNmbx=[ordered]@{  ticket=$ticket ; DisplayName="$($dname)"  ; MInitial="" ; Owner=$owner ; SiteOverride=$SiteOverride ; NonGeneric=$false  ; Vscan="YES" ; NoPrompt=$true ; domaincontroller=$dc ; showDebug=$true ; whatIf=$($whatif) ; } ;
        if($cu5 -AND ($cu5 -ne "toro")){
            write-host -fore yellow "CU5:$($cu5): CUSTOM DOMAIN SPEC" ;
            $pltNmbx.add("CU5",$CU5) ;
        } ;
        write-host -foregroundcolor green "`n$((get-date).ToString('HH:mm:ss')):new-MailboxGenericTOR w`n$(($pltNmbx|out-string).trim())" ;
        new-MailboxGenericTOR @pltNmbx ;
        if(!($whatif)){
            write-host "waiting 10 secs..." ;
            start-sleep -seconds 10 ;
            Do {write-host "." -NoNewLine; Start-Sleep -m (1000 * 5)} Until (($tmbx = get-mailbox "$($dname)" -domaincontroller $dc -ea 0)) ;
            $pltGrant=[ordered]@{  ticket=$ticket  ; TargetID=$tmbx.samaccountname ; Owner=$owner ; PermsDays=999 ; members=$grantees ; NoPrompt=$true ; domaincontroller=$dc ; showDebug=$true  ; whatIf=$whatif ; } ;
            write-host -foregroundcolor green "n$((get-date).ToString('HH:mm:ss')):===add-MbxAccessGrant w`n$(($pltGrant|out-string).trim())" ;
            add-MbxAccessGrant @pltGrant ;
            $moveTargets+= $tmbx.alias ;
        } else {write-host -foregroundcolor green "(-whatif, skipping acc grant)" };
        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
    } ;
    if(!($whatif)){
        write-host -foregroundcolor green "===$((get-date).ToString('HH:mm:ss')):CONFIRMING PERMISSIONS:" ;
        foreach($movetarget in $movetargets) {
            write-host -foregroundcolor green "`n$((get-date).ToString('HH:mm:ss')):`Alias:$($movetarget):" ;
            get-mailboxpermission -identity "$($movetarget)" |?{$_.user -like 'toro*'}| select user;
        } ;
    } ;
    if(!($whatif) -AND $tmbx){
        caad ;
        write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):PREPARING DAWDLE LOOP!($($tmbx.PrimarySmtpAddress))`nAADLastSync:`n$((get-AADLastSync| ft -a TimeGMT,TimeLocal|out-string).trim())" ;
        Do {rxo ; write-host "." -NoNewLine; Start-Sleep -s 30} Until ((get-xorecipient $tmbx.PrimarySmtpAddress -EA 0)) ;
        write-host "`n*READY TO MOVE*!`a" ; sleep -s 1 ; write-host "*READY TO MOVE*!`a" ; sleep -s 1 ; write-host "*READY TO MOVE*!`a`n" ;
        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Running:`n`nmove-EXOmailboxNow.ps1 -TargetMailboxes $($sQot + ($moveTargets -join '","') + $sQot) -showDebug -whatIf`n`n" ;
        . move-EXOmailboxNow.ps1 -TargetMailboxes $moveTargets -showDebug -whatIf ;
        $strMoveCmd="move-EXOmailboxNow.ps1 -TargetMailboxes `$moveTargets -showDebug -NoTEST  -whatIf:`$false" ;
        write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):Move Command (copied to cb):`n`n$($strMoveCmd)`n" ;
        $strMoveCmd | out-clipboard ;
        $strCleanCmd="get-xomoverequest -BatchName ExoMoves-* | ?{`$_.status -eq 'Completed'} | Remove-xoMoveRequest -whatif" ;
        write-host -foregroundcolor green "`n$((get-date).ToString('HH:mm:ss')):Post-completion Cleanup Command :`n`n$($strCleanCmd)`n" ;
    } else { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):(WHATIF skipping AMPG & move)" } ;
    BP Scriptblock that permits bulk creation of a series of mailboxes, with explicit email addresses. DisplayName is generated as a variant of the email address (see verbose comments above for details). As per the prior expl, also waits for ADC repliction to complete, and then mocks up mailbox move to cloud.
    .EXAMPLE
    write-verbose "==MAILBOXES ARRAY AD-HOC REPORT (runs for each address in the $tmbxs array)==" ; 
    $tmbxs="MBX1@toro.com","MBX2@toro.com" ;
    foreach($tmbx in $tmbxs){
        write-host  "==$($tmbx)" ;
        $mbxo = get-mailbox -Identity $tmbx  ;
        $cmbxo= Get-CASMailbox -Identity $mbxo.samaccountname ;
        $aduprops="GivenName,Surname,Manager,Company,Office,Title,StreetAddress,City,StateOrProvince,c,co,countryCode,PostalCode,Phone,Fax,Description" ;
        $ADu = get-ADuser -Identity $mbxo.samaccountname-properties * | select *;
        write-host -foregroundcolor green "User Email:`t$(($mbxo.WindowsEmailAddress.tostring()).trim())" ;
        write-host -foregroundcolor green "Mailbox Information:" ;
        write-host -foregroundcolor green "$(($mbxo | select @{Name='LogonName';
        Expression={$_.SamAccountName }},Name,DisplayName,Alias,database,UserPrincipalName,RetentionPolicy,CustomAttribute5,CustomAttribute9,RecipientType,RecipientTypeDetails | out-string).trim())" ;
        write-host -foregroundcolor green "$(($Adu | select GivenName,Surname,Manager,Company,Office,Title,StreetAddress,City,StateOrProvince,c,co,countryCode,PostalCode,Phone,Fax,Description | out-string).trim())";
        write-host -foregroundcolor green "ActiveSyncMailboxPolicy:$($cmbxo.ActiveSyncMailboxPolicy.tostring())" ;
        write-host -foregroundcolor green "Description: $($Adu.Description.tostring())";
        write-host -foregroundcolor green "Info: $($Adu.info.tostring())";
        write-host -foregroundcolor green "Initial Password: $(($pltINPUTS.pass | out-string).trim())" ;
        $tmbx=$mbxo=$cmbxo=$aduprops=$ADu=$null;
        write-host "===========" ;
    } ;
    BP Scriptblock that outputs a summary report for each mailbox in the array (output resembles the output for the new-MailboxGenericTOR function)
    .EXAMPLE
    .\new-MailboxGenericTOR.ps1 -ticket "355925" -DisplayName "XXX Confirms"  -MInitial ""  -Owner "LOGON" -NonGeneric $true -showDebug -whatIf ;
    Testing syntax with explicit BaseUSer specified, Whatif test & Debug messages displayed:
    .EXAMPLE
    .\new-MailboxGenericTOR.ps1 -ticket "355925" -DisplayName "XXX Confirms"  -MInitial ""  -Owner "LOGON" -BaseUser "AccountsReceivable" -NonGeneric -showDebug -whatIf ;
    .EXAMPLE
    .\new-MailboxGenericTOR.ps1 -Ticket 99999 -DisplayName "TestScriptMbxRoom" -MInitial "" -Owner LOGON -NonGeneric $false -Room $true -SiteOverride SITECODE -Vscan YES -showDebug -whatif ;
    Testing syntax with Room resource mbx type specified, Whatif test & Debug messages displayed:
    .EXAMPLE
    .\new-MailboxGenericTOR.ps1 -Ticket 99999 -DisplayName "TestScriptMbxEquip" -MInitial "" -Owner LOGON -NonGeneric $false -Equip  $true -SiteOverride SITECODE -Vscan YES -showDebug -whatif ;
    Testing syntax with Equipment resource mbx type specified, Whatif test & Debug messages displayed:
    .LINK
    #>
    ## hosted w/in verb-Ex2010, 
    [CmdletBinding()]
    
    Param(
        [Parameter(Mandatory=$true,HelpMessage="Display Name for mailbox [fname lname,genericname]")]
            [string]$DisplayName,
        [Parameter(HelpMessage="Middle Initial for mailbox (for non-Generic)[a]")]
            [string]$MInitial,
        [Parameter(Mandatory=$true,HelpMessage="Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]")]
            [string]$Owner,
        [Parameter(HelpMessage="Optionally a specific existing mailbox upon which to base the new mailbox settings (default is to draw a random mbx from the target OU)[name,emailaddr,alias]")]
            [string]$BaseUser,
        [Parameter(HelpMessage="Optional parameter indicating new mailbox Is Room-type[-Room `$true]")]
            [bool]$Room,
        [Parameter(HelpMessage="Optional parameter indicating new mailbox Is Equipment-type[-Equip `$true]")]
            [bool]$Equip,
        [Parameter(HelpMessage="Optional parameter indicating new mailbox Is NonGeneric-type[-NonGeneric `$true]")]
            [bool]$NonGeneric,
        [Parameter(HelpMessage="Optional parameter indicating new mailbox belongs to a Contractor[-IsContractor switch]")]
            [switch]$IsContractor,
        [Parameter(HelpMessage="Optional parameter controlling Vscan (CU9) access (prompts if not specified)[-Vscan YES|NO|NULL]")]
            [string]$Vscan="YES",
        [Parameter(Mandatory=$false,HelpMessage="Optionally force CU5 (variant domain assign) [-Cu5 Exmark]")]
            [string]$Cu5,
        [Parameter(HelpMessage="Optionally specify a 3-letter Site Code o force OU placement to vary from Owner's current site[3-letter Site code]")]
            [string]$SiteOverride,
        # 2:49 PM 1/24/2025 add support for Office that doesn't match SITE OU code: $OfficeOverride = 'Pune, IN' ; 
        [Parameter(HelpMessage="Optionally specify an override Office value (assigned to mailbox Office, instead of SiteCode)['City, CN']")]
            [string]$OfficeOverride,
        [Parameter(Mandatory=$true,HelpMessage="Incident number for the change request[[int]nnnnnn]")]
            # [int] # 10:30 AM 10/13/2021 pulled, to permit non-numeric & multi-tix
            $Ticket,
        [Parameter(HelpMessage="Option to hardcode a specific DC [-domaincontroller xxxx]")]
            [string]$domaincontroller,
    	[Parameter(Mandatory=$FALSE,HelpMessage="TenantTag value, indicating Tenants to connect to[-TenOrg 'TOL']")]
	        [ValidateNotNullOrEmpty()]
	        $TenOrg = 'TOR',
	    [Parameter(HelpMessage="Credential to use for cloud actions [-credential [credential obj variable]")][System.Management.Automation.PSCredential]
	        $Credential,
	    [Parameter(Mandatory = $false, HelpMessage = "Credential User Role spec (SID|CSID|UID|B2BI|CSVC|ESVC|LSVC|ESvcCBA|CSvcCBA|SIDCBA)[-UserRole @('SIDCBA','SID','CSVC')]")]
            [ValidateSet('SID','CSID','UID','B2BI','CSVC')]
	        [string]$UserRole='SID',
        [Parameter(HelpMessage="Suppress YYY confirmation prompts [-NoPrompt]")]
            [switch] $NoPrompt,
        [Parameter(HelpMessage='Debugging Flag [$switch]')]
            [switch] $showDebug,
        [Parameter(HelpMessage='Whatif Flag [$switch]')]
            [switch] $whatIf,
        [Parameter(HelpMessage='NoOutput Flag [$switch]')]
            [switch] $NoOutput=$true
    ) ;
    #region CONSTANTS_AND_ENVIRO #*======v CONSTANTS_AND_ENVIRO v======
    $verbose = ($VerbosePreference -eq "Continue") ;

    # Get the name of this function
    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
    # Get parameters this function was invoked with
    $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;

    
    if ($Whatif){$bWhatif=$true ; write-host -foregroundcolor green "`$Whatif is $true (`$bWhatif:$bWhatif)" ; };
    # ISE also has not perfect but roughly equiv workingdir (unless script cd's):
    #$ExecutionContext.SessionState.Path.GetUnresolvedProviderPathFromPSPath('.\')
    
    write-verbose "`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;
    # most of this falls apart once you move a script to a module - all resolve to the module .ps(m|d)1 file, have to use ${CmdletName} for funcs, instead
    if ($psISE -AND (!($PSScriptRoot) -AND !($PSCommandPath))){
        $ScriptDir = Split-Path -Path $psISE.CurrentFile.FullPath ;
        $ScriptBaseName = split-path -leaf $psise.currentfile.fullpath ;
        $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($psise.currentfile.fullpath) ;
        $PSScriptRoot = $ScriptDir ;
        if($PSScriptRoot -ne $ScriptDir){ write-warning "UNABLE TO UPDATE BLANK `$PSScriptRoot TO CURRENT `$ScriptDir!"} ;
        $PSCommandPath = $psise.currentfile.fullpath ;
        if($PSCommandPath -ne $psise.currentfile.fullpath){ write-warning "UNABLE TO UPDATE BLANK `$PSCommandPath TO CURRENT `$psise.currentfile.fullpath!"} ;
    } else {
        if($host.version.major -lt 3){
            $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
            $PSCommandPath = $myInvocation.ScriptName ;
            $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
            $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
        } elseif($PSScriptRoot) {
            $ScriptDir = $PSScriptRoot ;
            if($PSCommandPath){
                $ScriptBaseName = split-path -leaf $PSCommandPath ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($PSCommandPath) ;
            } else {
                $PSCommandPath = $myInvocation.ScriptName ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } ;
        } else {
            if($MyInvocation.MyCommand.Path) {
                $PSScriptRoot = Split-Path $MyInvocation.MyCommand.Path -Parent ;
                $ScriptBaseName = (Split-Path -Leaf ((&{$myInvocation}).ScriptName))  ;
                $ScriptNameNoExt = [system.io.path]::GetFilenameWithoutExtension($MyInvocation.InvocationName) ;
            } else {
                throw "UNABLE TO POPULATE SCRIPT PATH, EVEN `$MyInvocation IS BLANK!" ;
            } ;
        } ;
    } ;
    write-verbose "`$ScriptDir:$($ScriptDir)`n`$ScriptBaseName:$($ScriptBaseName)`n`$ScriptNameNoExt:$($ScriptNameNoExt)`n`$PSScriptRoot:$($PSScriptRoot)`n`$PSCommandPath:$($PSCommandPath)" ;

    #  add password generator
    [Reflection.Assembly]::LoadWithPartialName("System.Web") | out-null ;

    # add retry support
    $Retries = 4 ; # number of re-attempts
    $RetrySleep = 5 ; # seconds to wait between retries
    # add CU5 validator 
    #$rgxCU5 = [moved to infra file] 

    # Clear error variable
    $Error.Clear() ;
    #endregion CONSTANTS_AND_ENVIRO ; #*------^ END CONSTANTS_AND_ENVIRO ^------

    #region FUNCTIONS ; # ------
    #*======v FUNCTIONS v======

    #-------v Function _cleanup v-------
    #make it defer to existing script-copy
    <#if(test-path function:Cleanup){
        "(deferring to `$script:cleanup())" ;
    } else {
        "(using default verb-transcript:cleanup())" ;
    #>
        function _cleanup {
            # clear all objects and exit
            # 8:55 AM 5/11/2021 ren: internal helper func Cleanup() -> _cleanup() 
            # 1:36 PM 11/16/2018 Cleanup:stop-transcriptlog left tscript running, test again and re-stop
            # 8:15 AM 10/2/2018 Cleanup:make it defer to $script:cleanup() (needs to be preloaded before verb-transcript call in script), added missing semis, replaced all $bDebug -> $showDebug
            # 2:02 PM 9/21/2018 missing $timestampnow, hardcode
            # 8:45 AM 10/13/2015 reset $DebugPreference to default SilentlyContinue, if on
            # # 8:46 AM 3/11/2015 at some time from then to 1:06 PM 3/26/2015 added ISE Transcript
            # 8:39 AM 12/10/2014 shifted to stop-transcriptLog function
            # 7:43 AM 1/24/2014 always stop the running transcript before exiting
            write-verbose "$((get-date).ToString('HH:mm:ss')):_cleanup" ; 
            #stop-transcript ;
            <#actually, with write-log in use, I don't even need cleanup /ISE logging, it's already covered in new-mailboxshared() etc)
            if($host.Name -eq "Windows PowerShell ISE Host"){
                # shift the logfilename gen out here, so that we can arch it
                #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -uformat "%Y%m%d-%H%M" ) + "-ISEtrans.log")) ;
                # shift to static timestamp $timeStampNow
                #$Logname= (join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + $timeStampNow + "-ISEtrans.log")) ;
                # missing $timestampnow, hardcode
                #$Logname=(join-path -path (join-path -path $scriptDir -childpath "logs") -childpath ($scriptNameNoExt + "-" + (get-date -format 'yyyyMMdd-HHmmtt') + "-ISEtrans.log")) ;
                #-=-=-=-=-=-=-=-=
                #$ParentPath = $MyInvocation.MyCommand.Definition ;
                $ParentPath = $PSCommandPath ; 
                if($ParentPath){
                    $rgxProfilePaths='(\\Documents\\WindowsPowerShell\\scripts|\\Program\sFiles\\windowspowershell\\scripts)' ;
                    if($ParentPath -match $rgxProfilePaths){
                        $ParentPath = "$(join-path -path 'c:\scripts\' -ChildPath (split-path $ParentPath -leaf))" ;
                    } ;
                    $logspec = start-Log -Path ($ParentPath) -showdebug:$($showdebug) -whatif:$($whatif) ;
                    if($logspec){
                        $logging=$logspec.logging ;
                        $logfile=$logspec.logfile ;
                        $Logname=$logspec.transcript ;
                    } else {$smsg = "Unable to configure logging!" ; write-warning "$((get-date).ToString('HH:mm:ss')):$($sMsg)" ; Exit ;} ;
                } else {$smsg = "No functional `$ParentPath found!" ; write-warning "$((get-date).ToString('HH:mm:ss')):$($sMsg)" ;  Exit ;} ;
                #-=-=-=-=-=-=-=-=
                $logname = $logname.replace(".log","-ISEtrans.log")
                write-host "`$Logname: $Logname";
                Start-iseTranscript -logname $Logname ;
                #Archive-Log $Logname ;
                # standardize processing file so that we can send a link to open the transcript for review
                $transcript = $Logname ;
            } else {
                write-verbose"$(Get-Date -Format 'HH:mm:ss'):Stop Transcript" ;
                Stop-TranscriptLog ;
                #write-verbose "$(Get-Date -Format 'HH:mm:ss'):Archive Transcript" ;
                #Archive-Log $transcript ;
                write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):`$transcript:$(($transcript|out-string).trim())" ;
            } # if-E
            # Cleanup:stop-transcriptlog left tscript running, test again and re-stop
            if (Test-Transcribing) {
                Stop-Transcript
                if ($showdebug) {write-host -foregroundcolor green "`$transcript:$transcript"} ;
            }  # if-E
            # add an exit comment
            #>
            write-host -foregroundcolor green "END $BARSD4 $scriptBaseName $BARSD4"  ;
            write-host -foregroundcolor green "$BARSD40" ;
            # finally restore the DebugPref if set
            if ($ShowDebug -OR ($DebugPreference = "Continue")) {
                write-host -foregroundcolor green "Resetting `$DebugPreference from 'Continue' back to default 'SilentlyContinue'" ;
                $showdebug=$false ;
                # also need to enable write-debug output (and turn this off at end of script, it's a global, normally SilentlyContinue)
                $DebugPreference = "SilentlyContinue" ;
            } # if-E
            exit ;
        #} ;
    } ; #*------^ END Function _cleanup ^------

    # moved new-MailboxShared => verb-Ex2010

    #*======^ END Functions ^======
    #endregion FUNCTIONS ; # ------

    #region SUBMAIN ; # ------
    #*======v SUB MAIN v======


    #$logging = $True ; # need to set in scope outside of functions
    $pltInput=[ordered]@{} ;

    if($PSCommandPath){$pltInput.add("ParentPath",$PSCommandPath) } ; 
    if($DisplayName){$pltInput.add("DisplayName",$DisplayName) } ;
    if($MInitial){$pltInput.add("MInitial",$MInitial) } ;
    if($Owner){$pltInput.add("Owner",$Owner) } ;
    if($BaseUser){$pltInput.add("BaseUser",$BaseUser) } ;
    if($IsContractor){$pltInput.add("IsContractor",$IsContractor) } ;
    # add room/equip support
    if($Room){$pltInput.add("Room",$Room) } ;
    if($Equip){$pltInput.add("Equip",$Equip) } ;
    if($Ticket){$pltInput.add("Ticket",$Ticket) } ;
    if($domaincontroller){$pltInput.add("domaincontroller",$domaincontroller) } ;
    if($NoPrompt){$pltInput.add("NoPrompt",$NoPrompt) } ;
    if($showDebug){$pltInput.add("showDebug",$showDebug) } ;
    if($verbose){$pltInput.add("verbose",$(($VerbosePreference -eq "Continue"))) } ;
    if($whatIf){$pltInput.add("whatIf",$whatIf) } ;
    # 2:59 PM 1/24/2025 new OfficeOverride
    if($OfficeOverride){
        if($pltInput.keys -contains 'OfficeOverride'){
            $pltInput.OfficeOverride=$OfficeOverride ; 
        }else{
            $pltInput.add('OfficeOverride',$OfficeOverride) ;  
        }
    };
    # only reset from defaults on explicit -NonGeneric $true param
    if($NonGeneric -eq $true){
        # switching over generics to real 'shared' mbxs: "Shared" = $True
    } else {
        # force it if not true
        $NonGeneric=$false;
        #$pltInput.NonGeneric=$false
        # rem'd above in favor of below
    } ;
    if($NonGeneric){$pltInput.add("NonGeneric",$NonGeneric) } ;

    # vscan
    if ($Vscan){
        if ($Vscan -match "(?i:^(YES|NO)$)" ) {
            $Vscan = $Vscan.ToString().ToUpper() ;
            if($Vscan){$pltInput.add("Vscan",$Vscan) } ;
        } else {
            $Vscan = $null ;
            #$pltInput.Vscan=$Vscan ;
            # force em  on all, no reason not to have external email!
            if($Vscan){$pltInput.add("Vscan","YES") } ;
        }  ;
    }; # If not explicit yes/no, prompt for input

    # Cu5 override support (normally inherits from assigned owner/manager)
    if ($Cu5){
        #$pltInput.Cu5=$Cu5;
        # looks like it's adding on assign (?.?)7
        if($Cu5){$pltInput.add("Cu5",$Cu5) } ;
    } else {
        $pltInput.add("Cu5",$null) ;
    }  ;
    
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):new-MailboxShared w`n$(($pltInput|out-string).trim())" ;
    if(-not($NoOutput)){
        $bRet = new-MailboxShared @pltInput ; 
        $bRet | write-output ;
    } else { 
        new-MailboxShared @pltInput
    } ; 
    # shift exit work into _cleanup function ;
    #_cleanup ;
    #Exit ;

    #*======^ END SUB MAIN ^======
    #endregion SUBMAIN ; # ------
}

#*------^ new-MailboxGenericTOR.ps1 ^------


#*------v new-MailboxShared.ps1 v------
function new-MailboxShared {
    <#
    .SYNOPSIS
    new-MailboxShared.ps1 - Create New Generic Mbx
    .NOTES
    Version     : 1.0.2
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2020-
    FileName    : new-MailboxShared.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite:	URL
    AddedTwitter:	URL
    REVISIONS
    # 2:46 PM 1/24/2025 add support for $OfficeOverride = 'Pune, IN' ; support for Office that doesn't match SITE OU code: $OfficeOverride = 'Pune, IN' ; 
    # 10:56 AM 4/12/2024 fix: echo typo 889:FIRSTNAME -> LASTNAME
    # 2:36 PM 8/2/2023 have to bump up password complexity - revised policy., it does support fname.lname naming & email addreses, just have to pass in dname with period. but the dname will also come out with the same period (which if they specified the eml, implies they don't mind if the name has it)
    # 10:30 AM 10/13/2021 pulled [int] from $ticket , to permit non-numeric & multi-tix
    # 10:01 AM 9/14/2021 had a random creation bug - but debugged fine in ISE (bad PSS?), beefed up Catch block outputs, captured new-mailbox output & recycled; added 7pswhsplat outputs prior to cmds.
    # 4:37 PM 5/18/2021 fixed broken start-log call (wasn't recycling logspec into logfile & transcrpt)
    # 11:10 AM 5/11/2021 swapped parentpath code for dyn module-support code (moving the new-mailboxgenerictor & add-mbxaccessgrant preproc .ps1's to ex2010 mod functions)
    # 1:52 PM 5/5/2021 added dot-divided displayname support (split fname & lname for generics, to auto-gen specific requested eml addresses) ; diverted parentpath log pref to d: before c: w test; untested code
    # 8:34 AM 3/31/2021 added verbose suppress to all import-mods
    # 1:29 PM 4/23/2020 updated dynpath & logging, unwrapped loadmod,
    # 4:28 PM 4/22/2020 updated logging code, to accomodate dynamic locations and $ParentPath
    # 4:36 PM 4/8/2020 works fully on jumpbox, but ignores whatif, renamed $bwhatif -> $whatif (as the b variant was prev set in the same-script, now separate scopes); swapped out CU5 switch, moved settings into infra file, genericized
    # 2:15 PM 4/7/2020 updated to reflect debugging on jumpbox
    # 2:35 PM 4/3/2020 new-MailboxShared: genericized for pub, moved material into infra, updated hybrid mod loads, cleaned up comments/remmed material ; updated to use start-log, debugged to funciton on jumpbox, w divided modules ; added -ParentPath to pass through a usable path for start-log, within new-mailboxshared()
    # 8:48 AM 11/26/2019 new-MailboxShared():moved the Office spec from $MbxSplat => $MbxSetSplat. New-Mailbox syntax set that supports -Shared, doesn't support -Office
    # 12:14 PM 10/4/2019 splice in Room/Equip code from new-mailboxConfRm.ps1's variant (not functionalized yet), added new -Room & -Equipement flags to trigger ConfRm code
    # 2:22 PM 10/1/2019 2076 & 1549 added: $FallBackBaseUserOU, OU that's used when can't find any baseuser for the owner's OU, default to a random shared from SITECODE (avoid crapping out):
    # 9:48 AM 9/27/2019 new-MailboxShared:added `a 'beep' to YYY prompt
    # 1:47 PM 9/20/2019 switched to auto mailbox distribution (ALL TO SITECODE dbs)
    # 12:06 PM 6/12/2019 functionalized version new-MailboxGenericTOR.ps1 => new-MailboxShared
    # 8:04 AM 5/31/2019 2441 exempted EAS info reporting from shared/generic mailboxes (EAS isn't core supported by EXO, no sense pointing out it is onprem)
    # 11:17 AM 5/8/2019 spliced in updated hybrid baseuser resolve code from new-mailboxConfRm.ps1
    # 8:41 AM 4/30/2019 #2327: add lab support for UPN build fr email addr:
    # 2:19 PM 4/29/2019 add $($DomTOLfqdn) to the domain param validateset on get-gcfast copy (sync'd in from verb-ex2010.ps1 vers), lab psv2 LACKS the foreign-lang cleanup funtions below, exempt use on psv2
    # 10:39 AM 4/1/2019 added: Remove-StringDiacritic, Remove-StringLatinCharacters(), and purging non-AAD-syncable chars from upn, mail alias etc. Ran a test pass. Also pre-cleaning the fname/lname/dname before using it to build samaccountname. Debugged & ran fine, creating a mbx.
    # 11:15 AM 2/15/2019 copied in bug-fixed write-log() with fixed debug support
    # 10:41 AM 2/15/2019 updated write-log to latest deferring version
    # 2:26 PM 12/13/2018 SITECODE has all mbxs moved out, need to poll remotembxs for baseuser!
    # 10:00 AM 11/20/2018 major update, switched 99% of write-xxx to write-log support, so it now produces a realtime 'log' of the build of the mailbox. Better than transcript because it still logs the changes right up to crashes. And it's only the _relevant) changes.
    # downside: lacks color coding unless I want to code in WARNs, which would be logged as warns.
    # 12:04 PM 7/18/2018 made display of password conditional (!shared)
    # 10:28 AM 6/27/2018 add $domaincontroller param option - skips dc discovery process and uses the spec, also updated $findOU code to work with TOL dom
    # 10:59 AM 5/21/2018 Fixed broken -nongeneric $true functionality: (corrected samaccountname gen code for blank fname field). Also added Mailuser/RemoteMailbox support for -Owner value. Validated functional for creation of the LYNCmonacct1 mbx.
    # 11:25 AM 12/22/2017 missing casmailbox splat construct for psv2 section, update CU5 test regx for perrotde & perrotpl, output an error when it fails to find a BaseUser (new empty site with empty target OU to draw from, prompts to hand spec -BaseUser param with mbx in another OU or loc
    # 11:58 AM 11/15/2017 1321: accommodate EXO-hosted Owners by testing with get-remotemailbox -AND get-mailbox on the owner spec. Created a mailbox, seemed to work. Not sure of access grant script yet.
    # 11:43 AM 10/6/2017 made $Cu5 Mandatry:$false
    # 10:30 AM 10/6/2017 fix typo in $cu5 switch
    # 8:41 AM 10/6/2017 major re-splict to read lost set-mailbox (alt domain assignment) & set-casmailbox material. Need to splice this code
            into the other new-mailbox based scripts. This explains why nothing has been setting owner-based domains in recent (months)?.
    # 3:22 PM 10/4/2017 midway through adding CU5 support
    # 2:38 PM 6/22/2017 LastName too, strip all names back
    # 2:30 PM 6/22/2017 Mbx.Name attrib appears to be a 64char limit!
    # 12:49 PM 5/31/2017 add $NoPrompt
    # 8:18 AM 5/9/2017 fixed minotr #region/#endregion typos
    # 1:29 PM 4/3/2017 #1764: this should have the -server spec
    # 2:39 PM 3/21/2017 spliced over sitemailboxOU() from new-mailboxconfrm.ps1
    # 8:03 AM 3/16/2017 suppress error make sure the $($script:ExPSS).ID  is EVEN POPULATED!
    # 7:56 AM 3/16/2017 gadu need a dawdle loop, also add -server $(InputSplat.domaincontroller)
    # 9:48 AM 3/2/2017 merged in updated Add-EMSRemote Set
    # 1:30 PM 2/27/2017 neither vscan cu9 nor owner's cu5 values got properly populated.
    # 12:36 PM 2/27/2017 get-SiteMbxOU(): fixed to cover breaks frm AD reorg OU name changes, Generics are all now in a single OU per site
    # 1:04 PM 2/24/2017 tweak below
    #12:56 PM 2/24/2017 doesn't run worth a damn SITECODE-> $($ADSiteCodeAU)/$($ADSiteCodeUK), force it to abort (avoid half-built remote objects that take too long to replicate back to SITECODE)
    # 11:37 AM 2/24/2017 Reporting loop: add RecipientType,RecipientTypeDetails
    # 11:35 AM 2/24/2017 ran initial debug pass, may work.
    # # 11:09 AM 2/24/2017 DMG gone: switch generics to real shared mbxs "Shared" = $True / $Inputsplat.shared
    #* 9:11 AM 9/30/2016 added pretest if(get-command -name set-AdServerSettings -ea 0)
    # 10:38 AM 6/7/2016 tested debugged 378194, generic creation. Now has new UPN set based on Primary SMTP dirname@DOMAIN.com.
    # 8:17 AM 6/7/2016 fixed to missing )'s in the splat dummy refactor bloc
    # 7:51 AM 6/7/2016 roughed in retries, and if/then cleanupexit blocks to make more fault tolerant. Needs debugging
    # 12:51 PM 5/10/2016 updated debug BP blocks
    # 2:07 PM 4/8/2016 minor tweaking
    # 12:32 PM 4/8/2016 submain: added validation that an existing $script:ExPSS is actually functional, or forces an Add-Emsremote
    # 11:28 AM 4/8/2016 passed EMSRemote dynamic
    # 11:25 AM 4/8/2016 passed initial test on Ex EMS local
    # 11:22 AM 4/8/2016 I think I've finally got it properly managing EMSRemote, purging redudant, and outputing functional report. needs to be tested in Ex EMS local
    # 12:31 PM 4/6/2016 it's crapping out in local EMS on SITECODE-3V6KSY1 Add-EMSRemote isn't picking up on the existing verbs, and noclobber etc.
    # 12:29 PM 4/6/2016 validated Generic in rEMS
    # 12:23 PM 4/6/2016: seems functional for testing.
        Added Validate-Password, and looping pw gen, to generate consistently compliant complexity.
        Debugged through a lot of inconsistencies. I think it can now serve as the base template for other scripts.
        needs testing to confirm that the new Add-EMSRemote will work in EMS, rEMS, and v2ps EMS on servers.
    # 12:28 PM 4/1/2016 synced all $whatif tests against the std $bWhatif, not a mix
    # 11:39 AM 3/31/2016 ren Manager/ManagedBy -> Owner in splats, dropping ManagedBy use on AD Objects
    # 2:32 PM 3/22/2016 rem out ManagedBy support (need to implement Owner)
    # 1:12 PM 2/11/2016 fixed new bug in get-GCFast, wasn't detecting blank $site
    # 12:20 PM 2/11/2016 updated to standard EMS/AD Call block & Add-EMSRemote()
    # 11:31 AM 2/11/2016 updated [ordered] to exempt psv2
    #10:49 AM 2/11/2016: updated get-GCFast to current spec, updated any calls for "-site 'lyndale'" to just default to local machine lookup
    # 7:40 AM Add-EMSRemote: 2/5/2016 another damn cls REM IT! I want to see all the connectivity info, switched wh->wv, added explicit echo's of what it's doing.
    # 11:08 AM 1/15/2016 re-updated Add-EMSRemote, using a -eq v -like with a wildcard string. Have to repush copies all over now. Also removed 2 Clear-Host's
    # 10:02 AM 1/13/2016: fixed cls bug due to spurious ";cls" included in the try/catch boilerplate: Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;cls => Write-Error "$((get-date).ToString('HH:mm:ss')): Command: $($_.InvocationInfo.MyCommand)" ;
    # 1:48 PM 10/29/2015 fixed blank surname/givenname - was generic-only setting it. Also sub'd insput fname/lname for std firstname lastname field names (ported from new-mailboxCN.ps1)
    # 1:30 PM 10/29/2015: 780 get-aduser needs -server, fails:, also added -server to the get-AD* cmds missing it, and added XIA sitecode steering to the $OU find process
    # 2:07 PM 10/26/2015 had to split out the new-mailbox | set-mailbox, with a do/while wait for the mbx to be visible, in between, because the set wasn't finding a mbx, when it executed
    # 1:53 PM 10/26/2015 fixed failure to assign $InputSplat.SiteCode, for Generic mbxs
    # 12:24 PM 10/21/2015 added/debugged -Vscan YES|NO|null param. Created OEV\Generic\Test XXXOffboard mbx with it
    # 11:41 AM 10/21/2015 update clean-up param & help info
    # 11:32 AM 10/21/2015 613: added NonGeneric detect and trigger ResetPasswordOnNextLogon flag
    # 11:26 AM 10/21/2015 fixed rampant issues created by OEV's non-standard OU naming choices: had a Generic*Win7*Computers ou, that had to be one-off excluded, and also had GPOTest users that likewise had to be excluded to ensure only a single OU came through.
    # 9:40 AM 10/21/2015 #531:fix missing trailing )
    # 9:08 AM 10/14/2015 added debugpref maint code to get write-debug to work
    # 7:31 AM 10/14/2015 added -dc specs to all *-user & *-mailbox cmds, to ensure we're pulling back data from same dc that was updated in the set-* commands
    # 7:27 AM 10/14/2015 rplcd all get-timestamps -> $((get-date).ToString('HH:mm:ss'))
    # 1:12 PM 10/6/2015 updated to spec, looks functional
    # 10:49 AM 10/6/2015: updated vers of Get-AdminInitials
    * 2:48 PM 10/2/2015 updated Catch blocks to be specific on crash
    * 10:23 AM 10/2/2015 initial port from add-mbxaccessgrant & bp code
.DESCRIPTION
new-MailboxShared.ps1 - Create New Generic Mbx
.PARAMETER DisplayName
    Display Name for mailbox ["fname lname","genericname"]
    .PARAMETER MInitial
    Middle Initial for mailbox (for non-Generic)["a"]
    .PARAMETER Owner
    Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]
    .PARAMETER SiteOverride
    Optionally specify a 3-letter Site Code. Used to force DL name/placement to vary from Owner's site)[3-letter Site code]
    .PARAMETER OfficeOverride
    Optionally specify an override Office value (assigned to mailbox Office, instead of SiteCode)['City, CN']
    .PARAMETER BaseUser
    Optionally specify an existing mailbox upon which to base the new mailbox & OU settings[name,emailaddr,alias]
    .PARAMETER Room
    Optional parameter indicating new mailbox Is Room-type[-Room `$true]
    .PARAMETER Equip
    Optional parameter indicating new mailbox Is Equipment-type[-Equip `$true]
    .PARAMETER NonGeneric
    Optionally specify new mailbox Is NON-Generic-type (defaults $false)[-NonGeneric $true]
    .PARAMETER IsContractor
    Parameter indicating new mailbox belongs to a Contractor[-IsContractor switch]
    .PARAMETER Vscan
    Parameter indicating new mailbox will have Vscan access (prompts if not specified)[-Vscan Yes|No|Null]
    .PARAMETER Cu5
    Optionally force CU5 (variant domain assign) [-Cu5 Exmark]
    .PARAMETER ticket
    Incident number for the change request[[int]nnnnnn]
    .PARAMETER domaincontroller
    Option to hardcode a specific DC [-domaincontroller xxxx]
    .PARAMETER ParentPath
    Calling script path (used for log construction)[-ParentPath c:\pathto\script.ps1]
    .PARAMETER NoPrompt
    Suppress YYY confirmation prompts
    .PARAMETER Whatif
    Parameter to run a Test no-change pass, and log results [-Whatif switch]
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    new-MailboxShared.ps1 -ticket "355925" -DisplayName "XXX Confirms"  -MInitial ""  -Owner "LOGON" -NonGeneric $true -showDebug -whatIf ;
    Testing syntax with explicit BaseUSer specified, Whatif test & Debug messages displayed:
    .EXAMPLE
    new-MailboxShared.ps1 -ticket "355925" -DisplayName "XXX Confirms"  -MInitial ""  -Owner "LOGON" -BaseUser "AccountsReceivable" -NonGeneric -showDebug -whatIf ;
    Testing syntax with no explict BaseUSer specified (draws random from Generic OU of Owner's Site), Whatif test & Debug messages displayed:
    .EXAMPLE
    #-=-=-=-=-=-=-=-=
    $logging = $True ; # need to set in scope outside of functions
    $pltInput=[ordered]@{} ;
    if($DisplayName){$pltInput.add("DisplayName",$DisplayName) } ;
    if($MInitial){$pltInput.add("MInitial",$MInitial) } ;
    if($Owner){$pltInput.add("Owner",$Owner) } ;
    if($BaseUser){$pltInput.add("BaseUser",$BaseUser) } ;
    if($IsContractor){$pltInput.add("IsContractor",$IsContractor) } ;
    if($Room){$pltInput.add("Room",$Room) } ;
    if($Equip){$pltInput.add("Equip",$Equip) } ;
    if($Ticket){$pltInput.add("Ticket",$Ticket) } ;
    if($domaincontroller){$pltInput.add("domaincontroller",$domaincontroller) } ;
    if($NoPrompt){$pltInput.add("NoPrompt",$NoPrompt) } ;
    if($showDebug){$pltInput.add("showDebug",$showDebug) } ;
    if($whatIf){$pltInput.add("whatIf",$whatIf) } ;
    # only reset from defaults on explicit -NonGeneric $true param
    if($NonGeneric -eq $true){
        # switching over generics to real 'shared' mbxs: "Shared" = $True
    } else {
        # force it if not true
        $NonGeneric=$false;
    } ;
    if($NonGeneric){$pltInput.add("NonGeneric",$NonGeneric) } ;
    if ($Vscan){
        if ($Vscan -match "(?i:^(YES|NO)$)" ) {
            $Vscan = $Vscan.ToString().ToUpper() ;
            if($Vscan){$pltInput.add("Vscan",$Vscan) } ;
        } else {
            $Vscan = $null ;
            #$pltInput.Vscan=$Vscan ;
            # 1:32 PM 2/27/2017 force em  on all, no reason not to have external email!
            if($Vscan){$pltInput.add("Vscan","YES") } ;
        }  ;
    }; # If not explicit yes/no, prompt for input
    # Cu5 override support (normally inherits from assigned owner/manager)
    if ($Cu5){
        if($Cu5){$pltInput.add("Cu5",$Cu5) } ;
    } else {
        $pltInput.add("Cu5",$null) ;
    }  ;
    write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):new-MailboxShared w`n$(($pltInput|out-string).trim())" ;
    new-MailboxShared @pltInput
    CleanUp ;
    #-=-=-=-=-=-=-=-=
    Full prod call code (from new-MailboxGenericTOR.ps1)
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$true,HelpMessage="Display Name for mailbox [fname lname,genericname]")]
          [string]$DisplayName,
        [Parameter(HelpMessage="Middle Initial for mailbox (for non-Generic)[a]")]
          [string]$MInitial,
        [Parameter(Mandatory=$true,HelpMessage="Specify the userid to be responsible for access-grant-approvals[name,emailaddr,alias]")]
          [string]$Owner,
        [Parameter(HelpMessage="Optionally a specific existing mailbox upon which to base the new mailbox settings (default is to draw a random mbx from the target OU)[name,emailaddr,alias]")]
          [string]$BaseUser,
        [Parameter(HelpMessage="Optional parameter indicating new mailbox Is Room-type[-Room `$true]")]
          [bool]$Room,
        [Parameter(HelpMessage="Optional parameter indicating new mailbox Is Equipment-type[-Equip `$true]")]
          [bool]$Equip,
        [Parameter(HelpMessage="Optional parameter indicating new mailbox Is NonGeneric-type[-NonGeneric `$true]")]
          [bool]$NonGeneric,
        [Parameter(HelpMessage="Optional parameter indicating new mailbox belongs to a Contractor[-IsContractor switch]")]
          [switch]$IsContractor,
        [Parameter(HelpMessage="Optional parameter controlling Vscan (CU9) access (prompts if not specified)[-Vscan YES|NO|NULL]")]
          [string]$Vscan="YES",
        [Parameter(Mandatory=$false,HelpMessage="Optionally force CU5 (variant domain assign) [-Cu5 Exmark]")]
          [string]$Cu5,
        [Parameter(HelpMessage="Optionally specify a 3-letter Site Code o force OU placement to vary from Owner's current site[3-letter Site code]")]
          [string]$SiteOverride,
        # 2:49 PM 1/24/2025 add support for Office that doesn't match SITE OU code: $OfficeOverride = 'Pune, IN' ; 
        [Parameter(HelpMessage="Optionally specify an override Office value (assigned to mailbox Office, instead of SiteCode)['City, CN']")]
            [string]$OfficeOverride,
        [Parameter(Mandatory=$true,HelpMessage="Incident number for the change request[[int]nnnnnn]")]
          # [int] # 10:30 AM 10/13/2021 pulled, to permit non-numeric & multi-tix
          $Ticket,
        [Parameter(HelpMessage="Option to hardcode a specific DC [-domaincontroller xxxx]")]
          [string]$domaincontroller,
        [Parameter(HelpMessage="Calling script path (used for log construction)[-ParentPath c:\pathto\script.ps1]")]
          [string]$ParentPath,
        [Parameter(HelpMessage="Suppress YYY confirmation prompts [-NoPrompt]")]
          [switch] $NoPrompt,
        [Parameter(HelpMessage='Debugging Flag [$switch]')]
          [switch] $showDebug,
        [Parameter(HelpMessage='Whatif Flag [$switch]')]
          [switch] $whatIf
    ) ;

    BEGIN {
        $verbose = ($VerbosePreference -eq "Continue") ;
        # Get the name of this function
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        # Get parameters this function was invoked with
        $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
        $continue = $true ;
        switch -regex ($env:COMPUTERNAME){
            ($rgxMyBoxW){ $LocalInclDir="c:\usr\work\exch\scripts" ; }
            ($rgxProdEx2010Servers){ $LocalInclDir="c:\scripts" ; }
            ($rgxLabEx2010Servers){ $LocalInclDir="c:\scripts" ; }
            ($rgxProdL13Servers){ $LocalInclDir="c:\scripts" ; }
            ($rgxLabL13Servers){ $LocalInclDir="c:\scripts" ; }
        } ;
        $Retries = 4 ; # number of re-attempts
        $RetrySleep = 5 ; # seconds to wait between retries
        # $rgxCU5 = [infra file]
        # OU that's used when can't find any baseuser for the owner's OU, default to a random shared from ($ADSiteCodeUS) (avoid crapping out):
        $FallBackBaseUserOU = "$($DomTORfqdn)/($ADSiteCodeUS)/Generic Email Accounts" ;

        # strings are: "[tModName];[tModFile];tModCmdlet"
        $tMods = @() ;
        #$tMods+="verb-Auth;C:\sc\verb-Auth\verb-Auth\verb-Auth.psm1;get-password" ;
        $tMods+="verb-logging;C:\sc\verb-logging\verb-logging\verb-logging.psm1;write-log";
        $tMods+="verb-IO;C:\sc\verb-IO\verb-IO\verb-IO.psm1;Add-PSTitleBar" ;
        $tMods+="verb-Mods;C:\sc\verb-Mods\verb-Mods\verb-Mods.psm1;check-ReqMods" ;
        #$tMods+="verb-Desktop;C:\sc\verb-Desktop\verb-Desktop\verb-Desktop.psm1;Speak-words" ;
        #$tMods+="verb-dev;C:\sc\verb-dev\verb-dev\verb-dev.psm1;Get-CommentBlocks" ;
        $tMods+="verb-Text;C:\sc\verb-Text\verb-Text\verb-Text.psm1;Remove-StringDiacritic" ;
        #$tMods+="verb-Automation.ps1;C:\sc\verb-Automation.ps1\verb-Automation.ps1\verb-Automation.ps1.psm1;Retry-Command" ;
        #$tMods+="verb-AAD;C:\sc\verb-AAD\verb-AAD\verb-AAD.psm1;Build-AADSignErrorsHash";
        $tMods+="verb-ADMS;C:\sc\verb-ADMS\verb-ADMS\verb-ADMS.psm1;load-ADMS";
        $tMods+="verb-Ex2010;C:\sc\verb-Ex2010\verb-Ex2010\verb-Ex2010.psm1;Connect-Ex2010";
        #$tMods+="verb-EXO;C:\sc\verb-EXO\verb-EXO\verb-EXO.psm1;Connect-Exo";
        #$tMods+="verb-L13;C:\sc\verb-L13\verb-L13\verb-L13.psm1;Connect-L13";
        $tMods+="verb-Network;C:\sc\verb-Network\verb-Network\verb-Network.psm1;Send-EmailNotif";
        #$tMods+="verb-Teams;C:\sc\verb-Teams\verb-Teams\verb-Teams.psm1;Connect-Teams";
        #$tMods+="verb-SOL;C:\sc\verb-SOL\verb-SOL\verb-SOL.psm1;Connect-SOL" ;
        #$tMods+="verb-Azure;C:\sc\verb-Azure\verb-Azure\verb-Azure.psm1;get-AADBearToken" ;
        foreach($tMod in $tMods){
            $tModName = $tMod.split(';')[0] ;             $tModFile = $tMod.split(';')[1] ;             $tModCmdlet = $tMod.split(';')[2] ;
            $smsg = "( processing `$tModName:$($tModName)`t`$tModFile:$($tModFile)`t`$tModCmdlet:$($tModCmdlet) )" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            if($tModName -eq 'verb-Network' -OR $tModName -eq 'verb-Text' -OR $tModName -eq 'verb-IO'){
                write-host "GOTCHA!:$($tModName)" ;
            } ;
            $lVers = get-module -name $tModName -ListAvailable -ea 0 ;
            if($lVers){                 $lVers=($lVers | Sort-Object version)[-1];                 try {                     import-module -name $tModName -RequiredVersion $lVers.Version.tostring() -force -DisableNameChecking -verbose:$($false)                }   catch {                      write-warning "*BROKEN INSTALLED MODULE*:$($tModName)`nBACK-LOADING DCOPY@ $($tModDFile)" ;import-module -name $tModDFile -force -DisableNameChecking -verbose:$($false)                } ;
            } elseif (test-path $tModFile) {                 write-warning "*NO* INSTALLED MODULE*:$($tModName)`nBACK-LOADING DCOPY@ $($tModDFile)" ;                 try {import-module -name $tModDFile -force -DisableNameChecking -verbose:$($false)}                 catch {                     write-error "*FAILED* TO LOAD MODULE*:$($tModName) VIA $(tModFile) !" ;                     $tModFile = "$($tModName).ps1" ;                     $sLoad = (join-path -path $LocalInclDir -childpath $tModFile) ;                     if (Test-Path $sLoad) {                         write-verbose ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;                         . $sLoad ;                         if ($showdebug) { write-verbose "Post $sLoad" };                     } else {                         $sLoad = (join-path -path $backInclDir -childpath $tModFile) ;                         if (Test-Path $sLoad) {                             write-verbose ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;                             . $sLoad ;                             if ($showdebug) { write-verbose "Post $sLoad" };                         } else {                             Write-Warning ((Get-Date).ToString("HH:mm:ss") + ":MISSING:" + $sLoad + " EXITING...") ;                             exit;                         } ;                     } ;                 } ;             } ;
            if(!(test-path function:$tModCmdlet)){                 write-warning "UNABLE TO VALIDATE PRESENCE OF $tModCmdlet`nfailing through to `$backInclDir .ps1 version" ;                 $sLoad = (join-path -path $backInclDir -childpath "$($tModName).ps1") ;                 if (Test-Path $sLoad) {                     write-verbose ((Get-Date).ToString("HH:mm:ss") + "LOADING:" + $sLoad) ;                     . $sLoad ;                     if ($showdebug) { write-verbose "Post $sLoad" };                     if(!(test-path function:$tModCmdlet)){                         write-warning "$((get-date).ToString('HH:mm:ss')):FAILED TO CONFIRM `$tModCmdlet:$($tModCmdlet) FOR $($tModName)" ;                     } else {                         write-verbose  "(confirmed $tModName loaded: $tModCmdlet present)"                     }                 } else {                     Write-Warning ((Get-Date).ToString("HH:mm:ss") + ":MISSING:" + $sLoad + " EXITING...") ;                     exit;                 } ;
            } else {                 write-verbose  "(confirmed $tModName loaded: $tModCmdlet present)"             } ;
        } ;  # loop-E
        #*------^ END MOD LOADS ^------

        <# rem, shifting preprocessor to module, loses $parentpath function, (resolves to module file in allusers context)
        if($ParentPath){
            $rgxProfilePaths='(\\Documents\\WindowsPowerShell\\scripts|\\Program\sFiles\\windowspowershell\\scripts)' ;
            if($ParentPath -match $rgxProfilePaths){
                if(test-path -Path 'd:\scripts\'){
                    $ParentPath = "$(join-path -path 'd:\scripts\' -ChildPath (split-path $ParentPath -leaf))" ;
                }else{
                    $ParentPath = "$(join-path -path 'c:\scripts\' -ChildPath (split-path $ParentPath -leaf))" ;
                } ; 
            } ;
            $logspec = start-Log -Path ($ParentPath) -showdebug:$($showdebug) -whatif:$($whatif) -tag $DisplayName;
            if($logspec){
                $logging=$logspec.logging ;
                $logfile=$logspec.logfile ;
                $transcript=$logspec.transcript ;
            } else {$smsg = "Unable to configure logging!" ; write-warning "$((get-date).ToString('HH:mm:ss')):$($sMsg)" ; Exit ;} ;
        } else {$smsg = "No functional `$ParentPath found!" ; write-warning "$((get-date).ToString('HH:mm:ss')):$($sMsg)" ;  Exit ;} ;
        #>
        # detect profile installs (installed mod or script), and redir to stock location
        $dPref = 'd','c' ; foreach($budrv in $dpref){ if(test-path -path "$($budrv):\scripts" -ea 0 ){ break ;  } ;  } ;
        [regex]$rgxScriptsModsAllUsersScope="^$([regex]::escape([environment]::getfolderpath('ProgramFiles')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
        [regex]$rgxScriptsModsCurrUserScope="^$([regex]::escape([environment]::getfolderpath('Mydocuments')))\\((Windows)*)PowerShell\\(Scripts|Modules)" ;
        # -Tag "($TenOrg)-LASTPASS" 
        $pltSLog = [ordered]@{ NoTimeStamp=$false ; Tag=$lTag  ; showdebug=$($showdebug) ;whatif=$($whatif) ;} ;
        if($PSCommandPath){
            if(($PSCommandPath -match $rgxScriptsModsAllUsersScope) -OR ($PSCommandPath -match $rgxScriptsModsCurrUserScope) ){
                # AllUsers or CU installed script, divert into [$budrv]:\scripts (don't write logs into allusers context folder)
                if($PSCommandPath -match '\.ps(d|m)1$'){
                    # module function: use the ${CmdletName} for childpath
                    $pltSLog.Path= (join-path -Path "$($budrv):\scripts" -ChildPath "$(${CmdletName}).ps1" )  ;
                } else { 
                    $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
                } ; 
            }else {
                $pltSLog.Path=$PSCommandPath ;
            } ;
        } else {
            if( ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsAllUsersScope) -OR ($MyInvocation.MyCommand.Definition -match $rgxScriptsModsCurrUserScope) ){
                $pltSLog.Path=(join-path -Path "$($budrv):\scripts" -ChildPath (split-path $PSCommandPath -leaf)) ;
            } else {
                $pltSLog.Path=$MyInvocation.MyCommand.Definition ;
            } ;
        } ;
        $smsg = "start-Log w`n$(($pltSLog|out-string).trim())" ;
        if($verbose){ if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        $logspec = start-Log @pltSLog ;
        if($logspec){
            $logging=$logspec.logging ;
            $logfile=$logspec.logfile ;
            $transcript=$logspec.transcript ;

            if($whatif){
                $logfile=$logfile.replace("-BATCH","-BATCH-WHATIF") ;
                $transcript=$transcript.replace("-BATCH","-BATCH-WHATIF") ;
            } else {
                $logfile=$logfile.replace("-BATCH","-BATCH-EXEC") ;
                $transcript=$transcript.replace("-BATCH","-BATCH-EXEC") ;
            } ;
            if($Ticket){
                $logfile=$logfile.replace("-BATCH","-$($Ticket)") ;
                $transcript=$transcript.replace("-BATCH","-$($Ticket)") ;
            } else {
                $logfile=$logfile.replace("-BATCH","-nnnnnn") ;
                $transcript=$transcript.replace("-BATCH","-nnnnnn") ;
            } ;

            if(Test-TranscriptionSupported){
                $stopResults = try {Stop-transcript -ErrorAction stop} catch {} ;
                start-transcript -Path $transcript ;
            } ;
        } else {throw "Unable to configure logging!" } ;

        

        $xxx="====VERB====";
        $xxx=$xxx.replace("VERB","NewMbx") ;
        $BARS=("="*10);

        $reqMods+="Add-PSTitleBar;Remove-PSTitleBar".split(";") ;
        $reqMods+="Test-TranscriptionSupported;Test-Transcribing;Stop-TranscriptLog;Start-IseTranscript;Start-TranscriptLog;get-ArchivePath;Archive-Log;Start-TranscriptLog".split(";") ;
        $reqMods=$reqMods| Select-Object -Unique ;

        #region SPLATDEFS ; # ------
        # dummy hashes
        if($host.version.major -ge 3){
            $InputSplat=[ordered]@{
                Dummy = $null ;
            } ;
            $MbxSplat=[ordered]@{
                Dummy = $null ;
            } ;
            $MbxSetSplat=[ordered]@{
                Dummy = $null ;
            } ;
            $MbxSetCASmbx=[ordered]@{
                Dummy = $null ;
            } ;
            $ADSplat=[ordered]@{
                Dummy = $null ;
            } ;
            $UsrSplat=[ordered]@{
                Dummy = $null ;
            } ;
        } else {
            $InputSplat=@{
                Dummy = $null ;
            } ;
            $MbxSplat=@{
                Dummy = $null ;
            } ;
            $MbxSetSplat=@{
                Dummy = $null ;
            } ;
            $MbxSetCASmbx=@{
                Dummy = $null ;
            } ;
            $ADSplat=@{
                Dummy = $null ;
            } ;
            $UsrSplat=@{
                Dummy = $null ;
            } ;
        } ;
        # then immediately remove the dummy value:
        $InputSplat.remove("Dummy") ;
        $MbxSplat.remove("Dummy") ;
        $MbxSetSplat.remove("Dummy") ;
        $ADSplat.remove("Dummy") ;
        $UsrSplat.remove("Dummy") ;
        # 8:08 AM 10/6/2017 add missing CASMailbox splat
        $MbxSetCASmbx.remove("Dummy") ;

        # also, less code post-decl to populate the $hash with fields, post creation:
        #$InputSplat.Add("NewField",$($NewValue)) ;
        $InputSplat.Add("Ticket",$($null)) ;
        $InputSplat.Add("DisplayName",$("")) ;
        $InputSplat.Add("MInitial",$("")) ;
        $InputSplat.Add("Owner",$("")) ;
        $InputSplat.Add("OwnerMbx",$($null)) ;
        $InputSplat.Add("BaseUser",$("")) ;
        $InputSplat.Add("IsContractor",$($false)) ;
        $InputSplat.Add("NonGeneric",$($false)) ;
        $InputSplat.Add("Vscan",$($null)) ;
        $InputSplat.Add("BUserAD",$($null)) ;
        $InputSplat.Add("ADDesc",$($null)) ;
        $InputSplat.Add("Domain",$($null)) ;
        $InputSplat.Add("DomainController",$($null)) ;
        $InputSplat.Add("SiteName",$($null)) ;
        $InputSplat.Add("OrganizationalUnit",$($null)) ;

        #$MbxSplat.Add("OrganizationalUnit",$($null)) ;
        $MbxSplat.Add("Shared",$($null)) ;
        $MbxSplat.Add("Name",$($null)) ;
        $MbxSplat.Add("DisplayName",$($null)) ;
        $MbxSplat.Add("userprincipalname",$($null)) ;
        $MbxSplat.Add("OrganizationalUnit", $($null)) ;
        #$MbxSplat.Add("Office", $($null)) ;
        # new-mailbox syntax set that includes -shared DOESN'T include -office!, move it to MbxSetSplat
        $MbxSplat.Add("database",$($null)) ;
        $MbxSplat.Add("password",$($null)) ;
        $MbxSplat.Add("FirstName",$($null)) ;
        $MbxSplat.Add("Initials",$($null));
        $MbxSplat.Add("LastName",$($null)) ;
        $MbxSplat.Add("samaccountname",$($null)) ;
        $MbxSplat.Add("alias",$($null)) ;
        $MbxSplat.Add("ResetPasswordOnNextLogon",$($false));
        $MbxSplat.Add("RetentionPolicy",$($TORMeta['RetentionPolicy'])) ;
        $MbxSplat.Add("ActiveSyncMailboxPolicy",$('Default')) ;
        $MbxSplat.Add("domaincontroller",$($null)) ;
        $MbxSplat.Add("whatif",$true) ;

        $MbxSetSplat.Add("identity",$($null)) ;
        $MbxSetSplat.Add("CustomAttribute9",$($null)) ;
        $MbxSetSplat.Add("CustomAttribute5",$($null)) ;
        $MbxSetSplat.Add("Office", $($null)) ; # 8:44 AM 11/26/2019 shifted unsupported syntax mix from new-mailbox to set-mailbox
        $MbxSetSplat.Add("domaincontroller",$($null)) ;
        $MbxSetSplat.Add("whatif",$true) ;

        # CASMailbox splat
        $MbxSetCASmbx.Add("identity",$($null)) ;
        $MbxSetCASmbx.Add("ActiveSyncMailboxPolicy",$($null)) ;
        $MbxSetCASmbx.Add("domaincontroller",$($null)) ;
        $MbxSetCASmbx.Add("whatif",$true) ;

        $ADSplat.Add("manager",$($null)) ;
        $ADSplat.Add("Description",$($null)) ;
        $ADSplat.Add("Server",$($null)) ;
        $ADSplat.Add("identity",$($null)) ;
        $ADSplat.Add("whatif",$($true)) ;

        $UsrSplat.Add("whatif",$($true)) ;
        $UsrSplat.Add("City",$($null)) ;
        $UsrSplat.Add("CountryOrRegion",$($null)) ;
        $UsrSplat.Add("Fax",$($null)) ;
        $UsrSplat.Add("Office",$($null)) ;
        $UsrSplat.Add("PostalCode",$($null)) ;
        $UsrSplat.Add("StateOrProvince",$($null)) ;
        $UsrSplat.Add("StreetAddress",$($null)) ;
        $UsrSplat.Add("Title",$($null)) ;
        $UsrSplat.Add("Phone",$($null)) ;
        $UsrSplat.Add("domaincontroller",$($null)) ;

        # start stocking in params into $InputSplat
        if($DisplayName){$InputSplat.DisplayName=$DisplayName};
        if($MInitial){$InputSplat.MInitial=$MInitial};
        if($Owner){$InputSplat.Owner=$Owner};

        if($BaseUser){$InputSplat.BaseUser=$BaseUser};
        # only reset from defaults on explicit -NonGeneric $true param
        if($NonGeneric -eq $true){

        } else {
            # force it if not true
            $NonGeneric=$false;
        } ;
        $InputSplat.NonGeneric=$NonGeneric
        if($IsContractor){$InputSplat.IsContractor=$IsContractor};

        if ($Vscan){
            if ($Vscan -match "(?i:^(YES|NO)$)" ) {
                $Vscan = $Vscan.ToString().ToUpper() ;
                $InputSplat.Vscan=$Vscan ;
            } else {
                $Vscan = $null ;
                $InputSplat.Vscan="YES";
            }  ;
        };

        # 3:07 PM 10/4/2017 Cu5 override support (normally inherits from assigned owner/manager)
        if ($Cu5){
            if ($Cu5 -match $rgxCU5 ) {
                # pulled switch out, it wasn't actually translating, just rgx of the final tags
                $InputSplat.Cu5=$Cu5;
            } else {
                $InputSplat.Cu5=$null ;
            }  ;
        }; #  # if-E Cu5


        if($SiteOverride){
            if($InputSplat.keys -contains 'SiteOverride'){
                $InputSplat.SiteOverride=$SiteOverride ; 
            }else{
                $InputSplat.add('SiteOverride',$SiteOverride) ;  
            }
        };
        # 2:59 PM 1/24/2025 new OfficeOverride
        if($OfficeOverride){
            if($InputSplat.keys -contains 'OfficeOverride'){
                $InputSplat.OfficeOverride=$OfficeOverride ; 
            }else{
                $InputSplat.add('OfficeOverride',$OfficeOverride) ;  
            }
        };
        if($Ticket){$InputSplat.Ticket=$Ticket};


        #endregion SPLATDEFS ; # ------
        #region LOADMODS ; # ------
        $rgxExoPsHostName="^(ps\.outlook\.com|outlook\.office365\.com)$" ;
        #$rgxEx10HostName=[infra file]
        $rgxRemsPssName="^(Exchange2010|Session\sfor\simplicit\sremoting\smodule\sat\s.*)" ;
        $rgxSnapPssname="^Session\d{1}$" ;
        $rgxEx2010SnapinName="^Microsoft\.Exchange\.Management\.PowerShell\.E2010$";
        $Ex2010SnapinName="Microsoft.Exchange.Management.PowerShell.E2010" ;

        #
        #LEMS detect: IdleTimeout -ne -1
        if(get-pssession |Where-Object{($_.configurationname -eq 'Microsoft.Exchange') -AND ($_.ComputerName -match $rgxEx10HostName) -AND ($_.IdleTimeout -ne -1)} ){
            write-verbose  "$((get-date).ToString('HH:mm:ss')):LOCAL EMS detected" ;
            $Global:E10IsDehydrated=$false ;
        # REMS detect dleTimeout -eq -1
        } elseif(get-pssession |Where-Object{$_.configurationname -eq 'Microsoft.Exchange' -AND $_.ComputerName -match $rgxEx10HostName -AND ($_.IdleTimeout -eq -1)} ){
            write-verbose  "$((get-date).ToString('HH:mm:ss')):REMOTE EMS detected" ;
            $reqMods+="get-GCFast;Get-ExchangeServerInSite;connect-Ex2010;Reconnect-Ex2010;Disconnect-Ex2010;Disconnect-PssBroken".split(";") ;
            if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
            reconnect-ex2010 ;
            $Global:E10IsDehydrated=$true ;
        } else {
            write-verbose  "$((get-date).ToString('HH:mm:ss')):No existing Ex2010 Connection detected" ;
            # Server snapin defer
            if(($host.version.major -lt 3) -AND (get-service MSExchangeADTopology -ea SilentlyContinue)){
                write-verbose "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Loading Local Server EMS10 Snapin" ;
                $reqMods+="Load-EMSSnap;load-EMSLatest".split(";") ;
                if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
                Load-EMSSnap ;
                $Global:E10IsDehydrated=$false ;
            } else {
                # if you want REMS - (assumed on new scripts)
                $reqMods+="connect-Ex2010;Reconnect-Ex2010;Disconnect-Ex2010;Get-ExchangeServerInSite;Disconnect-PssBroken".split(";") ;
                if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
                reconnect-ex2010 ;
                $Global:E10IsDehydrated=$true ;
            } ;
        } ;
        #

        # load ADMS
        $reqMods+="load-ADMS;get-AdminInitials".split(";") ;
        if( !(check-ReqMods $reqMods) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing function. EXITING." ; exit ;}  ;
        write-host -foregroundcolor darkgray "$((get-date).ToString('HH:mm:ss')):(loading ADMS...)" ;
        load-ADMS -cmdlet get-aduser,Set-ADUser,Get-ADGroupMember,Get-ADDomainController,Get-ADObject,get-adforest | out-null ;

        $AdminInits=get-AdminInitials ;

        #region LOADMODS ; # ------

    }  # BEG-E ;

    PROCESS {

        #region DATAPREP ; # ------
        if ( ($InputSplat.OwnerMbx=(get-mailbox -identity $($InputSplat.Owner) -ea 0)) -OR ($InputSplat.OwnerMbx=(get-remotemailbox -identity $($InputSplat.Owner) -ea 0)) ){

        } else {
          throw "Unable to resolve $($InputSplat.Owner) to any existing OP or EXO mailbox" ;
          Cleanup ; Exit ;
        } ;

        $InputSplat.Domain=$($InputSplat.OwnerMbx.identity.tostring().split("/")[0]) ;
        $InputSplat.SiteCode=($InputSplat.OwnerMbx.identity.tostring().split('/')[1]) ;

        $domain=$InputSplat.Domain ;
        if(!$domaincontroller){
            $domaincontroller =(get-gcfast -domain $domain) ;
        } else {
            $smsg= "Using hard-coded domaincontroller:$($domaincontroller)" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
        } ;
        $InputSplat.DomainController=$domaincontroller ;

        $MbxSplat.DomainController=$($InputSplat.DomainController) ;
        $MbxSetSplat.DomainController=$($InputSplat.DomainController) ;
        $ADSplat.Server=$($InputSplat.DomainController) ;
        $UsrSplat.DomainController=$($InputSplat.DomainController) ;

        if($InputSplat.SiteOverride){
            $SiteCode=$($InputSplat.SiteOverride);
            # force the $InputSplat.SiteCode to match the override too
            $InputSplat.SiteCode=$($InputSplat.SiteOverride);
        } else {
            $SiteCode=$InputSplat.SiteCode.tostring();
        } ;

        If($InputSplat.NonGeneric) {
            if ( $MbxSplat.OrganizationalUnit = (Get-SiteMbxOU  -Sitecode $SiteCode -Generic $false)   ) {

            } else { Cleanup ; Exit ;}
        } elseIf($Room -OR $Equipement) {
            if ( $MbxSplat.OrganizationalUnit = (Get-SiteMbxOU  -Sitecode $SiteCode -Resource $true ) ) {
            } else { Cleanup ; Exit ;}
        } else {
            if ( $MbxSplat.OrganizationalUnit = (Get-SiteMbxOU  -Sitecode $SiteCode -Generic $true ) ) {
            } else { Cleanup ; Exit ;}
        }

        # add forced office designation, to match $SiteCode/OU
        # New-Mailbox doesn't support both -Shared & -Office in the same syntax set, move it to $MbxSetSplat
        
        # 2:53 PM 1/24/2025 exempt OfficeOverride
        if($InputSplat.OfficeOverride){
            $smsg = "-OfficeOverride:$($InputSplat.OfficeOverride): overriding user object Office from SiteCode to specified Override!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
            $MbxSetSplat.Office = $InputSplat.OfficeOverride ;
        } else { 
            $MbxSetSplat.Office = $SiteCode ;
        } ; 
        $smsg= "Site Located:`$SiteCode:$SiteCode`n`$OrganizationalUnit:$($MbxSplat.OrganizationalUnit)" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn


        if(Get-ADObject $($MbxSplat.OrganizationalUnit) -server $($InputSplat.Domain)){
            $InputSplat.SiteName=$($SiteCode) ;
            $InputSplat.OrganizationalUnit=$($MbxSplat.OrganizationalUnit) ;
            $smsg= "Target Dname: $($InputSplat.DisplayName)" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
            $InputSplat.Add("samaccountname",$null) ;
            If($InputSplat.NonGeneric) {
                $InputSplat.Add("Shared",$False ) ;
                # user-style acct, fname & lname
                if ($InputSplat.DisplayName.tostring().indexof(" ") -gt 0){
                    $InputSplat.Add("FirstName",$($InputSplat.DisplayName.tostring().split(" ")[0].trim()) ) ;
                    $InputSplat.Add("LastName",$($InputSplat.DisplayName.tostring().split(" ")[1].trim()) ) ;
                } else {
                    $InputSplat.Add("FirstName",$null ) ;
                    $InputSplat.Add("LastName",$InputSplat.DisplayName) ;
                } ;
                if (($InputSplat.IsContractor) -OR ($InputSplat.SiteName -eq "XIA") ){
                    $LnameClean=Remove-StringDiacritic -string $InputSplat.LastName ;
                    $LnameClean= Remove-StringLatinCharacters -string $LnameClean ;
                    $FnameClean=Remove-StringDiacritic -string $InputSplat.FirstName ;
                    $FnameClean= Remove-StringLatinCharacters -string $FnameClean ;
                    $InputSplat.samaccountname=$( ([System.Text.RegularExpressions.Regex]::Replace($LnameClean,"[^1-9a-zA-Z_]","").tostring().substring(0,[math]::min([System.Text.RegularExpressions.Regex]::Replace($LnameClean,"[^1-9a-zA-Z_]","").tostring().length,5)) + $FnameClean.tostring().substring(0,1) + "x").toLower() )  ;
                } else {
                    if($InputSplat.FirstName){
                        $LnameClean=Remove-StringDiacritic -string $InputSplat.LastName ;
                        $LnameClean= Remove-StringLatinCharacters -string $LnameClean ;
                        $FnameClean=Remove-StringDiacritic -string $InputSplat.FirstName ;
                        $FnameClean= Remove-StringLatinCharacters -string $FnameClean ;
                        $InputSplat.samaccountname=$( ([System.Text.RegularExpressions.Regex]::Replace($LnameClean,"[^1-9a-zA-Z_]","").tostring().substring(0,[math]::min([System.Text.RegularExpressions.Regex]::Replace($LnameClean,"[^1-9a-zA-Z_]","").tostring().length,5)) + $FnameClean.tostring().substring(0,1)).toLower() )  ;
                    } else {
                        $LnameClean=Remove-StringDiacritic -string $InputSplat.LastName ;
                        $LnameClean= Remove-StringLatinCharacters -string $LnameClean ;
                        $InputSplat.samaccountname=$( ([System.Text.RegularExpressions.Regex]::Replace($LnameClean,"[^1-9a-zA-Z_]","").tostring().substring(0,[math]::min([System.Text.RegularExpressions.Regex]::Replace($LnameClean,"[^1-9a-zA-Z_]","").tostring().length,20))).toLower() )  ;
                    }
                    # append non-blank MI
                    if($InputSplat.MInitial){
                        $InputSplat.samaccountname+=$($InputSplat.MInitial).tostring().toLower() ;
                    } # if-E
                } ;

                # need to accommodate EXO-hosted MailUser owners
                switch ((get-recipient -Identity $($InputSplat.Owner)).RecipientType ){
                    "UserMailbox" {
                        if ( ($Tmbx=(get-mailbox -identity $($InputSplat.Owner) -ea stop)) ){
                            if($showdebug){ $smsg= "Owner UserMailbox detected" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;  } ;
                            # base users off of Owner
                            if ( $InputSplat.BaseUser=(get-mailbox -identity $($InputSplat.Owner) -domaincontroller $($InputSplat.domaincontroller) -ea continue ) ) {
                            } else { Cleanup ; Exit ;}
                        } else {
                            throw "Unable to resolve $($InputSplat.ManagedBy) to any existing OP or EXO mailbox" ;
                            Cleanup ; Exit ;
                        } ;
                    }
                    "MailUser" {
                        if ( ($Tmbx=(get-remotemailbox -identity $($InputSplat.Owner) -ea stop)) ){
                            if($showdebug){ $smsg= "Owner MailUser detected" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;  } ;
                            # base users off of Owner
                            if ( $InputSplat.BaseUser=(get-Remotemailbox -identity $($InputSplat.Owner) -domaincontroller $($InputSplat.domaincontroller) -ea continue ) ) {
                            } else { Cleanup ; Exit ;}
                        } else {
                            # without the -ea stop, we need an explicit error
                            throw "Unable to resolve $($InputSplat.ManagedBy) to any existing OP or EXO mailbox" ;
                            Cleanup ; Exit ;
                        } ;
                    }
                    default {
                        throw "$($InputSplat.ManagedBy) Not found, or unrecognized RecipientType" ;
                        Cleanup ; Exit ;
                    }
                } ;

            } else {
                # strict shared acct, no FirstName - revising, we'll support period in name and auto-split fname.lname, to create requested fname.lname@domain.com addresses wo post modification
                # support for shared/room/equip
                if(!$Equip -AND !$Room){
                    # only use Shared when not Equip or Room
                    $smsg= "SHARED Mailbox specified" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                    $InputSplat.Add("Shared",$true ) ;
                    # tear out the unused
                    $InputSplat.Remove("Room") ;
                    $InputSplat.Remove("Equip") ;
                    # add support divide on period
                    if ($InputSplat.DisplayName.tostring().indexof(".") -gt 0){
                        $InputSplat.Add("FirstName",$($InputSplat.DisplayName.tostring().split(".")[0].trim()) ) ;
                        $InputSplat.Add("LastName",$($InputSplat.DisplayName.tostring().split(".")[1].trim()) ) ;
                    } else { 
                        $InputSplat.Add("FirstName",$null ) ;
                        $InputSplat.Add("LastName",$InputSplat.DisplayName) ;
                    } ; 
                } else {
                    $InputSplat.Remove("Shared") ;
                    if($Room -AND !$Equip){
                        $smsg= "ROOM Mailbox specified" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                        $InputSplat.Add("Room",$true) ;
                        $InputSplat.Remove("Equip") ;
                    }elseif($Equip -AND !$Room){
                        $smsg= "EQUIPMENT Mailbox specified" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                        $InputSplat.Add("Equip",$true) ;
                        $InputSplat.Remove("Room") ;
                    } else { throw "INVALID OPTIONS: USE -Room OR -Equip BUT NOT BOTH" }
                    $InputSplat.Add("FirstName",$null ) ;
                    $InputSplat.Add("LastName",$InputSplat.DisplayName) ;
                } ;
                
                # psv2 LACKS the foreign-lang cleanup funtions below, skip on psv2
                if($host.version.major -lt 3){
                    write-host -foregroundcolor yellow "$((get-date).ToString('HH:mm:ss')):Psv2 detected, skipping foreign character normalization!" ;
                     $DnameClean=$InputSplat.DisplayName
                } else {
                    $DnameClean=Remove-StringDiacritic -string $InputSplat.DisplayName
                    $DnameClean= Remove-StringLatinCharacters -string $DnameClean ;
                } ;
                # strip all nonalphnums from samacct!
                $InputSplat.samaccountname=$([System.Text.RegularExpressions.Regex]::Replace($DnameClean,"[^1-9a-zA-Z_]",""));
                if($InputSplat.samaccountname.length -gt 20) { $InputSplat.samaccountname=$InputSplat.samaccountname.tostring().substring(0,20) };

                # base generics off of baseuser
                # deter BaseUser as a random user in the $($MbxSplat.OrganizationalUnit)
                # leave the -BaseUser param in to force an override, but if blank, draw random from the OU
                if(!($InputSplat.BaseUser)){
                    # draw a random from the $($MbxSplat.OrganizationalUnit)
                    if($InputSplat.SiteCode -eq "($ADSiteCodeUS)"){
                        if ( $InputSplat.BaseUser=get-mailbox -OrganizationalUnit $($MbxSplat.OrganizationalUnit) -resultsize 50 | Where-Object{($_.distinguishedname -notlike '*demo*') -AND (!$_.CustomAttribute5)} | get-random ) {

                        } elseif ( $InputSplat.BaseUser=get-remotemailbox -OnPremisesOrganizationalUnit  $($MbxSplat.OrganizationalUnit) -resultsize 50 | Where-Object{($_.distinguishedname -notlike '*demo*') -AND (!$_.CustomAttribute5)} | get-random ) {

                        } else {
                            $smsg= "UNABLE TO FIND A BASEUSER - USE -BASEUSER TO SPECIFY A SUITABLE ACCT *SOMEWHERE*" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                            Cleanup ; Exit ;
                        } ;
                    } else {
                        if ( $InputSplat.BaseUser = get-remotemailbox -OnPremisesOrganizationalUnit $($MbxSplat.OrganizationalUnit) -resultsize 50 | Where-Object { $_.distinguishedname -notlike '*demo*' } | get-random   ) {

                        }elseif ( $InputSplat.BaseUser=get-mailbox -OrganizationalUnit $($MbxSplat.OrganizationalUnit) -resultsize 50 | Where-Object{$_.distinguishedname -notlike '*demo*'} | get-random
                          ) {
                        } elseif ( $InputSplat.BaseUser=get-remotemailbox -OnPremisesOrganizationalUnit  $FallBackBaseUserOU -resultsize 50 | Where-Object{($_.distinguishedname -notlike '*demo*') -AND (!$_.CustomAttribute5)} | get-random ) {
                            # if all else fails, pull a random remotemailbox from ($ADSiteCodeUS) - we're losing comps moving ahead
                        } else {
                            $smsg= "UNABLE TO FIND A BASEUSER - USE -BASEUSER TO SPECIFY A SUITABLE ACCT *SOMEWHERE*" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
                            Cleanup ; Exit ;
                        } ;
                    }
                    write-host -foregroundcolor darkgray "$((get-date).ToString("HH:mm:ss")):Drew Random BaseUser: $($InputSplat.BaseUser.DisplayName) ($($inputsplat.BaseUser.samaccountname))" ;
                } else {
                    switch ((get-recipient -Identity $($InputSplat.BaseUser)).RecipientType ){
                        "UserMailbox" {
                            if ( ($tmpBaseUser=(get-mailbox -identity $InputSplat.BaseUser -ea stop)) ){
                                    $InputSplat.BaseUser=$tmpBaseUser ;
                            } else {
                                throw "Unable to resolve $($InputSplat.BaseUser) to any existing OP or EXO mailbox" ;
                                Cleanup ; Exit ;
                            } ;
                        } ;
                        "MailUser" {
                            if ( ($tmpBaseUser=(get-remotemailbox -identity $InputSplat.BaseUser -ea stop)) ){
                                $InputSplat.BaseUser=$tmpBaseUser ;
                            } else {
                                # without the -ea stop, we need an explicit error
                                throw "Unable to resolve $($InputSplat.BaseUser) to any existing OP or EXO mailbox" ;
                                Cleanup ; Exit ;
                            } ;
                        } ;
                        default {
                            throw "$($InputSplat.ManagedBy) Not found, or unrecognized RecipientType" ;
                            Cleanup ; Exit ;
                        }
                    } ;
                } ;

            };
            $InputSplat.Add("Phone","") ;
            # *** BREAKPOINT ;
            $InputSplat.Add("Title","") ;

             #region passwordgen #-----------
            # need to test complex, and if failed, pull another: (above doesn't consistently deliver Ad complexity req's)
            # 2:16 PM 8/2/2023 revised pol, don't need complex, but will pass with it, but leng is bumped; until rebuild, can push up default with explicit -minLen param
            # # method: GeneratePassword(int length, int numberOfNonAlphanumericCharacters)
            Do { $password = $([System.Web.Security.Membership]::GeneratePassword(14,2)) } Until (Validate-Password -pwd $password -minLen 14) ;
            $InputSplat.Add("pass",$($password));
            #region passwordgen #-----------

            # 9:43 AM 4/1/2016 secgrp is only necc for Generics
            if(!$InputSplat.NonGeneric){
                $InputSplat.Add("PermGrpName",$($InputSplat.SiteName + "-Data-Email-" + $InputSplat.DisplayName + "-G")) ;
            } else {
                $InputSplat.Add("PermGrpName",$null) ;
            } ;

            if ( $InputSplat.BUserAD=(get-user -identity $($InputSplat.BaseUser.samaccountname) -domaincontroller $($InputSplat.domaincontroller) -ea continue)  ) {
            } else { Cleanup ; Exit ;} ;
            $InputSplat.ADDesc="$(get-date -format 'MM/dd/yyyy') for $($InputSplat.OwnerMbx.samaccountname) $($InputSplat.ticket) -tsk" ;

            # check for conflicting samaccountname, and increment
            $bConflicted=$false ;
            if (Get-User -identity $($InputSplat.samaccountname) -domaincontroller $($InputSplat.domaincontroller) -ea SilentlyContinue) {
                $InputSplat.samaccountname+="2"
                $smsg= "===Conflicting SamAccountName found ($($InputSplat.samaccountname)), incrementing SamAccountName $($InputSplat.samaccountname) to avoid conflict...===" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                $bConflicted=$true ;
            };

            If(!$InputSplat.NonGeneric -AND !($InputSplat.Equip -OR $InputSplat.Room)) {
                    $MbxSplat.shared=$true ;
            } ;
            # add Equipment, Room
            if($InputSplat.Equip){
                $MbxSplat.Equipment=$true ;
                $MbxSplat.Remove("shared");
            }elseif($InputSplat.Room){
                $MbxSplat.Room=$true ;
                $MbxSplat.Remove("shared");
            }


            # 64char limit on names
            if($InputSplat.DisplayName.length -gt 64){
                $smsg= "`n **** NOTE TRUNCATING NAME, -GT 64 CHARS!  ****`N" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                $MbxSplat.Name=$InputSplat.DisplayName.Substring(0,63) ;
                $MbxSplat.DisplayName=$InputSplat.DisplayName.Substring(0,63) ;
            } else {
                $MbxSplat.Name=$InputSplat.DisplayName;
                $MbxSplat.DisplayName=$InputSplat.DisplayName;
            };

            # using AMD (Automatic mailbox distribution), only subset are enabled for IsExcludedFromProvisioning $false
            # blank the db name and AMD will autopick db from avail block in site.
            $MbxSplat.database=$null ;
            $MbxSplat.password=ConvertTo-SecureString -a -f ($($InputSplat.pass));
            if($InputSplat.FirstName.length -gt 64){
                $smsg= "`n **** NOTE TRUNCATING FIRSTNAME, -GT 64 CHARS!  ****`N" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                $MbxSplat.FirstName=$InputSplat.FirstName.Substring(0,63) ;
            } else {
                $MbxSplat.FirstName=$InputSplat.FirstName;
            };
            $MbxSplat.Initials=$null;
            if($InputSplat.LastName.length -gt 64){
                $smsg= "`n **** NOTE TRUNCATING LASTNAME, -GT 64 CHARS!  ****`N" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                $MbxSplat.LastName=$InputSplat.LastName.Substring(0,63) ;
            } else {
                $MbxSplat.LastName=$InputSplat.LastName;
            };

            if($MbxSplat.FirstName -AND $MbxSplat.LastName){
                # dot-separated addr
                $DirName="$([System.Text.RegularExpressions.Regex]::Replace($MbxSplat.LastName,'[^1-9a-zA-Z_]','')).$([System.Text.RegularExpressions.Regex]::Replace($MbxSplat.FirstName,'[^1-9a-zA-Z_]',''))" ;
            } else {
                # no-dot, just the fname+lname concat'd, trimmed
                $DirName=("$([System.Text.RegularExpressions.Regex]::Replace($MbxSplat.LastName,'[^1-9a-zA-Z_]',''))$([System.Text.RegularExpressions.Regex]::Replace($MbxSplat.FirstName,'[^1-9a-zA-Z_]',''))").trim() ;
            } ;

            switch ($Domain){
              "$($DomTORfqdn)" {
                  $MbxSplat.userprincipalname="$($DirName)@$($toRmeta['o365_OPDomain'])" ;
              } ;
              "$($DomTOLfqdn)" {
                  $MbxSplat.userprincipalname="$($DirName)@$($toLmeta['o365_OPDomain'])" ;
              } ;
              default {
                  throw "unrecognized `Domain:$($Domain)!" ;
              } ;
            } ;

            $MbxSplat.samaccountname=$InputSplat.samaccountname;
            $MbxSplat.Alias = $InputSplat.samaccountname;
            $MbxSplat.RetentionPolicy=$TORMeta['RetentionPolicy'];
            $MbxSplat.domaincontroller=$($InputSplat.domaincontroller)

            #or nonshared, make them reset pw on logon
            if($NonGeneric -eq $true){
                write-host -foregroundcolor green "$((get-date).ToString("HH:mm:ss")):NonGeneric user, Forcing ResetPasswordOnNextLogon";
                $MbxSplat.ResetPasswordOnNextLogon=$true
                # move EAS pol into here - Shared have no pw, so how could they log onto EAS?
                $MbxSplat.ActiveSyncMailboxPolicy='Default';
            } else {
                $MbxSplat.ResetPasswordOnNextLogon=$false;
                # completely remove the policy spec (throws up on shared/equipment/room
                $MbxSplat.remove("ActiveSyncMailboxPolicy");
            };

            #for nonshared, make them reset pw on logon
            if($NonGeneric -eq $true){
                $smsg= "$((get-date).ToString("HH:mm:ss")):NonGeneric user, Forcing ResetPasswordOnNextLogon";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                $MbxSplat.ResetPasswordOnNextLogon=$true
            } ;

            # get the identity set to match
            $MbxSetSplat.identity=$MbxSplat.samaccountname ;
            $MbxSetSplat.CustomAttribute9=$null;
            $MbxSetSplat.CustomAttribute5=$null;

            if(!($InputSplat.Vscan)){
                # prompt if not explicitly set
                $smsg= "`a$($xxx)`nPROMPT:";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                $bRet= read-host "Enable Vscan?[Y/N]" ;
                # *** BREAKPOINT ;
                if($bRet.ToUpper() -eq "Y"){
                    $MbxSetSplat.CustomAttribute9 = $CU9Value ;
                } ;
            } else {
                $smsg= "$((get-date).ToString("HH:mm:ss")):-Vscan $($InputSplat.Vscan) parameter specified"; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                if($InputSplat.Vscan -eq "YES"){
                    $MbxSetSplat.CustomAttribute9 = $CU9Value  ;
                } elseif($InputSplat.Vscan -eq "NO"){
                    $MbxSetSplat.CustomAttribute9 = $null  ;
                } ;  # if-E vscan
            }  # if-E Vscan;

            if($InputSplat.Cu5){
                $smsg= "-CU5 override detected, forcing CustomAttribute5:$( $InputSplat.Cu5 )" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                $MbxSetSplat.CustomAttribute5 = $InputSplat.Cu5 ;
            } else {
                # switch CA5 to keying off of Mgr - too likely to draw inapprop odddomain.com users in ($ADSiteCodeUS) $InputSplat.Owner
                # Owner doesn't have a cu5 attr, shift to the new OwnerMbx prop
                if($InputSplat.OwnerMbx.CustomAttribute5){
                    $smsg= "OwnerMbx has Cu5 set: Applying '$($InputSplat.OwnerMbx.CustomAttribute5)' to CU5 on new mbx" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                    $MbxSetSplat.CustomAttribute5 =$InputSplat.BaseUser.CustomAttribute5 ;
                } ;
            } ;

            # casmbx matrl
            $MbxSetCASmbx.identity=$MbxSplat.samaccountname ;
            #$MbxSetCASmbx.ActiveSyncMailboxPolicy="Default" ;
            if($NonGeneric -eq $true){
                write-host -foregroundcolor green "$((get-date).ToString("HH:mm:ss")):NonGeneric user, Forcing ResetPasswordOnNextLogon & EAS";
                $MbxSetCASmbx.ResetPasswordOnNextLogon=$true
                # move EAS pol into here - Shared have no pw, so how could they log onto EAS?
                $MbxSetCASmbx.ActiveSyncMailboxPolicy='Default';
            } else {
                # completely remove the policy spec (throws up on shared/equipment/room
                $smsg= "$((get-date).ToString("HH:mm:ss")):Shared/Room/Equipment:Removing ActiveSyncMailboxPolicy"; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                $MbxSetCASmbx.remove("ActiveSyncMailboxPolicy");
            };
            $MbxSetCASmbx.domaincontroller=$($InputSplat.domaincontroller) ;

            #  blank setting manager
            $ADSplat.Identity=$($MbxSplat.samaccountname) ;
            $ADSplat.Description=$($InputSplat.ADDesc) ;

            $UsrSplat.City=$($InputSplat.BUserAD.City);
            $UsrSplat.CountryOrRegion=$($InputSplat.BUserAD.CountryOrRegion);
            $UsrSplat.Fax=$($InputSplat.BUserAD.Fax);
            $UsrSplat.Office=$($InputSplat.BUserAD.Office);
            $UsrSplat.PostalCode=$($InputSplat.BUserAD.PostalCode);
            $UsrSplat.StateOrProvince=$($InputSplat.BUserAD.StateOrProvince);
            $UsrSplat.StreetAddress=$($InputSplat.BUserAD.StreetAddress);
            $UsrSplat.Title=$Title;
            $UsrSplat.Phone=$Phone

            $ChangeLog="$((get-date -format "MM/dd/yyyy"))" ;

            if($($InputSplat.Ticket)){$ChangeLog+=" #$($InputSplat.Ticket)" } ;
            $ChangeLog+=" for $($InputSplat.Owner) -$($AdminInits)" ;

            $smsg= "=== v Input Specifications v ===";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
            $smsg= "`$InputSplat:`n$(($InputSplat|out-string).trim())" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
            if(!($MbxSplat.Shared -OR $MbxSplat.Room -OR $mbxSplat.Equipment)){
                $smsg= "`nInitial Password: $($InputSplat.pass)";

            } ;
            $smsg= "`$MbxSplat:`n$(($MbxSplat|out-string).trim())" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
            $smsg= "`$MbxSetSplat:`n$(($MbxSetSplat|out-string).trim())" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
            $smsg= "`$MbxSetCASmbx:`n$(($MbxSetCASmbx|out-string).trim())" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
            $smsg= "`$ADSplat:`n$(($ADSplat|out-string).trim())" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
            $smsg= "`$UsrSplat:`n$(($UsrSplat|out-string).trim())" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;

            $smsg= "=== ^ Input Specifications ^ ===";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;

            #endregion DATAPREP ; # ------

            #region MAKECHANGES ; # ------

            $smsg= "Checking for existing $($InputSplat.SamAccountname)..."  ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
            if($bDebug){$smsg= "`$Mbxsplat.DisplayName:$($Mbxsplat.DisplayName)"; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; }
            # 12:30 PM 4/1/2016 if samaccountname checks always bump to 2, this will never match existing!
            if($bConflicted) {
                $smsg= "Prior Conflict already found!" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                $oMbx = (get-mailbox -identity  $($Mbxsplat.samaccountname) -domaincontroller $($InputSplat.DomainController) -ea silentlycontinue) ;
            } else {

            } ;

            if($oMbx){
                if($bDebug){
                    $smsg= "Existing found: `$InputSplat.DisplayName:$($InputSplat.DisplayName)" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                    $smsg= "`$oMbx.DN:$($oMbx.DistinguishedName)" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                } ;
            } else {
                $smsg= "$($Mbxsplat.DisplayName) Not found. ..."  ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                $smsg= "Whatif $($Mbxsplat.Name) creation...";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                $MbxSplat.Whatif=$true ;
                New-Mailbox @MbxSplat -ea Stop ;

                $smsg= "$((get-date).ToString("HH:mm:ss")):Continue with $($Mbxsplat.Name) creation?...`a";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                if($NoPrompt) {$bRet= "YYY"} else { $bRet=Read-Host "Enter YYY to continue. Anything else will exit" ;} ;
                if ($bRet.ToUpper() -eq "YYY") {
                    # *** BREAKPOINT ;
                    $smsg= "Executing...";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                    if($Whatif){
                        $smsg= "SKIPPING EXEC: Whatif-only pass";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                    } else {
                        $MbxSplat.Whatif=$false ;
                        $Exit = 0 ;
                        $smsg = "New-Mailbox  w`n$(($MbxSplat|out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        # do loop until up to 4 retries...
                        Do {
                            Try {
                                $oNMbx = New-Mailbox @MbxSplat -ea Stop ;
                                $Exit = $Retries ;
                            } Catch {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #-=-record a STATUSWARN=-=-=-=-=-=-=
                                $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                                #-=-=-=-=-=-=-=-=
                                $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                                Start-Sleep -Seconds $RetrySleep ;
                                $Exit ++ ;
                                #$smsg= "Failed to exec cmd because: $($Error[0])" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                                $smsg= "Try #: $Exit" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                                If ($Exit -eq $Retries) {$smsg= "Unable to exec cmd!"; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; } ;
                            } # try-E
                            
                        } Until ($Exit -eq $Retries) # loop-E

                        $MbxSplat.Whatif=$true ;
                    } ;

                    if($Whatif){
                        $smsg= "SKIPPING EXEC: Whatif-only pass";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                    } else {
                        if(!$oNMbx){
                            write-verbose "(using returned New-Mailbox output object...)" ; 
                            do {Write-Host "." -NoNewLine;Start-Sleep -s 1} until ($oMbx = (get-mailbox -identity $Mbxsplat.samaccountname -domaincontroller $Mbxsplat.DomainController -ea silentlycontinue)) ;
                        } else { 
                            # if $oNMbx is properly output from new-mailbox, use it
                            write-verbose "(New-Mailbox output did not return an object, reusing input SamAccountname for gmbx...)" ; 
                            do {Write-Host "." -NoNewLine;Start-Sleep -s 1} until ($oMbx = (get-mailbox -identity $oNMbx.samaccountname -domaincontroller $Mbxsplat.DomainController -ea silentlycontinue)) ;
                        } ; 
                        if($bDebug){
                            $smsg= "`$oMbx:$($Mbxsplat.DisplayName)" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                            $smsg= "`$oMbx.DN:$($oMbx.DistinguishedName)" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        } ;
                    }  # if-E
                } else {
                    $smsg= "INVALID KEY ABORTING NO CHANGE!" ;  if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                    Exit ;
                } ;

            } # if-E No oMbx

            if($oMbx){

                if($Whatif){
                        $smsg= "SKIPPING REMAINING AD CMDS - NO OBJECT YET: Whatif-only pass";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                } else {
                    $MbxSetSplat.Whatif=$false ;
                    $Exit = 0 ;
                    if($bDebug) {$smsg= "$((get-date).ToString("HH:mm:ss")):Updating Mbx" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; }
                    $smsg = "Set-Mailbox w`n$(($MbxSetSplat|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Do {
                        Try {
                            Set-Mailbox @MbxSetSplat -ea Stop  ;
                            $Exit = $Retries ;
                        } Catch {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #-=-record a STATUSWARN=-=-=-=-=-=-=
                            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                            #-=-=-=-=-=-=-=-=
                            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                            Start-Sleep -Seconds $RetrySleep
                            $Exit ++ ;
                            $smsg= "Failed to execute Set-Mailbox because: $($Error[0])" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                            $smsg= "Try #: $($Exit)" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                            If ($Exit -eq $Retries) {
                                $smsg= "Unable to update mailbox! (Set-Mailbox)" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                            } ;
                        } # try-E
                    } Until ($Exit -eq $Retries) # loop-E

                    if($bDebug) {$smsg= "$((get-date).ToString("HH:mm:ss")):Setting CASMbx settings" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; } ;
                    $MbxSetCASmbx.Whatif=$false ;
                    $smsg = "set-CASMailbox w`n$(($MbxSetCASmbx|out-string).trim())" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $Exit = 0 ;
                    Do {
                        Try {
                            set-CASMailbox @MbxSetCASmbx -ea Stop ;
                            $Exit = $Retries ;
                        } Catch {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #-=-record a STATUSWARN=-=-=-=-=-=-=
                            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                            #-=-=-=-=-=-=-=-=
                            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                            Start-Sleep -Seconds $RetrySleep
                            $Exit ++ ;
                            $smsg= "Failed to execute Set-CASMailbox because: $($Error[0])" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                            $smsg= "Try #: $Exit" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                            If ($Exit -eq $Retries) {$smsg= "Unable to update mailbox! (Set-CASMailbox)" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; } ;
                        } # try-E
                    } Until ($Exit -eq $Retries) # loop-E

                    if($MbxSetSplat.CustomAttribute5){
                        # force trigger EAP toggle
                        $smsg= "$((get-date).ToString("HH:mm:ss")):(toggling EAP to force variant email...)";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        set-mailbox $($InputSplat.samaccountname) -domaincontroller $($InputSplat.domaincontroller) -EmailAddressPolicyEnabled $false  ;Start-Sleep 1; set-mailbox $($InputSplat.samaccountname) -domaincontroller $($InputSplat.domaincontroller) -EmailAddressPolicyEnabled $true;
                    } ;

                    #=========== V NOTES PARSER
                    <# This block takes an existing Adobject Notes field and parses it and updates fields with a new ChangeLog reference
                    #>
                    # we should _append_ the $InfoStr into any existing Info for the object

                    $ADOtherInfoProps=@{
                        TargetMbx=$null ;
                        PermsExpire=$null ;
                        Incident=$null ;
                        Admin=$null ;
                        BusinessOwner=$null ;
                        ITOwner=$null ;
                        Owner=$null ;
                        ChangeLog=$null ;
                        ADNotes=$null ;
                    } ;

                    $oADOtherInfo = New-Object PSObject -Property $ADOtherInfoProps ;
                    $Exit = 0 ; # zero out $exit each new cmd try/retried

                    Do {
                        Try {
                            $oADUsr=get-aduser -identity $($MbxSplat.SamAccountname) -Properties * -server $($InputSplat.DomainController) -ErrorAction stop ;
                            # break-exit here, completes the Until block
                            $Exit = $Retries ;
                        } Catch {
                            $ErrTrapd=$Error[0] ;
                            $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #-=-record a STATUSWARN=-=-=-=-=-=-=
                            $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                            if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                            if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                            #-=-=-=-=-=-=-=-=
                            $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                            Start-Sleep -Seconds $RetrySleep ;
                            $Exit ++ ;
                            $smsg= "Failed to exec cmd because: $($Error[0])" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                            $smsg= "Try #: $($Exit)" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                            If ($Exit -eq $Retries) {$smsg= "Unable to exec cmd!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; } ;
                        } # try-E
                    } Until ($Exit -eq $Retries) # loop-E

                    # MailContact object has an explicit notes field
                    # but ADObjects just have info

                    if($oADUsr.info){
                        # if existing notes, grab all but the defined tags, and then we'll append a $ChangeLog to the head, and an Owner to the tail.
                        # mailcontact
                        $lns = ($oADUsr.info.tostring().split("`n")) ;
                        $UpdInfo=$null;
                        foreach ($ln in $lns) {
                                # add stock Owner
                                if($ln -match "^(TargetMbx|PermsExpire|Incident|Admin|BusinessOwner|ITOwner|Owner):.*$"){
                                    # it's part of a defined Info tag
                                    $matches=$null ;
                                    # ingest the matches and throw away the lines
                                    if($ln -match "(?<=TargetMbx:)\w+" ){ $oADOtherInfo.TargetMbx = $matches[0] } ; $matches=$null ;
                                    if($ln -match "(?<=PermsExpire:)\d+\/\d+/\d+" ) {$oADOtherInfo.PermsExpire = (get-date $matches[0]) ;   } ; ; $matches=$null ;
                                    if($ln -match "(?<=Incident:)^\d{5,6}$"){ $oADOtherInfo.Incident = $matches[0] ;  } ;  $matches=$null ;
                                    if($ln -match "(?<=Admin:)\w*"){ $oADOtherInfo.Admin = $matches[0] ;   } ; $matches=$null ;
                                    if($ln -match "(?<=BusinessOwner:)\w{2,20}"){ $oADOtherInfo.BusinessOwner = $matches[0] ;   } ; $matches=$null ;
                                    if($ln -match "(?<=ITOwner:)\w{2,20}"){ $oADOtherInfo.ITOwner = $matches[0] ;  } ; $matches=$null ;
                                    if($ln -match "(?<=Owner:)\w{2,20}$"){ $oADOtherInfo.Owner = $matches[0] ;  } ; $matches=$null ;
                                } else {
                                    $UpdInfo+="$($ln)`r`n" ;
                                } ;
                        }# loop-E ;

                        # do compare if detected existing owner: tag     $oADOtherInfo.Owner
                        if($oADOtherInfo.Owner){
                            if($oADOtherInfo.Owner -ne $InputSplat.Owner){
                                # preserve original owner, if change would update it
                                $UpdInfo+="`r`nOwner:$($oADOtherInfo.Owner)" ;
                                # update the $InputSplat Owner to reflect corrected owner
                                $smsg= "$((get-date).ToString("HH:mm:ss")):NOTE: $($oADUsr.Name) has an eisting Owner value, deferring ownership to existing value: $($oADOtherInfo.Owner)";
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                                $InputSplat.Owner = $oADOtherInfo.Owner ;
                                $InputSplat.OwnerMbx=(get-mailbox -identity $($InputSplat.Owner) $(InputSplat.domaincontroller) -ea stop) ;
                            } else {
                                $UpdInfo+="`r`nOwner:$($InputSplat.Owner)" ;
                            }
                        } else {
                            #$UpdInfo+="`r`nOwner:$($oADOtherInfo.Owner)" ;
                            $UpdInfo+="`r`nOwner:$($InputSplat.Owner)" ;
                        }

                        if($bDebug){
                            $smsg= "$((get-date).ToString("HH:mm:ss")):New Info field:"; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                            $UpdInfo | out-string | out-default ;
                        } ;

                    } else {
                        # new notes
                        $UpdInfo="Owner:$($InputSplat.Owner)" ;
                    } # if-E populated notes ;

                    # prepend the new $ChangeLog to the top and assign to .notes
                    $UpdInfo="$($ChangeLog)`r`n$($UpdInfo)" ;
                    # strip empty lines in there too
                    $UpdInfo = $UpdInfo -replace '(?ms)(?:\r|\n)^\s*$' ;
                    # mailcontact
                    #$AContactSplat.notes="$($UpdInfo)" ;
                    # ADU
                    $ADOtherInfoProps.ADNotes="$($UpdInfo)" ;
                    #=========== ^ NOTES PARSER

                    if($Whatif){
                        $smsg= "Whatif $($Mbxsplat.DisplayName) Update..."; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        $ADSplat.whatif = $true ;
                        Set-ADUser @ADSplat -Replace @{info="$($UpdInfo)"} ;
                    } else {
                        $smsg= "Executing $($Mbxsplat.DisplayName) Update...";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        $ADSplat.whatif = $false ;
                        $smsg = "Set-ADUser w`n$(($ADSplat|out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        $Exit = 0 ; # zero out $exit each new cmd try/retried
                        Do {
                            Try {
                                Set-ADUser @ADSplat -Replace @{info="$($UpdInfo)"} -ErrorAction stop ;
                                $Exit = $Retries ;
                            } Catch {
                                $ErrTrapd=$Error[0] ;
                                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #-=-record a STATUSWARN=-=-=-=-=-=-=
                                $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                                #-=-=-=-=-=-=-=-=
                                $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                #Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                                Start-Sleep -Seconds $RetrySleep ;
                                $Exit ++ ;
                                $smsg= "Failed to exec cmd because: $($Error[0])" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                                $smsg= "Try #: $Exit" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                                If ($Exit -eq $Retries) {$smsg= "Unable to exec cmd!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; } ;
                            } # try-E
                        } Until ($Exit -eq $Retries) # loop-E

                        $ADSplat.whatif = $true ;
                    }  ;

                    #region UPNFromEmail ; # ------
                    # pull the SMTP: addr and use it to force the UPN
                    if($Whatif){
                        $smsg= "Whatif skipping UPN Update...";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                    } else {
                        # dynm pull the forestdom from the forest, match @DOMAIN.COM
                        $forestdom=get-adforest -ea stop | Select-Object -expand upnsuffixes |Where-Object{$_ -match $rgxTTCDomainsLegacy}
                        if($forestdom -is [string]){
                            # pull primary SMTP:, verify -is [string]/non-array
                            Do {
                                $smsg= "Waiting for ADUser to return email addresses" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                                write-host "." -NoNewLine;Start-Sleep -m (1000 * 5)
                                $dirname=(Get-ADUser -identity $oMbx.samaccountname -server $InputSplat.domaincontroller -Properties proxyAddresses -ea 0 | Select-Object -Expand proxyAddresses | Where-Object {$_ -clike "SMTP:*"});
                            } Until (($dirname)) ;

                            if($dirname -is [string]){
                                # convert the $dirname to string and strip proto and take first element
                                $dirname=$dirname.tostring().replace("SMTP:","").split("@")[0]  ;
                                $newUPN="$($dirname)@$($forestdom)";
                                # strip chars allowed in eml, *NOT* allowed in upns:
                                <# Nov 06, 2004 05:27 PM
                                From MSDN: User account names are limited to 20 characters and group names are limited to 256 characters. In addition, account names cannot be terminated by a period and they cannot include commas or any of the following printable characters: ", /, \, [, ], :, |, <, >, +, =, ;, ?, *. Names also cannot include characters in the range 1-31, which are nonprintable

                                [Prepare to provision users through directory synchronization to Office 365 | Microsoft Docs](https://docs.microsoft.com/en-us/office365/enterprise/prepare-for-directory-synchronization):
                                maximum number of characters for the userPrincipalName attribute is 113.
                                Maximum number of characters for the user name that is in front of the at sign (@): 64
                                Maximum number of characters for the domain name following the at sign (@): 48

                                Invalid characters: \ % & * + / = ? { } | < > ( ) ; : , [ ] "
                                An umlaut is also an invalid character.
                                #>
                                # samaccountname & alias should be fine, I'm running an alphanumeric or underscore replacement on the sama, which also goes to the alias
                                $newUPN = Remove-StringDiacritic -string $newUPN ;
                                $newUPN = Remove-StringLatinCharacters -string $newUPN ;
                                # yank ampersand,apostrophe,hyphen,underscore,%, +
                                $newUPN = $newUPN.replace("&", "").replace("'","").replace("-","").replace("%","").replace("+","")  ;

                                if($bDebug){$smsg= "$((get-date).ToString("HH:mm:ss")):`$newUPN:$($newUPN)"; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; } ;
                                $pltSetADU2 = @{
                                    identity=$oMbx.samaccountname ;UserPrincipalName=$newUPN ;server=$InputSplat.domaincontroller ;ErrorAction='Stop' ;
                                } ; 
                                $smsg = "Set-ADUser w`n$(($pltSetADU2|out-string).trim())" ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                # retry support
                                $Exit = 0 ;
                                Do {
                                    Try {
                                        Set-ADUser @pltSetADU2 ;
                                        #-identity $oMbx.samaccountname -UserPrincipalName $newUPN -server $InputSplat.domaincontroller -ErrorAction Stop;
                                        $Exit = $Retries ;
                                    } Catch {
                                        $ErrTrapd=$Error[0] ;
                                        $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                        else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        #-=-record a STATUSWARN=-=-=-=-=-=-=
                                        $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                                        if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                                        if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                                        #-=-=-=-=-=-=-=-=
                                        $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                                        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                        #Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
                                        Start-Sleep -Seconds $RetrySleep ;
                                        $Exit ++ ;
                                        $smsg= "Failed to exec cmd because: $($Error[0])" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                                        $smsg= "Try #: $($Exit)" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                                        If ($Exit -eq $Retries) {$smsg= "Unable to exec cmd!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; } ;
                                    } # try-E
                                } Until ($Exit -eq $Retries) # loop-E

                            } else {
                                throw "invalid `$dirname$($dirname) type returned! (non-string)" ;
                            } ;
                        } else {
                            throw "invalid `$forestdom:$($forestdom) returned! (non-string)" ;
                        } ;
                    } ;
                    #endregion UPNFromEmail ; # ------
                    #endregion MAKECHANGES ; # ------

                    #region REPORTING ; # ------
                    do{
                        $smsg= "===REVIEW SETTINGS:=== " ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        $mbxo = get-mailbox -Identity $($InputSplat.samaccountname) -domaincontroller $($InputSplat.domaincontroller) ;
                        $cmbxo= Get-CASMailbox -Identity $($MbxSplat.samaccountname) -domaincontroller $($InputSplat.domaincontroller) ;
                        $aduprops="GivenName,Surname,Manager,Company,Office,Title,StreetAddress,City,StateOrProvince,c,co,countryCode,PostalCode,Phone,Fax,Description" ;
                        $ADu = get-ADuser -Identity $($InputSplat.samaccountname) -properties * -server $($InputSplat.domaincontroller)| Select-Object *;
                        $smsg= "User Email:`t$(($mbxo.WindowsEmailAddress.tostring()).trim())" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        $smsg= "Owner Email:`t$(($InputSplat.OwnerMbx.WindowsEmailAddress.tostring()).trim())" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        $smsg= "Mailbox Information:" ;if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        $smsg= "$(($mbxo | select @{Name='LogonName';Expression={$_.SamAccountName }},Name,DisplayName,Alias,database,UserPrincipalName,RetentionPolicy,CustomAttribute5,CustomAttribute9,RecipientType,RecipientTypeDetails | out-string).trim())" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        $smsg= "$(($Adu | select GivenName,Surname,Manager,Company,Office,Title,StreetAddress,City,StateOrProvince,c,co,countryCode,PostalCode,Phone,Fax,Description | out-string).trim())";
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        if($NonGeneric -eq $false){
                            $smsg= "ActiveSyncMailboxPolicy:$($cmbxo.ActiveSyncMailboxPolicy.tostring())" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        } ;
                        $smsg= "Description: $($Adu.Description.tostring())";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        $smsg= "Info: $($Adu.info.tostring())";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        if(!($MbxSplat.Shared -OR $MbxSplat.Room -OR $MbxSplat.Equipment  )){
                            $smsg= "Initial Password: $(($InputSplat.pass | out-string).trim())" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                        } ;
                        $bRet=Read-Host "Enter Y to Refresh Review (replication latency)." ;
                    } until ($bRet -ne "Y");
                    $smsg= "$xxx`n";if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                    if($InputSplat.NonGeneric){
                        $smsg= "(projected Permissions SecGrp name: $($InputSplat.PermGrpName))`n" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ;
                    } ;

                    #endregion REPORTING ; # ------

                }  # if-E whatif/exec



            }  # if-E $ombx

        } else { $smsg= "OU $(OU) not found. ABORTING!" ; if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; } ;



    } # PROC-E ;

    END {


    } # END-E
}

#*------^ new-MailboxShared.ps1 ^------


#*------v preview-EAPUpdate.ps1 v------
function preview-EAPUpdate {
        <#
        .SYNOPSIS
        preview-EAPUpdate.ps1 - Code to approximate EmailAddressTemplate-generated email addresses
        .NOTES
        Version     : 0.0.
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2021-08-23
        FileName    : 
        License     : MIT License
        Copyright   : (c) 2021 Todd Kadrie
        Github      : https://github.com/tostka/verb-XXX
        Tags        : Powershell
        AddedCredit : REFERENCE
        AddedWebsite: URL
        AddedTwitter: URL
        REVISIONS
        * 2:16 PM 6/24/2024: rem'd out #Requires -RunasAdministrator; sec chgs in last x mos wrecked RAA detection
        * 3:45 PM 8/23/2021 added extended examples, made a function (adding to 
        verb-ex2010); added drop of illegal chars (shows up distinctively as spaces in 
        dname :P); fixed bug in regex ps replace;  
        .DESCRIPTION
        preview-EAPUpdate.ps1 - Code to approximate EmailAddressTemplate-generated email addresses
        Note: This is a quick & dirty *approximation* of the generated email address. 
        Doesn't support multiple %rxy replaces on mult format codes. Just does the first one; plus any non-replace %d|s|i|m|g's. 

        Don't *rely* on this. It's just intended to quickly confirm assigned primarysmtpaddress roughly matches the intended EAP template.
        If it doesn't, put eyes on it and *confirm*, don't use this to drive any revision of the email address!

        Latest ref specs:[Email address policies in Exchange Server | Microsoft Docs - docs.microsoft.com/](https://docs.microsoft.com/en-us/exchange/email-addresses-and-address-books/email-address-policies/email-address-policies?view=exchserver-2019)

        Address types: SMTP| GWISE| NOTES| X400
        Address format variables:
        |Variable |Value|
        |---|---|
        |%d |Display name|
        |%g |Given name (first name)|
        |%i |Middle initial|
        |%m |Exchange alias|
        |%rxy |Replace all occurrences of x with y|
        |%rxx |Remove all occurrences of x|
        |%s |Surname (last name)|
        |%ng |The first n letters of the first name. For example, %2g uses the first two letters of the first name.|
        |%ns |The first n letters of the last name. For example, %2s uses the first two letters of the last name.|
        Use of email-legal ASCII chars:
        |Example |Exchange Management Shell equivalent|
        |---|---|
        |<alias>@contoso.com |%m@contoso.com|
        |elizabeth.brunner@contoso.com |%g.%s@contoso.com|
        |ebrunner@contoso.com |%1g%s@contoso.com|
        |elizabethb@contoso.com |%g%1s@contoso.com|
        |brunner.elizabeth@contoso.com |%s.%g@contoso.com|
        |belizabeth@contoso.com |%1s%g@contoso.com|
        |brunnere@contoso.com |%s%1g@contoso.com|

        %RXY REPLACEMENT EXAMPLES. 
        |Source properties||
        |---|---|
        |user logon name|"jwilson"|
        |Display name|James C. Wilson|
        |Surname|Wilson|
        |Given name|James|
        note: In %rXY, if X = Y - same char TWICE - the character will be DELETED rather than REPLACED.
        |Replacement String|SMTP Address Generated|Comment|
        |---|---|---|
        |%d@domain.com|JamesCWilson@domain.com|"Displayname@domain"|
        |%g.%s@microsoft.com|James.Wilson@microsoft.com|"givenname.surname@domain"|
        |@microsoft.com|JamesW@microsoft.com|"userLogon@domain" (default)|
        |%1g%s@microsoft.com|JWilson@microsoft.com|"[1stcharGivenName][surname]@domain"|
        |%1g%3s@microsoft.com|JWil@microsoft.com|"[1stcharGivenName][3charsSurname]@domain"|
        |@domain.com|<email-alias>@domain.com (this is the one item always a part of the Default policy)|
        |%r._%d@microsoft.com|JamesC_Wilson@microsoft.com|"[replace periods in displayname with underscore]@domain"|
        |%r..%d@microsoft.com|JamesC.Wilson@microsoft.com|"[DELETE periods in displayname]@domain",(avoids double period if name trails with a period)|
        |%g.%r''%s@domain.com|James.Wilson@domain|"[givenname].[surname,delete all APOSTROPHES]@domain"|
        |%r''%g.%r''%s@domain.com|James.Wilson@domain|"[givenname,delete all APOSTROPHES].[surname,delete all APOSTROPHES]@domain"|

        .PARAMETER  EmailAddressPolicy
        EmailAddressPolicy object to be modeled for primarysmtpaddress update
        .PARAMETER  Recipient
        Recipient object to be modeled
        .PARAMETER useEXOv2
        Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
        .INPUTS
        None. Does not accepted piped input.(.NET types, can add description)
        .OUTPUTS
        System.String
        [| get-member the output to see what .NET obj TypeName is returned, to use here]
        .EXAMPLE
        PS> preview-EAPUpdate  -eap $eaps[16] -Recipient $trcp -verbose ;
        Preview specified recipient using the specified EAP (17th in the set in the $eaps variable).
        .EXAMPLE
        PS> preview-EAPUpdate  -addresstemplate '%5s%3g@contoso.com' -Recipient $trcp -verbose ;
        Preview target recipient using a template that takes surname[0-4]givename[0-3]@contoso.com
        .EXAMPLE
        PS> preview-EAPUpdate  -addresstemplate '%5s%1g%1i@contoso.com' -Recipient $trcp -verbose ;
        Preview target recipient using a template that takes surname[0-4]givename[0]mi[0]@contoso.com
        .EXAMPLE
        PS> preview-EAPUpdate  -addresstemplate '%1g%s@contoso.com' -Recipient $trcp -verbose ;
        Preview target recipient using %1g%s@contoso.com|JWilson@contoso.com|"[1stcharGivenName][surname]@domain"|
        .EXAMPLE
        PS> preview-EAPUpdate  -addresstemplate '%r._%d@contoso.com' -Recipient $trcp -verbose ;
        Preview target recipient using %r._%d@contoso.com|JamesC_Wilson@contoso.com|"[replace periods in displayname with underscore]@domain"|
        .EXAMPLE
        PS> preview-EAPUpdate  -addresstemplate "%g.%r''%s@domain.co" -Recipient $trcp -verbose ;
        Preview target recipient using %g.%r''%s@domain.com|James.Wilson@domain|"[givenname].[surname,delete all APOSTROPHES]@domain"|
        .EXAMPLE
        PS> preview-EAPUpdate  -addresstemplate " %r''%g.%r''%s@domain.com" -Recipient $trcp -verbose ;
        Preview target recipient using %r''%g.%r''%s@domain.com|James.Wilson@domain|"[givenname,delete all APOSTROPHES].[surname,delete all APOSTROPHES]@domain"
        .EXAMPLE
        PS> preview-EAPUpdate  -addresstemplate ' %d@contoso.com' -Recipient $trcp -verbose ;
        Preview target recipient using %d@domain.com|JamesCWilson@domain.com|"Displayname@domain"
        .EXAMPLE
        PS> $genEml = preview-EAPUpdate  -addresstemplate ' %d@contoso.com' -Recipient $trcp -verbose ;
            if(($geneml -ne $trcp.primarysmtpaddress)){
                write-warning "Specified recip's PrimarySmtpAddress does *not* appear to match specified template!`nmanualy *review* the template specs`nand validate that the desired scheme is being applied!"
            }else {
                "PrimarysmtpAddr $($trcp.primarysmtpaddress) roughly conforms to specified template primary addr..."
            } ;
        Example testing output against $trcp primarySmtpAddress.
        .LINK
        https://github.com/tostka/verb-ex2010
        .LINK
        https://docs.microsoft.com/en-us/exchange/email-addresses-and-address-books/email-address-policies/email-address-policies?view=exchserver-2019
        #>
        ###Requires -Version 5
        ###Requires -Modules verb-Ex2010 - disabled, moving into the module
        ##Requires -RunasAdministrator
        # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
        ## [OutputType('bool')] # optional specified output type
        [CmdletBinding(DefaultParameterSetName='EAP')]
        PARAM(
            [Parameter(ParameterSetName='EAP',Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Exchange EmailAddressPolicy object[-eap `$eaps[16]]")]
            [ValidateNotNullOrEmpty()]
            #[Alias('ALIAS1', 'ALIAS2')]
            $EAP,
            [Parameter(ParameterSetName='Template',Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Specify raw AddressTemplate string, for output modeling[-AddressTemplate '%3g%5s@microsoft.com']")]
            [ValidateNotNullOrEmpty()]
            #[Alias('ALIAS1', 'ALIAS2')]
            $AddressTemplate,
            [Parameter(Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Array of recipient descriptors: displayname, emailaddress, UPN, samaccountname[-recip some.user@domain.com]")]
            #[ValidateNotNullOrEmpty()]
            #[Alias('ALIAS1', 'ALIAS2')]
            $Recipient,
            [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
            [switch] $useEXOv2
        ) ;
        BEGIN { 
            # function self-name (equiv to script's: $MyInvocation.MyCommand.Path) ;
            ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
            $rgxEmailDirLegalChars = "[0-9a-zA-Z-._+&']" ; 
            reconnect-ex2010 -verbose:$false ; 
    
        } ;  # BEGIN-E
        PROCESS {
            $Error.Clear() ; 
            if($EAP){
                $ptmpl= $eap.EnabledPrimarySMTPAddressTemplate ;
            } elseif($AddressTemplate){
                $ptmpl= $AddressTemplate ;
            } ; 
            $error.clear() ;
            TRY {
                if($Recipient.alias){
                    $Recipient = get-recipient $Recipient.alias ;
                } else { throw "-recipient invalid, has no Alias property!`nMust be a valid Exchange Recipient object" } ; 
                $usr = get-user -id $Recipient.alias -ErrorAction STOP ; 
            } CATCH {
                $ErrTrapd=$Error[0] ;
                $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                #-=-record a STATUSWARN=-=-=-=-=-=-=
                $statusdelta = ";WARN"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
                if(gv passstatus -scope Script -ea 0){$script:PassStatus += $statusdelta } ;
                if(gv -Name PassStatus_$($tenorg) -scope Script -ea 0){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ; 
                #-=-=-=-=-=-=-=-=
                $smsg = "FULL ERROR TRAPPED (EXPLICIT CATCH BLOCK WOULD LOOK LIKE): } catch[$($ErrTrapd.Exception.GetType().FullName)]{" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level ERROR } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                Break #Opts: STOP(debug)|EXIT(close)|CONTINUE(move on in loop cycle)|BREAK(exit loop iteration)|THROW $_/'CustomMsg'(end script with Err output)
            } ; 
            $genAddr = $null ; 
            # [0-9a-zA-Z-._+&]{1,64} # alias rgx legal
            # [0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+
            # dirname
            # ^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+ 
            # @domain: @([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}$

            #if($ptmpl -match '^@.*$'){$genAddr = $ptmpl = $ptmpl.replace('@',"$($Recipient.alias)@")} ;
            if($ptmpl -match '^@.*$'){
                write-verbose "(matched Alias@domain)" ;
                $string = ($Recipient.alias.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                $genAddr = $ptmpl = $ptmpl.replace('@',"$($string)@")
            } ;
            # do replace first, as the %d etc are simpler matches and don't handle the leading %r properly.
            if($ptmpl -match "%r([a-zA-Z_0-9-._+&])([a-zA-Z_0-9-._+&])%(d|g|i|m|s)@.*$"){
                $x = $matches[1] ; 
                $y = $matches[2] ; 
                $vari = $matches[3] ; 
                write-verbose "Parsed:`nx:$($x)`ny:$($y)`nvari:$($vari)" ;
                switch ($vari){
                    'd' {
                        write-verbose "(matched replace $($x) w $($y) on displayname)" ;
                        #$ptmpl = $ptmpl.replace("%d",$usr.displayname.replace($x,$y)) ;
                        $string = ($usr.displayname.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                        #$genAddr = $ptmpl = $ptmpl = $ptmpl.replace("%d",$string.replace($x,$y))
                        # subout %rxy first, then the trailing %d w name
                        $genAddr = $ptmpl = $ptmpl = $ptmpl -replace "%r([a-zA-Z_0-9-._+&])([a-zA-Z_0-9-._+&])",'' -replace "%d",$string.replace($x,$y)
                    }
                    'g'  {
                        write-verbose "(matched replace $($x) w $($y) on givenname)" ;
                        #$ptmpl = $ptmpl.replace("%g",$usr.firstname.replace($x,$y)) ;
                        $string = ($usr.firstname.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                        #$genAddr = $ptmpl = $ptmpl = $ptmpl.replace("%g",$string.replace($x,$y))
                        $genAddr = $ptmpl = $ptmpl = $ptmpl -replace "%r([a-zA-Z_0-9-._+&])([a-zA-Z_0-9-._+&])",'' -replace "%g",$string.replace($x,$y)
                    }
                    'i' {
                        write-verbose "(matched replace $($x) w $($y) on initials)" ;
                        #$ptmpl = $ptmpl.replace("%i",$usr.Initials.replace($x,$y)) ;
                        $string = ($usr.Initials.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                        #$genAddr = $ptmpl = $ptmpl = $ptmpl.replace("%i",$string.replace($x,$y))
                        $genAddr = $ptmpl = $ptmpl = $ptmpl -replace "%r([a-zA-Z_0-9-._+&])([a-zA-Z_0-9-._+&])",'' -replace "%i",$string.replace($x,$y)
                    }
                    'm' {
                        write-verbose "(matched replace $($x) w $($y) on alias)" ;
                        #$ptmpl = $ptmpl.replace("%m",$Recipient.alias.replace($x,$y)) ;
                        $string = ($Recipient.alias.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                        #$genAddr = $ptmpl = $ptmpl = $ptmpl.replace("%m",$string.replace($x,$y))
                        $genAddr = $ptmpl = $ptmpl = $ptmpl -replace "%r([a-zA-Z_0-9-._+&])([a-zA-Z_0-9-._+&])",'' -replace "%m",$string.replace($x,$y)
                    }
                    's' {
                        write-verbose "(matched replace $($x) w $($y) on surname)" ;
                        #$ptmpl = $ptmpl.replace("%s",$usr.lastname.replace($x,$y)) ;
                        $string = ($usr.lastname.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                        #$genAddr = $ptmpl = $ptmpl = $ptmpl.replace("%s",$string.replace($x,$y))
                        $genAddr = $ptmpl = $ptmpl = $ptmpl -replace "%r([a-zA-Z_0-9-._+&])([a-zA-Z_0-9-._+&])",'' -replace "%s",$string.replace($x,$y)
                    }
                    default {
                        throw "unrecognized template: replace (%r) character with no targeted variable (%(d|g|i|m|s))" ;
                    }
                } ;
            } ; 
            if($ptmpl.contains('%g')){
                write-verbose "(matched %g:displayname)" ;
                #$genAddr = $ptmpl = $ptmpl.replace('%g',$usr.firstname)
                $string = ($usr.firstname.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                $genAddr = $ptmpl = $ptmpl.replace('%g',$string)
            } ;
            if($ptmpl.contains('%s')){
                write-verbose "(matched %s:surname)" ;
                #$genAddr = $ptmpl = $ptmpl.replace('%s',$usr.lastname)} ;
                $string = ($usr.lastname.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                $genAddr = $ptmpl = $ptmpl.replace('%s',$string)
            };
            if($ptmpl.contains('%d')){
                write-verbose "(matched %d:displayname)" ;
                #$genAddr = $ptmpl = $ptmpl.replace('%d',$usr.displayname)
                $string = ($usr.displayname.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                $genAddr = $ptmpl = $ptmpl.replace('%d',$string)
            } ;
            if($ptmpl.contains('%i')){
                write-verbose "(matched %i:initials)" ;
                #$genAddr = $ptmpl = $ptmpl.replace('%i',$usr.Initials)} ;
                $string = ($usr.Initials.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                $genAddr = $ptmpl = $ptmpl.replace('%i',$string)
            } ;
            if($ptmpl.contains('%m')){
                write-verbose "(matched %m:alias)" ;
                #$genAddr = $ptmpl = $ptmpl.replace('%m',$Recipient.alias)} ;
                $string = ($Recipient.alias.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                $genAddr = $ptmpl = $ptmpl.replace('%m',$string)
            } ; 
            if($ptmpl -match '(%(\d)g)'){
                $ltrs = $matches[2] ; 
                write-verbose "(matched %g:displayname, first $($ltrs) chars)" ;
                #$genAddr = $ptmpl = $ptmpl -replace "(%\dg)","$1,$($usr.firstname.substring(0,$ltrs))" ;
                #$genAddr = $ptmpl = $ptmpl -replace "(%\dg)","$($usr.firstname.substring(0,$ltrs))"
                $string = ($usr.firstname.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                $genAddr = $ptmpl = $ptmpl -replace "(%\dg)","$($string.substring(0,$ltrs))"
            } ; 
            if($ptmpl -match "(%(\d)s)"){
                $ltrs = $matches[2] ; 
                write-verbose "(matched %s:surname, first $($ltrs) chars)" ;
                #$genAddr = $ptmpl = $ptmpl -replace "(%\ds)","$1,$($usr.lastname.substring(0,$ltrs))"
                #$genAddr = $ptmpl =$ptmpl -replace "(%\ds)","$($usr.lastname.substring(0,$ltrs))" ;
                $string = ($usr.lastname.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                $genAddr = $ptmpl = $ptmpl -replace "(%\ds)","$($string.substring(0,$ltrs))"
            } ; 
            if($ptmpl -match "(%(\d)i)"){
                $ltrs = $matches[2] ; 
                write-verbose "(matched %i:initials, first $($ltrs) chars)" ;
                #$genAddr = $ptmpl = $ptmpl -replace "(%\ds)","$1,$($usr.lastname.substring(0,$ltrs))"
                #$genAddr = $ptmpl =$ptmpl -replace "(%\di)","$($usr.initials.substring(0,$ltrs))" ;
                $string = ($usr.initials.ToCharArray() |?{$_ -match $rgxEmailDirLegalChars})  -join '' ;
                $genAddr = $ptmpl = $ptmpl -replace "(%\di)","$($string.substring(0,$ltrs))"
            } ; 

        } ;  # PROC-E
        END {
            if($genAddr){
                write-verbose "returning generated address:$($genAddr)" ; 
                $genAddr| write-output 
            } else {
                write-warning "Unable to generate a PrimarySmtpAddress model for user" ; 
                $false | write-output l
            };
        } ;  
    }

#*------^ preview-EAPUpdate.ps1 ^------


#*------v Reconnect-Ex2010.ps1 v------
Function Reconnect-Ex2010 {
  <#
    .SYNOPSIS
    Reconnect-Ex2010 - Reconnect Remote ExchOnPrem Mgmt Shell connection (validated functional Exch2010 - Exch2016)
    .NOTES
    Author: Todd Kadrie
    Website:	http://toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    AddedCredit : Inspired by concept code by ExactMike Perficient, Global Knowl... (Partner)
    AddedWebsite:	https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    Version     : 1.1.0
    CreatedDate : 2020-02-24
    FileName    : Reonnect-Ex2010()
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell
    REVISIONS   :
    * 3:11 PM 7/15/2024 needed to change CHKPREREQ to check for presence of prop, not that it had a value (which fails as $false); hadn't cleared $MetaProps = ...,'DOESNTEXIST' ; confirmed cxo working non-based
    * 10:47 AM 7/11/2024 cleared debugging NoSuch etc meta tests
    * 1:34 PM 6/21/2024 ren $Global:E10Sess -> $Global:EXOPSess ;updated $rgxRemsPSSName = "^(Session\d|Exchange\d{4}|Exchange\d{2}((\.\d+)*))$" ;
    * 11:02 AM 10/25/2021 dbl/triple-connecting, fliped $E10Sess -> $global:E10Sess (must not be detecting the preexisting session), added post test of session to E10Sess values, to suppres redund dxo/rxo.
    * 1:17 PM 8/17/2021 added -silent param
    * 4:31 PM 5/18/2l lost $global:credOpTORSID, sub in $global:credTORSID
    * 10:52 AM 4/2/2021 updated cbh
    * 1:56 PM 3/31/2021 rewrote to dyn detect pss, rather than reading out of date vari
    * 10:14 AM 3/23/2021 fix default $Cred spec, pointed at an OP cred
    * 8:29 AM 11/17/2020 added missing $Credential param
    * 9:33 AM 5/28/2020 actually added the alias:rx10
    * 12:20 PM 5/27/2020 updated cbh, moved alias: rx10 win func
    * 6:59 PM 1/15/2020 cleanup
    * 8:09 AM 11/1/2017 updated example to pretest for reqMods
    * 1:26 PM 12/9/2016 split no-session and reopen code, to suppress notfound errors, add pshelpported to local EMSRemote
    * 2/10/14 posted version
    .DESCRIPTION
    Reconnect-Ex2010 - Reconnect Remote Exch2010 Mgmt Shell connection
    .PARAMETER  Credential
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    $reqMods="connect-Ex2010;Disconnect-Ex2010;".split(";") ;
    $reqMods | % {if( !(test-path function:$_ ) ) {write-error "$((get-date).ToString("yyyyMMdd HH:mm:ss")):Missing $($_) function. EXITING." } } ;
    Reconnect-Ex2010 ;
    .LINK
    #>
    [CmdletBinding()]
    [Alias('rx10','rxOP','reconnect-ExOP')]
    Param(
        [Parameter(HelpMessage="Credential to use for this connection [-credential [credential obj variable]")][System.Management.Automation.PSCredential]
        $Credential = $global:credTORSID,
        [Parameter(HelpMessage="Silent output (suppress status echos)[-silent]")]
        [switch] $silent
    )
    BEGIN{
        # checking stat on canned copy of hist sess, says nothing about current, possibly timed out, check them manually
        $rgxRemsPSSName = "^(Session\d|Exchange\d{4}|Exchange\d{2}((\.\d+)*))$" ;

        #region CHKPREREQ ; #*------v CHKPREREQ v------
        # critical dependancy Meta variables
        $MetaNames = ,'TOR','CMW','TOL' #,'NOSUCH' ;
        # critical dependancy Meta variable properties
        $MetaProps = 'Ex10Server','Ex10WebPoolVariant','ExRevision','ExViewForest','ExOPAccessFromToro','legacyDomain' #,'DOESNTEXIST' ;
        # critical dependancy parameters
        $gvNames = 'Credential'
        $isBased = $true ; $gvMiss = @() ; $ppMiss = @() ;
        foreach($met in $metanames){
            write-verbose "chk:`$$($met)Meta" ;
            if(-not (gv -name "$($met)Meta" -ea 0)){$isBased = $false; $gvMiss += "$($met)Meta" } ;
            if($MetaProps){
                foreach($mp in $MetaProps){
                    write-verbose "chk:`$$($met)Meta.$($mp)" ;
                    #if(-not (gv -name "$($met)Meta" -ea 0).value[$mp]){ # testing has a value, not is present as a spec!
                    if(-not (gv -name "$($met)Meta" -ea 0).value.keys -contains $mp){
                        $isBased = $false; $ppMiss += "$($met)Meta.$($mp)"
                    } ;
                } ;
            } ;
        } ;
        if($gvNames){
            foreach($gvN in $gvNames){
                write-verbose "chk:`$$($gvN)" ;
                if(-not (gv -name "$($gvN)" -ea 0)){$isBased = $false; $gvMiss += "$($gvN)" } ;
            } ;
        } ;
        if($gvmiss){write-warning "Missing Dependant Meta variables:`n$(($gvMiss |%{"`$$($_)" }) -join ',')" } ;
        if($ppMiss){write-warning "Missing Dependant Meta vari properties:`n$(($ppMiss |%{"`$$($_)" }) -join ',')" } ;
        if(-not $isBased){ write-warning  "missing critical dependancy profile config!" } ;
        #endregion CHKPREREQ ; #*------^ END CHKPREREQ ^------

        if($isBased){
            # back the TenOrg out of the Credential        
            $TenOrg = get-TenantTag -Credential $Credential ;
        } ; 
    }  # BEG-E
    PROCESS{
        if($isBased){
            $Rems2Good = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND ($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName) -AND ($_.Availability -eq 'Available') } ;
            $Rems2WrongOrg = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND (
                $_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND (
                ( -not($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName) ) -AND (
                -not($_.ComputerName -match $rgxExoPsHostName)) ) -AND ($_.Availability -eq 'Available')
            } ;
        }else {
            $Rems2Good = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND ($_.Availability -eq 'Available') } ;
        } ; 

        $Rems2Broken = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND (
            $_.Name -match $rgxRemsPSSName) -AND ($_.State -like "*Broken*") } ;
        $Rems2Closed = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND (
            $_.Name -match $rgxRemsPSSName) -AND ($_.State -like "*Closed*") } ;
        if ($Rems2Broken.count -gt 0){ for ($index = 0 ;$index -lt $Rems2Broken.count ;$index++){Remove-PSSession -session $Rems2Broken[$index]}  };
        if ($Rems2Closed.count -gt 0){for ($index = 0 ;$index -lt $Rems2Closed.count ; $index++){Remove-PSSession -session $Rems2Closed[$index] } } ;
        if ($Rems2WrongOrg.count -gt 0){for ($index = 0 ;$index -lt $Rems2WrongOrg.count ; $index++){Remove-PSSession -session $Rems2WrongOrg[$index] } } ;
        #if( -not ($Global:EXOPSess ) -AND -not ($Rems2Good)){
        if(-not $Rems2Good){
            if (-not $Credential) {
                Connect-Ex2010 # sets $Global:EXOPSess on connect
            } else {
                Connect-Ex2010 -Credential:$($Credential) ; # sets $Global:EXOPSess on connect
            } ;
            if($Global:EXOPSess -AND ($tSess = get-pssession -id $Global:EXOPSess.id -ea 0 |?{$_.computername -eq $Global:EXOPSess.computername -ANd $_.name -eq $Global:EXOPSess.name})){
                # matches historical session
                if( $tSess | where-object { ($_.State -eq "Opened") -AND ($_.Availability -eq 'Available') } ){
                    $bExistingREms= $true ;
                } else {
                    $bExistingREms= $false ;
                } ;
            }elseif($tSess = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) }){ 
                if( $tSess | where-object { ($_.State -eq "Opened") -AND ($_.Availability -eq 'Available') } ){
                    $Global:EXOPSess = $tSess ;
                    $bExistingREms= $true ;
                } else {
                    $bExistingREms= $false ;
                    $Global:EXOPSess = $null ; 
                } ;
            } ; 
        }elseif($tSess = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) }){
            # matches generic session
            if( $tSess | where-object { ($_.State -eq "Opened") -AND ($_.Availability -eq 'Available') } ){
                if(-not $Global:EXOPSess){$Global:E10Sess = $tSess } ; 
                $bExistingREms= $true ;
            } else {
                $bExistingREms= $false ;
            } ;
        } else {
            # doesn't match histo
            $bExistingREms= $false ;
        } ;
        $propsPss =  'Id','Name','ComputerName','ComputerType','State','ConfigurationName','Availability' ;
    
        if($bExistingREms){
            if($silent){} else { 
                $smsg = "existing connection Open/Available:`n$(($tSess| ft -auto $propsPss |out-string).trim())" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
        } else {
            $smsg = "(resetting any existing EX10 connection and re-establishing)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Disconnect-Ex2010 ; Start-Sleep -S 3;
            if (-not $Credential) {
                Connect-Ex2010 ;
            } else {
                Connect-Ex2010 -Credential:$($Credential) ;
            } ;
        } ;
    }  # PROC-E
}

#*------^ Reconnect-Ex2010.ps1 ^------


#*------v Reconnect-Ex2010XO.ps1 v------
Function Reconnect-Ex2010XO {
   <#
    .SYNOPSIS
    Reconnect-Ex2010XO - Reconnect Remote Exch2010 Mgmt Shell connection Cross-Org (XO)
    .NOTES
    Updated By: : Todd Kadrie
    Website:	http://toddomation.com
    Twitter:	@tostka http://twitter.com/tostka
    Based on original function Author: ExactMike Perficient, Global Knowl... (Partner)
    Website:	https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    REVISIONS   :
    # 3:18 PM 5/18/2021 somehow lost $credOpTORSID, so flipped lost default $credOPTor -> $credTORSID
    * 1:57 PM 3/31/2021 wrapped long lines for vis
    * 8:30 AM 10/22/2020 ren'd $TentantTag -> $TenOrg, swapped looping meta resolve with 1-liner approach ; added AcceptedDom caching to the middle status test (suppress one more get-exoaccepteddomain call if possible), replaced all $Meta.value with the $TenOrg version
    * 1:19 PM 10/15/2020 converted connect-exo to Ex2010, adding onprem validation
    .DESCRIPTION
    Reconnect-Ex2010XO - Reconnect Remote Exch2010 Mgmt Shell connection Cross-Org (XO)
    .PARAMETER  Credential
    Credential to use for this connection [-credential 'account@domain.com']
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    Reconnect-Ex2010XO;
    Reconnect EXO connection
    .EXAMPLE
    $batchsize = 10 ;
    $RecordCount=$mr.count #this is the array of whatever you are processing ;
    $b=0 #this is the initialization of a variable used in the do until loop below ;
    $mrs = @() ;
    do {
        Write-Progress -Activity "Getting move request statistics for all $wave move requests." -Status "Processing Records $b through $($b+$batchsize) of $RecordCount." -PercentComplete ($b/$RecordCount*100) ;
        $mrs += $mr | Select-Object -skip $b -first $batchsize | foreach-object {Reconnect-Ex2010XO; $_ | Get-OLMoveRequestStatistics} ;
        $b=$b+$batchsize ;
        } ;
    until ($b -gt $RecordCount) ;

    .LINK
    https://social.technet.microsoft.com/Forums/msonline/en-US/f3292898-9b8c-482a-86f0-3caccc0bd3e5/exchange-powershell-monitoring-remote-sessions?forum=onlineservicesexchange
    #>
    [CmdletBinding()]
    [Alias('rx10xo')]
    <#
    Param(
      [Parameter(HelpMessage="Use Proxy-Aware SessionOption settings [-ProxyEnabled]")]
      [boolean]$ProxyEnabled = $False,
      [Parameter(HelpMessage="Credential to use for this connection [-credential [credential obj variable]")]
      [System.Management.Automation.PSCredential]$Credential = $global:credo365TORSID,
      [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
      [switch] $showDebug
    ) ;
    #>
     Param(
        [Parameter(HelpMessage = 'Credential object')][System.Management.Automation.PSCredential]$Credential = $credTORSID,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
        [switch] $showDebug
    )  ;
    BEGIN{
        $verbose = ($VerbosePreference -eq "Continue") ;
        #if(!$rgxExoPsHostName){$rgxExoPsHostName="^(ps\.outlook\.com|outlook\.office365\.com)$" } ;
        # $rgxEx10HostName : ^(lyn|bcc|adl|spb)ms6[4,5][0,1].global.ad.toro.com$
        # we'd need to define all possible hostnames to cover potential span. Should probably build dynamically from $XXXMeta vari
        # can build from $TorMeta.OP_ExADRoot:global.ad.toro.com
        <# on curly, from Ps into EMS:
        get-pssession | fl computername,computertype,state,configurationname,availability,name
        ComputerName      : curlyhoward.cmw.internal
        ComputerType      : RemoteMachine
        State             : Opened
        ConfigurationName : Microsoft.Exchange
        Availability      : Available
        Name              : Session1

        ComputerName      : lynms650.global.ad.toro.com
        ComputerType      : RemoteMachine
        State             : Broken
        ConfigurationName : Microsoft.Exchange
        Availability      : None
        Name              : Exchange2010

        "^\w*\.$($CMWMeta.OP_ExADRoot)$"
        => ^\w*\.cmw.internal$
        #>

        $sTitleBarTag = "EMS" ;
        $CommandPrefix = $null ;

        $TenOrg=get-TenantTag -Credential $Credential ;
        if($TenOrg -ne 'TOR'){
            # explicitly leave this tenant (default) untagged
            $sTitleBarTag += $TenOrg ;
        } ;
        <#
        $credDom = ($Credential.username.split("\"))[0] ;
        $Metas=(get-variable *meta|Where-Object{$_.name -match '^\w{3}Meta$'}) ;
        foreach ($Meta in $Metas){
            if( ($credDom -eq $Meta.value.legacyDomain) -OR ($credDom -eq $Meta.value.o365_TenantDomain) -OR ($credDom -eq $Meta.value.o365_OPDomain)){
                if($Meta.value.OP_ExADRoot){
                    if(!$Meta.value.OP_rgxEMSComputerName){
                        write-verbose "(adding XXXMeta.OP_rgxEMSComputerName value)"
                        # build vari that will match curlyhoward.cmw.internal|lynms650.global.ad.toro.com etc
                        set-variable -Name $meta.name -Value ((get-variable -name $meta.name).value  += @{'OP_rgxEMSComputerName' = "^\w*\.$([Regex]::Escape($Meta.value.OP_ExADRoot))$"} ) ;
                    } ;
                } else {
                    throw "Missing `$$($Meta.value.o365_Prefix).OP_ExADRoot value.`nProfile hasn't loaded proper tor-incl-infrastrings file)!"
                } ;
            } ; # if-E $credDom
        } ; # loop-E
        #>
        # non-looping vers:
        #$TenOrg = get-TenantTag -Credential $Credential ;
        #.OP_ExADRoot
        if( (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName ){

        } else {
            #.OP_rgxEMSComputerName
            if((Get-Variable  -name "$($TenOrg)Meta").value.OP_ExADRoot){
                set-Variable  -name "$($TenOrg)Meta" -value ( (Get-Variable  -name "$($TenOrg)Meta").value += @{'OP_rgxEMSComputerName' = "^\w*\.$([Regex]::Escape((Get-Variable  -name "$($TenOrg)Meta").value.OP_ExADRoot))$"} )
            } else {
                $smsg = "Missing `$$((Get-Variable  -name "$($TenOrg)Meta").value.o365_Prefix).OP_ExADRoot value.`nProfile hasn't loaded proper tor-incl-infrastrings file)!"
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } #Error|Warn|Debug
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } ;
    } ;  # BEG-E

    PROCESS{
        $verbose = ($VerbosePreference -eq "Continue") ;
        # if we're using ems-style BasicAuth, clear incompatible existing Rems PSS's
        # ComputerName      : curlyhoward.cmw.internal ;  ComputerType      : RemoteMachine ;  State             : Opened ;  ConfigurationName : Microsoft.Exchange ;  Availability      : Available ;  Name              : Session1 ;   ;
        $rgxRemsPSSName = "^(Session\d|Exchange\d{4})$" ;
        $Rems2Good = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND ($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName) -AND ($_.Availability -eq 'Available') } ;
        # Computername wrong fqdn suffix
        #$Rems2WrongOrg = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND (-not($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName)) -AND ($_.Availability -eq 'Available') } ;
        # above is seeing outlook EXO conns as wrong org, exempt them too: .ComputerName -match $rgxExoPsHostName
        $Rems2WrongOrg = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND (
            $_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND (
            ( -not($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName) ) -AND (
            -not($_.ComputerName -match $rgxExoPsHostName)) ) -AND ($_.Availability -eq 'Available')
        } ;
        $Rems2Broken = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND (
                $_.Name -match $rgxRemsPSSName) -AND ($_.State -like "*Broken*") } ;
        $Rems2Closed = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND (
                $_.Name -match $rgxRemsPSSName) -AND ($_.State -like "*Closed*") } ;

        write-verbose "(Removing $($Rems2Broken.count) Broken sessions)" ;
        if ($Rems2Broken.count -gt 0){ for ($index = 0 ;$index -lt $Rems2Broken.count ;$index++){Remove-PSSession -session $Rems2Broken[$index]}  };
        write-verbose "(Removing $($Rems2Closed.count) Closed sessions)" ;
        if ($Rems2Closed.count -gt 0){for ($index = 0 ;$index -lt $Rems2Closed.count ; $index++){Remove-PSSession -session $Rems2Closed[$index] } } ;
        write-verbose "(Removing $($Rems2WrongOrg.count) sessions connected to the WRONG ORG)" ;
        if ($Rems2WrongOrg.count -gt 0){for ($index = 0 ;$index -lt $Rems2WrongOrg.count ; $index++){Remove-PSSession -session $Rems2WrongOrg[$index] } } ;
        # preclear until proven *up*
        $bExistingREms = $false ;

        if( Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND ($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName) -AND ($_.Availability -eq 'Available') } ){

            $bExistingREms= $true ;
            write-verbose "(Authenticated to Ex20XX:$($Credential.username.split('\')[0].tostring()))" ;

        } else {
            write-verbose "(NOT Authenticated to Credentialed Ex20XX Org:$($Credential.username.split('\')[0].tostring()))" ;
            $tryNo=0 ; $1F=$false ;
            Do {
                if($1F){Sleep -s 5} ;
                $tryNo++ ;
                write-host "." -NoNewLine; if($tryNo -gt 1){Start-Sleep -m (1000 * 5)} ;
                write-verbose "$((get-date).ToString('HH:mm:ss')):Reconnecting:No existing PSSESSION matching`n (ConfigurationName -eq 'Microsoft.Exchange') -AND (Name -match $($rgxRemsPSSName)) -AND ($_.ComputerName -match $((Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName))`nwith valid Open/Availability:$((Get-PSSession | where-object { ($_.ConfigurationName -eq 'Microsoft.Exchange') -AND ($_.Name -match $rgxRemsPSSName)} |ft -a Id,Name,ComputerName,ComputerType,State,ConfigurationName,Availability|out-string).trim())" ;
                Disconnect-Ex2010 ; Disconnect-PssBroken ;Start-Sleep -Seconds 3;

                $bExistingREms = $false ;

                Connect-Ex2010xo -credential:$($Credential) ;

                $1F=$true ;
                if($tryNo -gt $DoRetries ){throw "RETRIED EX20XX CONNECT $($tryNo) TIMES, ABORTING!" } ;
            } Until ( Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND ($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName) -AND ($_.Availability -eq 'Available') } ) ;

        } ;

    } ;  # PROC-E
    END {
        if($bExistingREms -eq $false){
            if( Get-PSSession | where-object {$_.ConfigurationName -eq "Microsoft.Exchange" -AND $_.Name -match $rgxRemsPSSName -AND $_.State -eq "Opened" -AND ($_.ComputerName -match (Get-Variable  -name "$($TenOrg)Meta").value.OP_rgxEMSComputerName) -AND ($_.Availability -eq 'Available') }  ){
                $bExistingREms= $true ;
            } else {
                write-error "(Credential mismatch:disconnecting from existing Ex201X:$($eEXO.Identity) tenant)" ;
                Disconnect-Ex2010 ;
                $bExistingREms = $false ;
            } ;
        } ;
    } ; # END-E
}

#*------^ Reconnect-Ex2010XO.ps1 ^------


#*------v remove-EMSLocalModule.ps1 v------
Function remove-EMSLocalModule {
  <#
    .SYNOPSIS
    remove-EMSLocalModule - remove/unload local server bin-module-based ExchOnPrem Mgmt Shell connection ; validated Exch2016)
    .NOTES
    Author: Todd Kadrie
    Website:	http://toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    Version     : 1.0.0
    CreatedDate : 2021-04-15
    FileName    : remove-EMSLocalModule()
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Exchange,Exchange-2013,Exchange-2016
    REVISIONS   :
    * 9:42 AM 7/27/2021 add verbose to *-PsTitleBar calls
    * 10:03 AM 4/16/2021 init vers
    .DESCRIPTION
    remove-EMSLocalModule - remove/unload local server bin-module-based ExchOnPrem Mgmt Shell connection ; validated Exch2016)
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    remove-EMSLocalModule ;
    .LINK
    https://github.com/tostka/verb-Ex2010/
    #>
    [CmdletBinding()]
    #[Alias()]
    Param()  ;
    BEGIN{
        $verbose = ($VerbosePreference -eq "Continue") ;
    } ;  # BEG-E
    PROCESS{
        $error.clear() ;
        TRY {
            if($tMod = get-module ([System.Net.Dns]::gethostentry($(hostname))).hostname -ea 0){
                write-verbose "(Removing matched EMS module already loaded:)`n$(($tMod | ft -auto ModuleType,Version,Name,ExportedCommands|out-string).trim())" ;
                $tMod | Remove-Module ;
            } else {
                write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):(No matching loaded local Exchange Mgmt Shell binary module found)" ;
            } ;
        } CATCH {
            $ErrTrapd = $_ ;
            write-warning "$(get-date -format 'HH:mm:ss'): Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            #-=-record a STATUSERROR=-=-=-=-=-=-=
            $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0 ){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script  -ea 0 ){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
            #-=-=-=-=-=-=-=-=
        } ;
        # 7:54 AM 11/1/2017 add titlebar tag
        if(gcm Remove-PSTitleBar-PSTitleBar -ea 0 ){Remove-PSTitleBar-PSTitleBar 'EMSL' -verbose:$($VerbosePreference -eq "Continue") ;} ;
        # tag E10IsDehydrated
        $Global:ExOPIsDehydrated = $null ;
    } ;  # PROC-E
    END {
        <#
        $tMod = $null ;
        if($tMod = GET-MODULE ([System.Net.Dns]::gethostentry($(hostname))).HOSTNAME){
            write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):(local EMS module loaded:)`n$(($tMod | ft -auto ModuleType,Version,Name,ExportedCommands|out-string).trim())" ;
        } else {
            throw "Unable to resolve target local EMS module:GET-MODULE $([System.Net.Dns]::gethostentry($(hostname))).HOSTNAME)" ;
        } ;
        #>
    }
}

#*------^ remove-EMSLocalModule.ps1 ^------


#*------v remove-SmtpPlusAddress.ps1 v------
function remove-SmtpPlusAddress {
        <#
        .SYNOPSIS
        remove-SmtpPlusAddress - Strips any Plus address Tag present in an smtp address, and returns the base address
        .NOTES
        Version     : 1.0.0
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2024-05-22
        FileName    : remove-SmtpPlusAddress.ps1
        License     : (none asserted)
        Copyright   : (none asserted)
        Github      : https://github.com/tostka/verb-Ex2010
        Tags        : Powershell,EmailAddress,Version
        AddedCredit : Bruno Lopes (brunokktro )
        AddedWebsite: https://www.linkedin.com/in/blopesinfo
        AddedTwitter: @brunokktro / https://twitter.com/brunokktro
        REVISIONS
        * 2:37 PM 6/2/2025 add to vx10 ; 
        * 1:47 PM 7/9/2024 CBA github field correction
        * 1:22 PM 5/22/2024init
        .DESCRIPTION
        remove-SmtpPlusAddress - Strips any Plus address Tag present in an smtp address, and returns the base address

        Plus Addressing is supported in Exchange Online, Gmail, and other select hosts. 
        It is *not* supported for Exchange Server onprem. Any + addressed email will read as an unresolvable email address. 
        Supporting systems will truncate the local part (in front of the @), after the +, to resolve the email address for normal routing:

        monitoring+whatever@domain.tld, is cleaned down to: monitor@domain.tld. 

        .PARAMETER EmailAddress
        SMTP Email Address
        .OUTPUT
        String
        .EXAMPLE
        PS> 
        PS> $returned = remove-SmtpPlusAddress -EmailAddress 'monitoring+SolarWinds@toro.com';  
        PS> $returned ; 
        Demo retrieving get-EmailAddress, assigning to output, processing it for version info, and expanding the populated returned values to local variables. 
        .EXAMPLE
        ps> remove-SmtpPlusAddress -EmailAddress 'monitoring+SolarWinds@toro.com;notanemailaddresstoro.com,todd+spam@kadrie.net' -verbose ;
        Demo with comma and semicolon delimiting, and an invalid address (to force a regex match fail error).
        .LINK
        https://github.com/brunokktro/EmailAddress/blob/master/Get-ExchangeEnvironmentReport.ps1
        .LINK
        https://github.com/tostka/verb-Ex2010
        #>
        [CmdletBinding()]
        #[Alias('rvExVers')]
        PARAM(
            [Parameter(Mandatory = $true,Position=0,HelpMessage="Object returned by a get-EmailAddress command[-EmailAddress `$ExObject]")]
                [string[]]$EmailAddress
        ) ;
        BEGIN {
            ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
            $verbose = $($VerbosePreference -eq "Continue")
            $rgxSMTPAddress = "([0-9a-zA-Z]+[-._+&='])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}" ; 
            $sBnr="#*======v $($CmdletName): v======" ;
            write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
            if($EmailAddress -match ','){
                $smsg = "(comma detected, attempting split on commas)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $EmailAddress = $EmailAddress.split(',') ; 
            } ; 
            if($EmailAddress -match ';'){
                $smsg = "(semi-colon detected, attempting split on semicolons)" ; 
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                $EmailAddress = $EmailAddress.split(';') ; 
            } ; 
        }
        PROCESS {
            foreach ($item in $EmailAddress){
                if($item -match $rgxSMTPAddress){
                    if($item.split('@')[0].contains('+')){
                        write-verbose  "Remove Plus Addresses from: $($item)" ; 
                        $lpart,$domain = $item.split('@') ; 
                        $item = "$($lpart.split('+')[0])@$($domain)" ; 
                        $smsg = "Cleaned Address: $($item)" ; 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                    }
                    $item | write-output ; 
                } else { 
                    write-warning  "$($item)`ndoes not match a standard SMTP Email Address (skipping):`n$($rgxSmtpAddress)" ; 
                    continue ;
                } ; 
            } ;     
        
        } # PROC-E
        END{
            write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
        }
    }

#*------^ remove-SmtpPlusAddress.ps1 ^------


#*------v resolve-ExchangeServerVersionTDO.ps1 v------
function resolve-ExchangeServerVersionTDO {
    <#
    .SYNOPSIS
    resolve-ExchangeServerVersionTDO - Resolves the ExchangeVersion details from a returned get-ExchangeServer, whether local undehydrated ('Microsoft.Exchange.Data.Directory.Management.ExchangeServer') or remote EMS ('System.Management.Automation.PSObject')
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2024-05-22
    FileName    : resolve-ExchangeServerVersionTDO
    License     : (none asserted)
    Copyright   : (none asserted)
    Github      : https://github.com/tostka/verb-Ex2010
    Tags        : Powershell,ExchangeServer,Version
    AddedCredit : Bruno Lopes (brunokktro )
    AddedWebsite: https://www.linkedin.com/in/blopesinfo
    AddedTwitter: @brunokktro / https://twitter.com/brunokktro
    REVISIONS
    * 1:47 PM 7/9/2024 CBA github field correction
    * 1:22 PM 5/22/2024init
    .DESCRIPTION
    resolve-ExchangeServerVersionTDO - Resolves the ExchangeVersion details from a returned get-ExchangeServer, whether local undehydrated ('Microsoft.Exchange.Data.Directory.Management.ExchangeServer') or remote EMS ('System.Management.Automation.PSObject')
    Returns a  PSCustomObject to the pipleine with the following properties:

        isEx2019             : [boolean]
        isEx2016             : [boolean]
        isEx2007             : [boolean]
        isEx2003             : [boolean]
        isEx2000             : [boolean]
        ExVers               : [string] 'Ex2010'
        ExchangeMajorVersion : [string] '14.3'
        isEx2013             : [boolean]
        isEx2010             : [boolean]

    Extends on sample code by brunokktro's Get-ExchangeEnvironmentReport.ps1

    .PARAMETER ExchangeServer
    Object returned by a get-ExchangeServer command
    .OUTPUT
    PSCustomObject version summary.
    .EXAMPLE
    PS> write-verbose 'Resolve the local ExchangeServer object to version description, and assign to `$returned' ;     
    PS> $returned = resolve-ExchangeServerVersionTDO -ExchangeServer (get-exchangeserver $env:computername) 
    PS> write-verbose "Expand returned populated properties into local variables" ; 
    PS> $returned.psobject.properties | ?{$_.value} | %{ set-variable -Name $_.name -Value $_.value -verbose } ; 
        
        VERBOSE: Performing the operation "Set variable" on target "Name: ExVers Value: Ex2010".
        VERBOSE: Performing the operation "Set variable" on target "Name: ExchangeMajorVersion Value: 14.3".
        VERBOSE: Performing the operation "Set variable" on target "Name: isEx2010 Value: True".

    Demo retrieving get-exchangeserver, assigning to output, processing it for version info, and expanding the populated returned values to local variables. 
    .LINK
    https://github.com/brunokktro/ExchangeServer/blob/master/Get-ExchangeEnvironmentReport.ps1
    .LINK
    https://github.com/tostka/verb-Ex2010
    #>
    [CmdletBinding()]
    #[Alias('rvExVers')]
    PARAM(
        [Parameter(Mandatory = $true,Position=0,HelpMessage="Object returned by a get-ExchangeServer command[-ExchangeServer `$ExObject]")]
            [array]$ExchangeServer
    ) ;
    BEGIN {
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $verbose = $($VerbosePreference -eq "Continue")
        $sBnr="#*======v $($CmdletName): v======" ;
        write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr)" ;
    }
    PROCESS {
        foreach ($item in $ExchangeServer){
            
            if($host.version.major -ge 3){$oReport=[ordered]@{Dummy = $null ;} }
            else {$oReport = New-Object Collections.Specialized.OrderedDictionary} ;
            If($oReport.Contains("Dummy")){$oReport.remove("Dummy")} ;
            #$oReport.add('sessionid',$sid) ; # add a static pre-stocked value
            # then loop out the commonly-valued/typed entries
            
            $fieldsnull = 'isEx2019','isEx2016','isEx2007','isEx2003','isEx2000','ExVers','ExchangeMajorVersion' ; $fieldsnull | % { $oReport.add($_,$null) } ;
            #$fieldsArray = 'key4','key5','key6' ; $fieldsArray | % { $oReport.add($_,@() ) } ;
            #$oReport.add('',) ; # explicit variable
            #$oReport.add('','') ; # explicit value
            #$oReport.key1 = 'value' ;  # assign value 

            # this may be undehydrated $RemoteExchangePath, or REMS dehydrated, w fundementally diff properties
            switch($item.admindisplayversion.gettype().fullname){

                'Microsoft.Exchange.Data.ServerVersion'{
                    #    '6.0'  = @{Long = 'Exchange 2000'; Short = 'E2000' }
                         #  '6.5'  = @{Long = 'Exchange 2003'; Short = 'E2003' }
            #               '8'    = @{Long = 'Exchange 2007'; Short = 'E2007' }
            #               '14'   = @{Long = 'Exchange 2010'; Short = 'E2010' } # Ex2010 version.Minor == SP#
            #               '15'   = @{Long = 'Exchange 2013'; Short = 'E2013' } # Ex2010 version.Minor == SP#
            #               '15.1' = @{Long = 'Exchange 2016'; Short = 'E2016' } 
            #               '15.2' = @{Long = 'Exchange 2019'; Short = 'E2019' } #2019-05-17 TST Exchange Server 2019 added
                    #
                    if ($item.AdminDisplayVersion.Major -eq 6) {
                        # 6(.0) == Ex2000  ; 6.5 == Ex2003 
                        $oReport.ExchangeMajorVersion = [double]('{0}.{1}' -f $item.AdminDisplayVersion.Major, $item.AdminDisplayVersion.Minor)
                        $ExchangeSPLevel = $item.AdminDisplayVersion.FilePatchLevelDescription.Replace('Service Pack ', '')
                    } elseif ($item.AdminDisplayVersion.Major -eq 15 -and $item.AdminDisplayVersion.Minor -ge 1) {
                        # 15.1 == Ex2016 ; 15.2 == Ex2019
                        $oReport.ExchangeMajorVersion = [double]('{0}.{1}' -f $item.AdminDisplayVersion.Major, $item.AdminDisplayVersion.Minor)
                        $ExchangeSPLevel = 0
                    } else {
                        # 8(.0) == Ex2007 ; 14(.0) == Ex2010 ; 15(.0) == Ex2013 
                        $oReport.ExchangeMajorVersion = $item.AdminDisplayVersion.Major ; 
                        $ExchangeSPLevel = $item.AdminDisplayVersion.Minor ; 
                    } ; 

                    $oReport.isEx2000 = $oReport.isEx2003 = $oReport.isEx2007 = $oReport.isEx2010 = $oReport.isEx2013 = $oReport.isEx2016 = $oReport.isEx2019 = $false ; 
                    $oReport.ExVers = $null ; 
                    switch ([string]$oReport.ExchangeMajorVersion) {
                        '15.2' { $oReport.isEx2019 = $true ; $oReport.ExVers = 'Ex2019' }
                        '15.1' { $oReport.isEx2016 = $true ; $oReport.ExVers = 'Ex2016'}
                        '15' { $oReport.isEx2013 = $true ; $oReport.ExVers = 'Ex2013'}
                        '14' { $oReport.isEx2010 = $true ; $oReport.ExVers = 'Ex2010'}
                        '8' { $oReport.isEx2007 = $true ; $oReport.ExVers = 'Ex2007'}  
                        '6.5' { $oReport.isEx2003 = $true ; $oReport.ExVers = 'Ex2003'} 
                        '6' {$oReport.isEx2000 = $true ; $oReport.ExVers = 'Ex2000'} ;
                        default { 
                            $smsg = "UNRECOGNIZED ExchangeServer.AdminDisplayVersion.Major.Minor string:$($oReport.ExchangeMajorVersion)! ABORTING!" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            THROW $SMSG ; 
                            BREAK ; 
                        }
                    } ; 
                }
                'System.String'{
                    $oReport.ExVers = $oReport.isEx2000 = $oReport.isEx2003 = $oReport.isEx2007 = $oReport.isEx2010 = $oReport.isEx2013 = $oReport.isEx2016 = $oReport.isEx2019 = $false ; 
                    if([double]$ExVersNum = [regex]::match($item.AdminDisplayVersion,"Version\s(\d+\.\d+)\s\(Build\s(\d+\.\d+)\)").groups[1].value){
                        switch -regex ([string]$ExVersNum) {
                            '15.2' { $oReport.isEx2019 = $true ; $oReport.ExVers = 'Ex2019' }
                            '15.1' { $oReport.isEx2016 = $true ; $oReport.ExVers = 'Ex2016'}
                            '15.0' { $oReport.isEx2013 = $true ; $oReport.ExVers = 'Ex2013'}
                            '14.*' { $oReport.isEx2010 = $true ; $oReport.ExVers = 'Ex2010'}
                            '8.*' { $oReport.isEx2007 = $true ; $oReport.ExVers = 'Ex2007'}
                            '6.5' { $oReport.isEx2003 = $true ; $oReport.ExVers = 'Ex2003'}
                            '6' {$oReport.isEx2000 = $true ; $oReport.ExVers = 'Ex2000'} ;
                            default {
                                $smsg = "UNRECOGNIZED ExchangeServer.AdminDisplayVersion string:$($item.AdminDisplayVersion)! ABORTING!" ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                THROW $SMSG ;
                                BREAK ;
                            }
                        } ; 
                        $smsg = "Need `$oReport.ExchangeMajorVersion as well (emulating output of non-dehydrated)" 
                        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
                        $oReport.ExchangeMajorVersion = $ExVersNum
                    }else {
                        $smsg = "UNABLE TO RESOLVE `$ExVersNum from `$item.version:$($item.version)!" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                        else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        throw $smsg ; 
                        break ; 
                    } ;
                } ;
                default {
                    # $item.admindisplayversion.gettype().fullname
                    $smsg = "Unable to detect `$item.admindisplayversion.gettype():$($item.admindisplayversion.gettype().fullname)!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
                    else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                    throw $smsg ; 
                    break ; 
                };  
            }
            $smsg = "(returning  results for $($item.name) to pipeline)" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

            New-Object -TypeName PsObject -Property $oReport | write-output ; 
        } ; 
    } # PROC-E
    END{
        write-verbose  "$((get-date).ToString('HH:mm:ss')):$($sBnr.replace('=v','=^').replace('v=','^='))" ;
    }
}

#*------^ resolve-ExchangeServerVersionTDO.ps1 ^------


#*------v resolve-RecipientEAP.ps1 v------
function resolve-RecipientEAP {
    <#
    .SYNOPSIS
    resolve-RecipientEAP.ps1 - Resolve a recipient against the onprem local EmailAddressPolicies, and return the matching/applicable EAP Policy object
    .NOTES
    Version     : 1.0.0.
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2021-08-18
    FileName    : resolve-RecipientEAP.ps1
    License     : MIT License
    Copyright   : (c) 2021 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell
    AddedCredit : REFERENCE
    AddedWebsite: URL
    AddedTwitter: URL
    REVISIONS
    * 2:16 PM 6/24/2024: rem'd out #Requires -RunasAdministrator; sec chgs in last x mos wrecked RAA detection 
    * 11:21 AM 9/16/2021 string clean
    * 3:27 PM 8/23/2021 revised patched in new preview-EAPUpdate() support; added 
    default EAP cheatsheet output dump to console; suppress get-EAP warning ; 
    revised recipientfilter support to simple ($(existingRcpFltr) -AND (alias -eq $rcp.alias)).
    Much less complicated, should work on any eap with a recip fltr. 
    * 3:00 PM 8/19/2021 tested, fixed perrotpl issue (overly complicated rcpfltr), 
    pulls a single recipient back on a match on any domain. Considered running a 
    blanket 'get all matches' on each, and then post-filtering for target user(s) 
    but: filtered to a single recip in the rcptfilter, takes 8s for @toro.com; for 
    all targeted is's 1m+. And, just running for broad matches, wo considering 
    priority isn't valid: higher priority matches shut down laters, so you *need* 
    to run them in order, one at a time, and quit on first match. You can't try to 
    datacolect & postfilter wo considering priority, given user may match mult EAPs.
    * 11:11 AM 8/18/2021 init
    .DESCRIPTION
    resolve-RecipientEAP.ps1 - Resolve an array of recipients against the onprem local EmailAddressPolicies, and return the matching/applicable EAP Policy object
    Runs a single recipient (rather than an array) because you really can't pre-collect full populations and stop. Need to run the EAPs in priority order, filter population returned, and quit on first match.
    .PARAMETER  Recipient
    Array of recipient descriptors: displayname, emailaddress, UPN, samaccountname[-recip some.user@domain.com]
    .PARAMETER useEXOv2
    Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]
    .PARAMETER useAltFilter
    Switch to attempt broad append '(existing) -AND (Alias -eq '`$(alias)' to eap.recipientfilter, rather than fancy search/replc on clauses (defaulted TRUE) [-useAltFilter]
    .INPUTS
    None. Does not accepted piped input
    .OUTPUTS
    System.Management.Automation.PSCustomObject of matching EAP
    .EXAMPLE
    PS> $matchedEAP = resolve-RecipientEAP -rec SOMEACCT@DOMAIN.COM -verbose ;
    PS> if($matchedEAP){"User matches $($matchedEAP.name"} else { "user matches *NO* existing EAP! (re-run with -verbose for further details)" } ; 
    .EXAMPLE
    "user1@domain.com","user2@domain.com"|%{resolve-RecipientEAP -rec $_ -verbose} ; 
    Foreach-object loop an array of descriptors 
    .LINK
    https://github.com/tostka/verb-ex2010
    #>
    ###Requires -Version 5
    ###Requires -Modules verb-Ex2010 - disabled, moving into the module
    ##Requires -RunasAdministrator
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    ## [OutputType('bool')] # optional specified output type
    [CmdletBinding()]
    PARAM(
        [Parameter(Position=0,Mandatory=$true,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Array of recipient descriptors: displayname, emailaddress, UPN, samaccountname[-recip some.user@domain.com]")]
        #[ValidateNotNullOrEmpty()]
        #[Alias('ALIAS1', 'ALIAS2')]
        $Recipient,
        [Parameter(HelpMessage="Use EXOv2 (ExchangeOnlineManagement) over basic auth legacy connection [-useEXOv2]")]
        [switch] $useEXOv2,
        [Parameter(HelpMessage="Display EmailAddressPolicy format strings 'cheatsheet' (defaults true) [-showCheatsheet]")]
        [switch] $showCheatsheet=$true
    ) ;
    BEGIN{
        $Verbose = ($VerbosePreference -eq 'Continue') ; 
        $rgxEmailAddr = "^([0-9a-zA-Z]+[-._+&'])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,63}$" ; 
        $rgxDName = "^([a-zA-Z]{2,}\s[a-zA-Z]{1,}'?-?[a-zA-Z]{2,}\s?([a-zA-Z]{1,})?)" ; 
        $rgxSamAcctNameTOR = "^\w{2,20}$" ; # up to 20k, the limit prior to win2k
        #$rgxSamAcctName = "^[^\/\\\[\]:;|=,+?<>@?]+$" # no char limit ;
        $propsEAPFiltering = 'EmailAddressPolicyEnabled','CustomAttribute5','primarysmtpaddress','Office','distinguishedname','Recipienttype','RecipientTypeDetails' ; 
        $rgxEmailDirLegalChars = "[0-9a-zA-Z-._+&']" ; 
        $hCheatSheet = @"

Email Address Policy AddressTemplate format variables:
|Vari |Value
|-----|-------------------------------------|
|%d   |Display name                       
|%g   |Given name                         
|%i   |Middle initial                      
|%m   |Exchange alias                      
|%rxy |Replace all occurrences of x with y 
|%rxx |Remove all occurrences of x         
|%s   |Surname                 
|%ng  |The first n letters of the givenname.
|%ns  |The first n letters of the surname. 

All smtpaddr-illegal chars are dropped from source string. 
Commonly-permitted SmtpAddrChars:
$($rgxEmailDirLegalChars)
(RFC 5322 technically permits broader set, but frequently blocked as risks)

"@ ; 
        
        rx10 -Verbose:$false ; 
        #rxo  -Verbose:$false ; cmsol  -Verbose:$false ;

        # move the properties out to a separate vari
        [array]$eapprops = 'name','RecipientFilter','RecipientContainer','EnabledPrimarySMTPAddressTemplate','EnabledEmailAddressTemplates',
            'DisabledEmailAddressTemplates','Enabled' ; 
        # append an expression that if/then's Priority text value: coercing IsNumeric()'s to [int], else - only non-Numeric is 'Default' - replacing that Priority with [int](EAPs.count)+1
        $eapprops += @{Name="Priority";Expression={ 
            if($_.priority.trim() -match "^[-+]?([0-9]*\.[0-9]+|[0-9]+\.?)$"){
                [int]$_.priority 
            } else { 
                [int]($eaps.count+1) 
            }
            } } ; 
       
        # pull EAP's and sub sortable integer values for Priority (Default becomes EAPs.count+1)
        $smsg = "(polling:Get-EmailAddressPolicy...)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        $sw = [Diagnostics.Stopwatch]::StartNew();
        # use -warningaction silentlycontinue to suppress the 'WARNING: Recipient policy objects that don't contain e-mail address won't be shown unless you include the IncludeMailboxSettingOnlyPolicy'
        $eaps = Get-EmailAddressPolicy -WarningAction 0 ;
        $sw.Stop() ;
        $eaps = $eaps | select $eapprops | sort Priority  ; 
        
        $smsg = ("Elapsed Time: {0:dd}d {0:hh}h {0:mm}m {0:ss}s {0:fff}ms" -f $sw.Elapsed) ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                
        
    } 
    PROCESS{
       
        $hSum = [ordered]@{
            OPRcp = $OPRcp;
            xoRcp = $xoRcp;
        } ;
                    
        $sBnr="===vInput: '$($Recipient)' v===" ;
        $smsg = $sBnr ;        
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

        $xMProps="samaccountname","windowsemailaddress","DistinguishedName","Office","RecipientTypeDetails" ;
        
        $pltgM=[ordered]@{} ; 
        $smsg = "processing:'identity':$($Recipient)" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

        $pltgM.add('identity',$Recipient) ;
            
        $smsg = "get-recipient w`n$(($pltgM|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

        rx10 -Verbose:$false -silent ;
        $error.clear() ;

        $sw = [Diagnostics.Stopwatch]::StartNew();
        $hSum.OPRcp=get-recipient @pltgM -ea 0 |?{$_.recipienttypedetails -ne 'MailContact'}
        $sw.Stop() ;
        $smsg = ("Elapsed Time: {0:dd}d {0:hh}h {0:mm}m {0:ss}s {0:fff}ms" -f $sw.Elapsed) ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 


        if($hSum.OPRcp){
            $smsg = "`Matched On-Premesis Recipient:`n$(($hSum.OPRcp|out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 

            $hMsg=@"
Recipient $($hSum.OpRcp.primarysmtpaddress) has the following EmailAddressPolicy-related settings:

$(($hSum.OPRcp | fl $propsEAPFiltering|out-string).trim())

The above settings need to exactly match one or more of the EAP's to generate the desired match...

"@ ;
            
            $smsg = $hMsg ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

            if($hSum.OPRcp.EmailAddressPolicyEnabled -eq $false){
                $smsg = "Recipient $($hSum.OpRcp.primarysmtpaddress) is DISABLED for EAP use:`n" ; 
                $smsg += "$(($hSum.OPRcp | fl EmailAddressPolicy|out-string).trim())`n`n" ; 
                $smsg += "This user will *NOT* be governed by any EAP until this value is reset to `$true!" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } else {
                $smsg = "Recipient $($hSum.OpRcp.primarysmtpaddress) properly has:`n$(($hSum.OPRcp | fl EmailAddressPolicyEnabled|out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            }  ;

            $bBadRecipientType =$false ;
            switch -regex ($hSum.OPRcp.recipienttype){
                "UserMailbox" {
                    $smsg = "'UserMailbox'"
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                } 
                "MailUser" {
                    $smsg = "'MailUser'" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                } ;
                default {
                    $smsg = "Unsupported RecipientType:($hSum.OPRcp.recipienttype). EXITING!" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $bBadRecipientType = $true ;
                    Break ; 
                }
            }

            if(!$bBadRecipientType ){
                $error.clear() ;
                TRY {
                   
                    $matchedEAP = $null ; 
                    $propsEAP = 'name','RecipientFilter','RecipientContainer','Priority','EnabledPrimarySMTPAddressTemplate',
                        'EnabledEmailAddressTemplates','DisabledEmailAddressTemplates','Enabled' ; 
                    $aliasmatch = $hSum.OPRcp.alias ;

                    write-host "`n(Comparing to $(($Eaps|measure).count) EmailAddressPolicies for filter-match...)" ;
                    foreach($eap in $eaps){
                        if(!$verbose){
                            write-host "." -NoNewLine ;
                        } ; 
                        $smsg = "`n`n==$($eap.name):$($eap.RecipientFilter)" ;
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        
                        # try a simple (existing) -AND "Alias -eq '$($aliasmatch)'" filter mod
                        $tmpfilter = "($($eap.recipientfilter)) -and (Alias -eq '$($aliasmatch)')" ; 
                        
                        $smsg = "using `$tmpfilter recipientFilter:`n$($tmpfilter)" ;  
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        $pltGRcpV=[ordered]@{
                            RecipientPreviewFilter=$tmpfilter ;
                            OrganizationalUnit=$eap.RecipientContainer ;
                            resultsize='unlimited';
                            ErrorAction='STOP';
                        } ;
                        $smsg = "get-recipient w`n$(($pltGRcpV|out-string).trim())`n$(($pltGRcpV.RecipientPreviewFilter|out-string).trim())" ; 
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        
                        $sw = [Diagnostics.Stopwatch]::StartNew();
                        if($rcp =get-recipient @pltGRcpV| ?{$_.alias -eq $aliasmatch} ){
                            $sw.Stop() ;
                            write-host "MATCHED!:$($Eap.name)`n" ;
                            $matchedEAP = $eap ;
                            $smsg = ("Elapsed Time: {0:dd}d {0:hh}h {0:mm}m {0:ss}s {0:fff}ms" -f $sw.Elapsed) ; 
                            $smsg = "Matched OnPremRecipient $($Sum.OPRcp.alias) to EAP Preview grp:$($rcp.primarysmtpaddress)`n" ; 
                            $smsg += "filtered under EmailAddressPolicy:`n$(($eap | fl ($propsEAP |?{$_ -ne 'EnabledEmailAddressTemplates'}) |out-string).trim())`n" ; 
                            $smsg += "EnabledEmailAddressTemplates:`n$(($eap | select -expand EnabledEmailAddressTemplates |out-string).trim())`n" ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;

                            $genEml = preview-EAPUpdate  -eap $matchedEAP -Recipient $hSum.OPRcp -Verbose:($VerbosePreference -eq 'Continue')
                            if($geneml -ne $hSum.OPRcp.PrimarySmtpAddress){
                                $smsg = "`n===Specified recip's PrimarySmtpAddress ($hSum.OPRcp.PrimarySmtpAddress))`n"
                                $smsg += "does *not* appear to match specified template!`n" ; 
                                $smsg += "*manualy review* the template specs *validate*`n"
                                $smsg += "that the desired scheme is being applied!`n==="
                                #write-warning $smsg ; 
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            }else {
                                $smsg = "`n===PrimarysmtpAddr $($hSum.OPRcp.PrimarySmtpAddress))`n"
                                $smsg += "roughly conforms to specified template primary addr`n" ;
                                $smsg += "$($matchedEAP.EnabledPrimarySMTPAddressTemplate)...===`n" ;
                                #write-host -foregroundcolor Green $smsg ;
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                                else{ write-host "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                            } ;

                            break ;
                        } else {
                            $sw.Stop() ;
                            $smsg = ("Elapsed Time: {0:dd}d {0:hh}h {0:mm}m {0:ss}s {0:fff}ms" -f $sw.Elapsed) ; 
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
                        } ;
                    }; # E-loop
                    
                    if($showCheatsheet){
                        write-host $hCheatSheet
                    } ; 

                } CATCH {
                    $ErrTrapd=$Error[0] ;
                    $smsg = "Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                    else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    Continue ; 
                } ; 

            } else { 
                 $smsg = "-Recipient:$($Recipient) is of an UNSUPPORTED type by this script! (only Mailbox|MailUser are supported)"   ; 
                 if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
                else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ; 
            
        } else { 
            $smsg = "(no matching EXOP recipient object:$($Recipient))"   
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        } ; 
    } #  PROC-E
    END{
        if( $matchedEAP){
            $matchedEAP | write-output ; 
        } else { 
            $smsg = "Failed to resolve specified recipient $($user) to a matching EmailAddressPolicy" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug 
            else{ write-warning "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            $false | write-output ;
        } ; 
        $smsg = "$($sBnr.replace('=v','=^').replace('v=','^='))" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
     }

     #*======^ END SUB MAIN ^======
 }

#*------^ resolve-RecipientEAP.ps1 ^------


#*------v rx10cmw.ps1 v------
function rx10cmw {
    <#
    .SYNOPSIS
    rx10cmw - Reonnect-EX2010 to specified on-prem Exchange
    .DESCRIPTION
    Reconnect-EX2010 - Reonnect to specified on-prem Exchange
    .EXAMPLE
    rx10cmw
    #>
    [CmdletBinding()] 
        [Alias('rxOPcmw')]
    Param()
    $Verbose = ($VerbosePreference -eq 'Continue') ;
    $pltGHOpCred=@{TenOrg="CMW" ;userrole=@('ESVC','LSVC','SID') ;verbose=$($verbose)} ;
    if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
        ReConnect-EX2010 -cred $OPCred -Verbose:($VerbosePreference -eq 'Continue') ; 
    } else {
        $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole $($UserRole -join '|') value!"
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
        exit ;
    } ;
}

#*------^ rx10cmw.ps1 ^------


#*------v rx10tol.ps1 v------
function rx10tol {
    <#
    .SYNOPSIS
    rx10tol - Reonnect-EX2010 to specified on-prem Exchange
    .DESCRIPTION
    Reconnect-EX2010 - Reonnect to specified on-prem Exchange
    .EXAMPLE
    rx10tol
    #>
    [CmdletBinding()] 
    [Alias('rxOPtol')]
    Param()
    $Verbose = ($VerbosePreference -eq 'Continue') ;
    $pltGHOpCred=@{TenOrg="TOL" ;userrole=@('ESVC','LSVC','SID') ;verbose=$($verbose)} ;
    if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
        ReConnect-EX2010 -cred $OPCred -Verbose:($VerbosePreference -eq 'Continue') ; 
    } else {
        $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole $($UserRole -join '|') value!"
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
        exit ;
    } ;
}

#*------^ rx10tol.ps1 ^------


#*------v rx10tor.ps1 v------
function rx10tor {
    <#
    .SYNOPSIS
    rx10tor - Reonnect-EX2010 to specified on-prem Exchange
    .DESCRIPTION
    Reconnect-EX2010 - Reonnect to specified on-prem Exchange
    .EXAMPLE
    rx10tor
    #>
    [CmdletBinding()] 
    [Alias('rxOPtor')]
    Param()
    $Verbose = ($VerbosePreference -eq 'Continue') ;
    $pltGHOpCred=@{TenOrg="TOR" ;userrole=@('ESVC','LSVC','SID') ;verbose=$($verbose)} ;
    if($OPCred=(get-HybridOPCredentials @pltGHOpCred).cred){
        ReConnect-EX2010 -cred $OPCred -Verbose:($VerbosePreference -eq 'Continue') ; 
    } else {
        $smsg = "Unable to resolve get-HybridOPCredentials -TenOrg $($TenOrg) -userrole $($UserRole -join '|') value!"
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } #Error|Warn|Debug
        else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        throw "Unable to resolve $($tenorg) `$OPCred value!`nEXIT!"
        exit ;
    } ;
}

#*------^ rx10tor.ps1 ^------


#*------v test-ExOPPSession.ps1 v------
Function test-ExOPPSession {
  <#
    .SYNOPSIS
    test-ExOPPSession - Does a *simple* - NO-ORG REVIEW - validation of functional PSSession with: ConfigurationName:'Microsoft.Exchange' -AND Name match  '^(Exchange2010|Session\sfor\simplicit\sremoting\smodule\sat\s.*)' -AND State:'Opened' -AND Availability:'Available' -AND can gcm -name 'Add-ADPermission'
    .NOTES
    Author: Todd Kadrie
    Website:	http://toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    Version     : 1.0.0
    CreatedDate : 2021-04-15
    FileName    : test-ExOPPSession()
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Exchange,Exchange-2013,Exchange-2016
    REVISIONS   :
    * 12:30 PM 5/3/2021 init vers ; revised rgxRemsPSSName
    .DESCRIPTION
    test-ExOPPSession - Does a *simple* - NO-ORG REVIEW - validation of functional PSSession with: ConfigurationName:'Microsoft.Exchange' -AND Name match  '^(Exchange2010|Session\sfor\simplicit\sremoting\smodule\sat\s.*)' -AND State:'Opened' -AND Availability:'Available' -AND can gcm -name 'Add-ADPermission'.
    This does *NO* validation that any specific EXOnPrem org is attached! It just validates that an existing PSSession *exists* that *generically* matches a Remote Exchange Mgmt Shell connection in a usable state. Use case is scripts/functions that *assume* you've already pre-established a suitable connection, and just need to pre-test that *any* PSS is already open, before attempting commands. 
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    System.Management.Automation.Runspaces.PSSession. Returns the functional PSSession object(s)
    .EXAMPLE
    PS> if(test-ExOPPSession){'OK'} else { 'NOGO!'}  ;
    .LINK
    https://github.com/tostka/verb-Ex2010/
    #>
    [CmdletBinding()]
    #[Alias()]
    Param()  ;
    BEGIN{
        $verbose = ($VerbosePreference -eq "Continue") ;
        $rgxRemsPSSName = "^(Exchange\d{4})$" ; 
        $testCommand = 'Add-ADPermission' ; 
        $propsREMS = 'Id','Name','ComputerName','ComputerType','State','ConfigurationName','Availability' ; 
    } ;  # BEG-E
    PROCESS{
        $error.clear() ;
        TRY {
            if($RemsGood = Get-PSSession | where-object { ($_.ConfigurationName -eq "Microsoft.Exchange") -AND ($_.Name -match $rgxRemsPSSName) -AND ($_.State -eq "Opened") -AND ($_.Availability -eq 'Available') }){
                $smsg = "valid EMS PSSession found:`n$(($RemsGood|ft -a $propsREMS |out-string).trim())" ; 
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                else{ write-VERBOSE "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                
                if($tmod = (get-command -name $testCommand).source){
                    $smsg = "(confirmed PSSession open/available, with $($testCommand) available)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $RemsGood | write-output ; ;
                } else { 
                    throw "NO FUNCTIONAL PSSESSION FOUND!" ; 
                } ; 
            } else {
                throw "No existing open/available Remote Exchange Management Shell found!"
            } ;
        } CATCH {
            $ErrTrapd = $_ ;
            write-warning "$(get-date -format 'HH:mm:ss'): Failed processing $($ErrTrapd.Exception.ItemName). `nError Message: $($ErrTrapd.Exception.Message)`nError Details: $($ErrTrapd)" ;
            #-=-record a STATUSERROR=-=-=-=-=-=-=
            $statusdelta = ";ERROR"; # CHANGE|INCOMPLETE|ERROR|WARN|FAIL ;
            if(gv passstatus -scope Script -ea 0 ){$script:PassStatus += $statusdelta } ;
            if(gv -Name PassStatus_$($tenorg) -scope Script  -ea 0 ){set-Variable -Name PassStatus_$($tenorg) -scope Script -Value ((get-Variable -Name PassStatus_$($tenorg)).value + $statusdelta)} ;
            #-=-=-=-=-=-=-=-=
        } ;
        
    } ;  # PROC-E
    END {}
}

#*------^ test-ExOPPSession.ps1 ^------


#*------v test-EXOPStatus.ps1 v------
function test-EXOPConnection {
    <#
    .SYNOPSIS
    test-EXOPConnection.ps1 - Validate EXOP connection, and that the proper Tenant is connected (as per provided Credential)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-06-24
    FileName    : test-EXOPConnection.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-EXO
    Tags        : Powershell
    REVISIONS
    * 8:40 AM 6/23/2023 rmvd req's: ps3, just clutters, most mods aren't using a rev req drop it.
    * 2:23 PM 4/17/2023 pulled MinNoWinRMVersion refs (spurious)
    *11:44 AM 9/12/2022 init ; port Test-EXO2Connection to EXOP support
    .DESCRIPTION
    test-EXOPConnection.ps1 - Validate EXOP connection, and that the proper Tenant is connected (as per provided Credential)
    .PARAMETER Credential
    Credential to be used for connection
    .OUTPUT
    System.Boolean
    .EXAMPLE
    PS> $oRet = test-EXOPConnection -verbose ; 
    PS> if($oRet.Valid){
    PS>     $pssEXOP = $oRet.PsSession ; 
    PS>     write-host 'Validated EXOv2 Connected to Tenant aligned with specified Credential'
    PS> } else { 
    PS>     write-warning 'NO EXO USERMAILBOX TYPE LICENSE!'
    PS> } ; 
    Evaluate EXOP connection status with verbose output
    .LINK
    https://github.com/tostka/verb-EXO
    #>
    # VALIDATORS: [ValidateNotNull()][ValidateNotNullOrEmpty()][ValidateLength(24,25)][ValidateLength(5)][ValidatePattern("some\sregex\sexpr")][ValidateSet("USEA","GBMK","AUSYD")][ValidateScript({Test-Path $_ -PathType 'Container'})][ValidateScript({Test-Path $_})][ValidateRange(21,65)][ValidateCount(1,3)]
    [CmdletBinding()]
     Param(
        [Parameter(Mandatory=$False,HelpMessage="Credentials [-Credentials [credential object]]")]
        [System.Management.Automation.PSCredential]$Credential = $global:credOpTORSID
    )
    BEGIN {
        ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
        $Verbose = ($VerbosePreference -eq 'Continue') ;
        
        
        #*------v PSS & GMO VARIS v------
        # get-pssession session varis
        # select key differentiating properties:
        $pssprops = 'Id','ComputerName','ComputerType','State','ConfigurationName','Availability', 
            'Description','Guid','Name','Path','PrivateData','RootModuleModule', 
            @{name='runspace.ConnectionInfo.ConnectionUri';Expression={$_.runspace.ConnectionInfo.ConnectionUri} },  
            @{name='runspace.ConnectionInfo.ComputerName';Expression={$_.runspace.ConnectionInfo.ComputerName} },  
            @{name='runspace.ConnectionInfo.Port';Expression={$_.runspace.ConnectionInfo.Port} },  
            @{name='runspace.ConnectionInfo.AppName';Expression={$_.runspace.ConnectionInfo.AppName} },  
            @{name='runspace.ConnectionInfo.Credentialusername';Expression={$_.runspace.ConnectionInfo.Credential.username} },  
            @{name='runspace.ConnectionInfo.AuthenticationMechanism';Expression={$_.runspace.ConnectionInfo.AuthenticationMechanism } },  
            @{name='runspace.ExpiresOn';Expression={$_.runspace.ExpiresOn} } ; 
        
        if(-not $EXoPConfigurationName){$EXoPConfigurationName = "Microsoft.Exchange" };
        if(-not $rgxEXoPrunspaceConnectionInfoAppName){$rgxEXoPrunspaceConnectionInfoAppName = '^/(exadmin|powershell)$'}; 
        if(-not $EXoPrunspaceConnectionInfoPort){$EXoPrunspaceConnectionInfoPort = '80' } ; 
                
        # gmo varis
        # EXOP
        if(-not $rgxExoPsessionstatemoduleDescription){$rgxExoPsessionstatemoduleDescription = '/(exadmin|powershell)$' };
        if(-not $PSSStateOK){$PSSStateOK = 'Opened' };
        if(-not $PSSAvailabilityOK){$PSSAvailabilityOK = 'Available' };
        if(-not $EXOPGmoFilter){$EXOPGmoFilter = 'tmp_*' } ; 
        if(-not $EXOPGmoTestCmdlet){$EXOPGmoTestCmdlet = 'Add-ADPermission' } ; 
        #*------^ END PSS & GMO VARIS ^------

        # exop is dyn remotemod, not installed
        <#Try { Get-Module $modname -ErrorAction Stop | out-null } Catch {
            $smsg = "Import-Module w`n$(($pltIMod|out-string).trim())" ;
            if($silent){}elseif($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            Import-Module @pltIMod ;
        } ; # IsImported
        [boolean]$IsNoWinRM = [boolean]([version](get-module $modname).version -ge $MinNoWinRMVersion) ; 
        #>

    } ;  # if-E BEGIN    
    PROCESS {
        $oReturn = [ordered]@{
            PSSession = $null ; 
            Valid = $false ; 
        } ; 
        $isEXOPValid = $false ;
        
        if($pssEXOP = Get-PSSession |?{ (
            $_.runspace.connectioninfo.appname -match $rgxEXoPrunspaceConnectionInfoAppName) -AND (
            $_.runspace.connectioninfo.port -eq $EXoPrunspaceConnectionInfoPort) -AND (
            $_.ConfigurationName -eq $EXoPConfigurationName)}){
                    <# rem'd state/avail tests, run separately below: -AND (
                    $_.State -eq $PSSStateOK)  -AND (
                    $_.Availability -eq $PSSAvailabilityOK)
                    #>
            $smsg = "`n`nEXOP PSSessions:`n$(($pssEXOP | fl $pssprops|out-string).trim())" ; 
            if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
            else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 

            if($pssEXOPGood = $pssEXOP | ?{ ($_.State -eq $PSSStateOK)  -AND (
                    $_.Availability -eq $PSSAvailabilityOK)}){

                # verify the exop cmdlets actually imported as a tmp_ module w specifid prefix & 1st cmdlet
                # tmp_prpfxxlb.ozy
                if ( (get-module -name $EXOPGmoFilter | ForEach-Object { 
                    Get-Command -module $_.name -name $EXOPGmoTestCmdlet -ea 0 
                })) {

                    $smsg = "(EXOPGmo Basic-Auth PSSession module detected)" ; 
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } #Error|Warn|Debug 
                    else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    $isEXOPValid = $true ; 
                } else { $isEXOPValid = $false ; }
            } else{
                # pss but disconnected state
                rxo2 ; 
            } ; 
            
        } else { 
            $smsg = "Unable to detect EXOP PSSession!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-host -ForegroundColor yellow "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            #throw $smsg ;
            #Break ; 
            $isEXOPValid = $false ; 
        } ; 

        if($isEXOPValid){
            $oReturn.PSSession = $pssEXOPGood ;
            $oReturn.Valid = $isEXOPValid ; 
        } else { 
            $smsg = "(invalid session `$isEXOPValid:$($isEXOPValid))" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN } 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            Disconnect-ex2010 ;
            $oReturn.PSSession = $pssEXOPGood ; 
            $oReturn.Valid = $isEXOPValid ; 
        } ; 

    }  # PROC-E
    END{
        $smsg = "Returning `$oReturn:`n$(($oReturn|out-string).trim())" ; 
        if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } 
        else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
        New-Object PSObject -Property $oReturn | write-output ; 
    } ;
}

#*------^ test-EXOPStatus.ps1 ^------


#*------v test-LocalExchangeInfoTDO.ps1 v------
function test-LocalExchangeInfoTDO {
        
        <#
        .SYNOPSIS
        test-LocalExchangeInfoTDO.ps1 - Checks local environment for evidence of a local Exchangeserver install, the version installed, and wether Edge Role. Returns a summary object to the pipeline.
        .NOTES
        Version     : 1.0.0
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2025-05-09
        FileName    : test-LocalExchangeInfoTDO.ps1
        License     : MIT License
        Copyright   : (c) 2025 Todd Kadrie
        Github      : https://github.com/tostka/verb-Network
        Tags        : Powershell
        AddedCredit : Fabian Bader
        AddedWebsite: https://cloudbrothers.info/en/
        AddedTwitter: 
        REVISION
        * 12:53 PM 5/13/2025 swaped w-h -> w-v
        * 10:10 AM 5/12/2025 added -whatif:$false -confirm:$false to nested set-variable cmds - SSP prevents set-vari updates, just like any other action verb cmdlet.
        * 1:44 PM 5/9/2025 init
        .DESCRIPTION
        test-LocalExchangeInfoTDO.ps1 - Checks local environment for evidence of a local Exchangeserver install, the version installed, and wether Edge Role. Returns a summary object to the pipeline.
            
        Returns a psCustomObject summarizing the environment findings, in re: local Exchange server fingerprints:

            Name                           Value
            ----                           -----
            isLocalExchangeServer          True
            IsEdgeTransport                False
            ExVers                         Ex2010
            isEx2019                       False
            isEx2016                       False
            isEx2013                       False
            isEx2010                       True
            isEx2007                       False
            isEx2003                       False
            isEx2000                       False

        .INPUTS
        Does not accept piped input
        .OUTPUTS
        System.Management.Automation.PSCustomObject environment summary object with following properties:

            isLocalExchangeServer          [boolean]
            IsEdgeTransport                [boolean]
            ExVers                         [version]
            isEx2019                       [boolean]
            isEx2016                       [boolean]
            isEx2013                       [boolean]
            isEx2010                       [boolean]
            isEx2007                       [boolean]
            isEx2003                       [boolean]
            isEx2000                       [boolean] 

        .EXAMPLE
        PS> $results = test-LocalExchangeInfoTDO ; 
        PS> $results ; 

            Name                           Value
            ----                           -----
            isLocalExchangeServer          True
            IsEdgeTransport                False
            ExVers                         Ex2010
            isEx2019                       False
            isEx2016                       False
            isEx2013                       False
            isEx2010                       True
            isEx2007                       False
            isEx2003                       False
            isEx2000                       False
        
        PS> write-verbose "Expand returned NoteProperty properties into matching local variables" ; 
        PS> if($host.version.major -gt 2){
        PS>     $results.PsObject.Properties | ?{$_.membertype -eq 'NoteProperty'} | %{set-variable -name $_.name -value $_.value -verbose -whatif:$false -Confirm:$false ;} ;
        PS> }else{
        PS>     write-verbose "Psv2 lacks the above expansion capability; just create simpler variable set" ; 
        PS>     $ExVers = $results.ExVers ; $isLocalExchangeServer = $results.isLocalExchangeServer ; $IsEdgeTransport = $results.IsEdgeTransport ;
        PS> } ;

            VERBOSE: Performing the operation "Set variable" on target "Name: isEx2003 Value: False".
            VERBOSE: Performing the operation "Set variable" on target "Name: isEx2013 Value: False".
            VERBOSE: Performing the operation "Set variable" on target "Name: isEx2010 Value: False".
            VERBOSE: Performing the operation "Set variable" on target "Name: isEx2019 Value: False".
            VERBOSE: Performing the operation "Set variable" on target "Name: isEx2000 Value: False".
            VERBOSE: Performing the operation "Set variable" on target "Name: IsEdgeTransport Value: False".
            VERBOSE: Performing the operation "Set variable" on target "Name: isEx2016 Value: True".
            VERBOSE: Performing the operation "Set variable" on target "Name: isLocalExchangeServer Value: True".
            VERBOSE: Performing the operation "Set variable" on target "Name: isEx2007 Value: False".
            VERBOSE: Performing the operation "Set variable" on target "Name: ExVers Value: Ex2016".

        Demo pass with follow-on expansion of return pscustomobject into matching individual variables (or, on PSv2, which support for syntax above, expansion , the simpler $ExVers, $isLocalExchangeserver & $IsEdgeTransport variables).
        .LINK
        https://github.com/tostka/verb-Ex2010
        #>
        [CmdletBinding()]
        #[Alias('')]
        PARAM ()    
        PROCESS {
            #$isLocalExchangeServer = $IsEdgeTransport = $isEx2019 =  $isEx2016 =  $isEx2013 =  $isEx2010 =  $isEx2007 =  $isEx2003 =  $isEx2000 = $false ; 
            if($host.version.major -ge 3){$hSummary=[ordered]@{Dummy = $null ;} }
            else {$hSummary = $hSummary = @{Dummy = $null ;} } ;
            if($hSummary.keys -contains 'dummy'){$hSummary.remove('Dummy') };
            $fieldsBoolean = 'isLocalExchangeServer','IsEdgeTransport','isEx2019','isEx2016','isEx2010','isEx2007','isEx2003','isEx2000' | sort ; $fieldsBoolean | % { $hSummary.add($_,$false) } ;
            $fieldsnull = 'ExVers'  | sort ; $fieldsnull | % { $hSummary.add($_,$null) } ;
            <# creates equiv to hashtable:
            $hSummary = @{
                isLocalExchangeServer = $false ; 
                IsEdgeTransport = $false ; 
                ExVers = $null ;  
                isEx2019 = $false ; 
                isEx2016 = $false ; 
                isEx2013 = $false ; 
                isEx2010 = $false ; 
                isEx2007 = $false ; 
                isEx2003 = $false ; 
                isEx2000 = $false ; 
            } ; 
            #>
            if($env:ExchangeInstalled){
                $hSummary.isLocalExchangeServer = $true ;
            } elseif((get-service MSEx* -ea 0) -AND  ($hklmPath = (resolve-path "HKLM:\SOFTWARE\Microsoft\ExchangeServer\v1*\Setup").path)){
                $hSummary.isLocalExchangeServer = $true ;
                switch -regex ($hklmPath){
                    '\\v14\\'{$isEx2010 = $true ; $hSummary.ExVers = 'Ex2010' ; write-verbose "Ex2010" ; }
                    '\\v15\\'{write-verbose "\v115\Setup == Ex2016/Ex2019"}
                    default {
                        $smsg = "Unable to manually resolve $($hklmPath) to a known version path!" ;
                        write-warning $smsg ;
                        throw $smsg ;
                    }
                } ;
            } else {
                write-verbose "hSummary.isLocalExchangeServer:$false" ;
                $hSummary.isLocalExchangeServer = $false ;
            } ;
            if($hSummary.isLocalExchangeServer){
                if((get-service MSExchangeEdgeCredential -ea 0) -AND (Test-Path 'HKLM:\SOFTWARE\Microsoft\ExchangeServer\v1*\EdgeTransportRole')){$hSummary.IsEdgeTransport = $true} ;
                if($vers = (get-item "$($env:ExchangeInstallPath)\Bin\Setup.exe" -ea 0).VersionInfo.FileVersionRaw ){} else {
                    if($binPath = (resolve-path  "$($env:ProgramFiles)\Microsoft\Exchange Server\V1*\Bin\Setup.exe" -ea 0).path){ } else {
                        (get-psdrive -PSProvider FileSystem |?{$_ -match '[D-Z]'}  | select -expand name)|foreach-object{
                            $drv = $_ ;
                            if($rp = resolve-path  "$($drv)$($env:ProgramFiles.substring(1,($env:ProgramFiles.length-1)))\Microsoft\Exchange Server\V1*\Bin\Setup.exe" -ea 0){
                                $binPath = $rp.path;
                                if($host.version.major -gt 2){break} else {write-verbose "PSv2 breaks entire script w break, instead of branching out of local loop" } ;
                            } ;
                        };
                    } ;
                    if($binPath){
                        if( ($vers = (get-item $binPath).VersionInfo.FileVersionRaw) -OR ($vers = (get-item $binPath).VersionInfo.FileVersion) ){
                        }else {
                            $smsg = "Unable to manually resolve an `$env:ExchangeInstallPath equiv, on any local drive" ;
                            write-warning $smsg ;
                            throw $smsg ;
                        }
                    } ;
                } ;
            } ;
            if($hSummary.isLocalExchangeServer){
                if($vers){
                    switch -regex ($vers){
                        '15\.2' { $hSummary.isEx2019 = $true ; $hSummary.ExVers = 'Ex2019' }
                        '15\.1' { $hSummary.isEx2016 = $true ; $hSummary.ExVers = 'Ex2016'}
                        '15\.0' { $hSummary.isEx2013 = $true ; $hSummary.ExVers = 'Ex2013'}
                        '14\..*' { $hSummary.isEx2010 = $true ; $hSummary.ExVers = 'Ex2010'}
                        '8\..*' { $hSummary.isEx2007 = $true ; $hSummary.ExVers = 'Ex2007'}
                        '6\.5' { $hSummary.isEx2003 = $true ; $hSummary.ExVers = 'Ex2003'}
                        '6|6\.0' {$hSummary.isEx2000 = $true ; $hSummary.ExVers = 'Ex2000'} ;
                        default{ throw "[$($vers.tostring())]: Unrecognized version!" } ;
                    } ;
                }else {
                    throw "Empty `$vers resolved ExchangeVersion string variable!"
                } ; 
                $smsg = @("`$hSummary.ExVers: $($hSummary.ExVers)") ;
                $smsg += @("`$$((gv "is$($hSummary.ExVers)" -ea 0).name): $((gv "is$($hSummary.ExVers)"  -ea 0).value)") ;
                if($hSummary.IsEdgeTransport){ $smsg += @("`$hSummary.IsEdgeTransport: $($hSummary.IsEdgeTransport)") } else { $smsg += @(" (non-Edge)")} ;
                $smsg = ($smsg -join ' ') ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } else {
                $smsg = "(non-Local ExchangeServer (`$hSummary.isLocalExchangeServer:$([boolean]$hSummary.isLocalExchangeServer )))" ;
                if($verbose){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } 
                else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ; 
            } ;
        } ; 
        END {
            [pscustomobject]$hSummary | write-output 
        }
    }

#*------^ test-LocalExchangeInfoTDO.ps1 ^------


#*------v toggle-ForestView.ps1 v------
Function toggle-ForestView {
<#
.SYNOPSIS
toggle-ForestView.ps1 - Toggle Exchange onprem AD ViewEntireForest setting (permits org-wide object access, wo use of proper explicit -domaincontroller sub.domain.com)
.NOTES
Version     : 1.0.2
Author      : Todd Kadrie
Website     : http://www.toddomation.com
Twitter     : @tostka / http://twitter.com/tostka
CreatedDate : 2020-10-26
FileName    : 
License     : MIT License
Copyright   : (c) 2020 Todd Kadrie
Github      : https://github.com/tostka/verb-XXX
Tags        : Powershell
REVISIONS
* 10:53 AM 4/2/2021 typo fix
* 10:07 AM 10/26/2020 added CBH
.DESCRIPTION
toggle-ForestView.ps1 - Toggle Exchange onprem AD ViewEntireForest setting (permits org-wide object access, wo use of proper explicit -domaincontroller sub.domain.com)
.INPUTS
None. Does not accepted piped input.
.OUTPUTS
None. Returns no objects or output
.EXAMPLE
toggle-ForestView
.LINK
https://github.com/tostka/verb-ex2010
.LINK
#>
[CmdletBinding()]
PARAM() ;
    # toggle forest view
    if (get-command -name set-AdServerSettings){ 
        if (!(get-AdServerSettings).ViewEntireForest ) {
              write-warning "Enabling WholeForest"
              write-host "`a"
              if (get-command -name set-AdServerSettings -ea 0) { set-AdServerSettings -ViewEntireForest $TRUE } ;
        } else {
          write-warning "Disabling WholeForest"
          write-host "`a"
          set-AdServerSettings -ViewEntireForest $FALSE ;
        } ;
    } else {
        THROW "MISSING:set-AdServerSettings`nOPEN an Exchange OnPrem connection FIRST!"
    } ; 
}

#*------^ toggle-ForestView.ps1 ^------


#*======^ END FUNCTIONS ^======

Export-ModuleMember -Function add-MailboxAccessGrant,add-MbxAccessGrant,_cleanup,Connect-Ex2010,Connect-ExchangeServerTDO,_connect-ExOP,get-ADExchangeServerTDO,Connect-Ex2010XO,Connect-ExchangeServerTDO,_connect-ExOP,connect-OPServices,Connect-ExchangeServerTDO,_connect-ExOP,get-ADExchangeServerTDO,load-ADMS,get-GCFast,2b4,2b4c,fb4,cx10cmw,cx10tol,cx10tor,disable-ForestView,Disconnect-Ex2010,enable-ForestView,get-ADExchangeServerTDO,get-DAGDatabaseCopyStatus,Get-ExchServerFromExServersGroup,get-ExRootSiteOUs,get-MailboxDatabaseQuotas,Get-MessageTrackingLogTDO,resolve-EnvironmentTDO,write-log,Start-Log,Connect-ExchangeServerTDO,_connect-ExOP,get-ADExchangeServerTDO,load-ADMS,get-GCFast,resolve-NetworkLocalTDO,out-Clipboard,convertFrom-MarkdownTable,Remove-InvalidVariableNameChars,remove-SmtpPlusAddress,Initialize-xopEventIDTable,2b4,2b4c,fb4,get-UserMailADSummary,get-xopServerAdminDisplayVersion,import-EMSLocalModule,Initialize-xopEventIDTable,Invoke-ExchangeCommand,load-EMSLatest,Load-EMSSnap,new-MailboxGenericTOR,_cleanup,new-MailboxShared,preview-EAPUpdate,Reconnect-Ex2010,Reconnect-Ex2010XO,remove-EMSLocalModule,remove-SmtpPlusAddress,resolve-ExchangeServerVersionTDO,resolve-RecipientEAP,rx10cmw,rx10tol,rx10tor,test-ExOPPSession,test-EXOPConnection,test-LocalExchangeInfoTDO,toggle-ForestView -Alias *



